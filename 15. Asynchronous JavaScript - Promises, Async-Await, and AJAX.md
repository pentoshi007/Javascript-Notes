---


## 🤝 Promises: The Modern Solution

Promises represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They provide a much cleaner alternative to callbacks and solve the callback hell problem.

### Understanding Promises

```javascript
/**
 * PROMISES: THE MODERN ASYNC SOLUTION
 * 
 * A Promise is an object representing the eventual completion or failure
 * of an asynchronous operation. It's a placeholder for a future value.
 */

console.log('=== Promises Deep Dive ===');

/**
 * PROMISE STATES AND LIFECYCLE
 * 
 * A Promise can be in one of three states:
 * - Pending: Initial state, neither fulfilled nor rejected
 * - Fulfilled: Operation completed successfully
 * - Rejected: Operation failed
 */

function demonstratePromiseStates() {
    console.log('\n🔄 Promise States and Lifecycle:');
    
    // Create a promise that demonstrates all states
    function createDemoPromise(shouldSucceed, delay = 1000) {
        console.log('📦 Creating new Promise (initially PENDING)');
        
        return new Promise((resolve, reject) => {
            console.log('🔄 Promise executor function running immediately');
            console.log('   State: PENDING');
            
            setTimeout(() => {
                if (shouldSucceed) {
                    console.log('✅ Promise FULFILLED (resolved)');
                    resolve('Success! Operation completed');
                } else {
                    console.log('❌ Promise REJECTED');
                    reject(new Error('Operation failed'));
                }
            }, delay);
        });
    }
    
    // Demonstrate successful promise
    console.log('\n1. Successful Promise:');
    const successPromise = createDemoPromise(true, 800);
    
    successPromise
        .then(result => {
            console.log('🎉 Success handler called:', result);
        })
        .catch(error => {
            console.log('💥 Error handler called:', error.message);
        });
    
    // Demonstrate failed promise
    setTimeout(() => {
        console.log('\n2. Failed Promise:');
        const failPromise = createDemoPromise(false, 500);
        
        failPromise
            .then(result => {
                console.log('🎉 Success handler called:', result);
            })
            .catch(error => {
                console.log('💥 Error handler called:', error.message);
            });
    }, 1200);
}

demonstratePromiseStates();

/**
 * CREATING PROMISES: THE PROMISE CONSTRUCTOR
 * 
 * The Promise constructor takes an executor function with resolve and reject parameters.
 */

function demonstratePromiseCreation() {
    console.log('\n🏗️ Creating Promises:');
    
    // Basic Promise creation
    function createBasicPromise() {
        return new Promise((resolve, reject) => {
            // Executor function runs immediately
            console.log('🔄 Executor function running...');
            
            // Simulate async operation
            const randomDelay = Math.random() * 2000 + 500;
            const willSucceed = Math.random() > 0.3;
            
            setTimeout(() => {
                if (willSucceed) {
                    // Resolve with a value
                    resolve({
                        success: true,
                        data: 'Operation completed successfully',
                        timestamp: new Date().toISOString()
                    });
                } else {
                    // Reject with an error
                    reject(new Error('Random failure occurred'));
                }
            }, randomDelay);
        });
    }
    
    // Promise with validation
    function createValidatedPromise(input) {
        return new Promise((resolve, reject) => {
            // Immediate validation
            if (!input) {
                reject(new Error('Input is required'));
                return; // Important: return after reject
            }
            
            if (typeof input !== 'string') {
                reject(new Error('Input must be a string'));
                return;
            }
            
            // Async processing
            setTimeout(() => {
                const processedData = {
                    original: input,
                    processed: input.toUpperCase(),
                    length: input.length,
                    processedAt: new Date()
                };
                
                resolve(processedData);
            }, 1000);
        });
    }
    
    // Test basic promise
    console.log('1. Basic Promise:');
    createBasicPromise()
        .then(result => console.log('✅ Basic promise result:', result))
        .catch(error => console.log('❌ Basic promise error:', error.message));
    
    // Test validated promise - success case
    setTimeout(() => {
        console.log('\n2. Validated Promise - Success:');
        createValidatedPromise('hello world')
            .then(result => console.log('✅ Validated promise result:', result))
            .catch(error => console.log('❌ Validated promise error:', error.message));
    }, 1500);
    
    // Test validated promise - error case
    setTimeout(() => {
        console.log('\n3. Validated Promise - Error:');
        createValidatedPromise(null)
            .then(result => console.log('✅ This should not run:', result))
            .catch(error => console.log('❌ Expected error:', error.message));
    }, 2000);
}

// Run promise creation demo
setTimeout(demonstratePromiseCreation, 3000);

/**
 * CONSUMING PROMISES: .then(), .catch(), .finally()
 * 
 * Promises are consumed using .then() for success, .catch() for errors,
 * and .finally() for cleanup that runs regardless of outcome.
 */

function demonstratePromiseConsumption() {
    console.log('\n🍽️ Consuming Promises:');
    
    // Helper function to create test promises
    function createTestPromise(name, shouldSucceed, delay = 1000) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (shouldSucceed) {
                    resolve(`${name} completed successfully`);
                } else {
                    reject(new Error(`${name} failed`));
                }
            }, delay);
        });
    }
    
    // Basic .then() and .catch()
    console.log('1. Basic Promise Consumption:');
    
    createTestPromise('Operation A', true, 800)
        .then(result => {
            console.log('✅ Success:', result);
            return 'Additional processing done'; // Return value for next .then()
        })
        .then(additionalResult => {
            console.log('✅ Chained result:', additionalResult);
        })
        .catch(error => {
            console.log('❌ Error:', error.message);
        })
        .finally(() => {
            console.log('🏁 Finally block: cleanup operations');
        });
    
    // Error handling
    setTimeout(() => {
        console.log('\n2. Error Handling:');
        
        createTestPromise('Operation B', false, 600)
            .then(result => {
                console.log('✅ This should not run:', result);
            })
            .catch(error => {
                console.log('❌ Caught error:', error.message);
                return 'Error handled gracefully'; // Recovery
            })
            .then(recoveryResult => {
                console.log('🔄 Recovery result:', recoveryResult);
            })
            .finally(() => {
                console.log('🏁 Cleanup after error handling');
            });
    }, 1200);
    
    // Multiple .then() handlers
    setTimeout(() => {
        console.log('\n3. Multiple Handlers:');
        
        const promise = createTestPromise('Operation C', true, 400);
        
        // Multiple independent handlers
        promise.then(result => console.log('Handler 1:', result));
        promise.then(result => console.log('Handler 2:', result.toUpperCase()));
        promise.then(result => console.log('Handler 3: Length =', result.length));
        
        // vs. Chained handlers (different behavior)
        promise
            .then(result => {
                console.log('Chained 1:', result);
                return result + ' + extra';
            })
            .then(result => {
                console.log('Chained 2:', result);
            });
    }, 2000);
}

// Run consumption demo
setTimeout(demonstratePromiseConsumption, 6000);
```

### Creating Custom Promises

```javascript
/**
 * CREATING CUSTOM PROMISES: REAL-WORLD EXAMPLES
 * 
 * Let's build practical, reusable promise-based functions that solve
 * common asynchronous programming challenges.
 */

console.log('\n=== Creating Custom Promises ===');

/**
 * CUSTOM PROMISE: DELAY FUNCTION
 * 
 * A utility function that creates a promise-based delay.
 */

function delay(ms, value = undefined) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(value);
        }, ms);
    });
}

// Usage examples
function demonstrateDelayPromise() {
    console.log('\n⏰ Custom Delay Promise:');
    
    console.log('Starting delay...');
    
    delay(1000, 'Delay completed!')
        .then(result => {
            console.log('✅', result);
            return delay(500, 'Another delay done!');
        })
        .then(result => {
            console.log('✅', result);
        });
}

demonstrateDelayPromise();

/**
 * CUSTOM PROMISE: TIMEOUT WRAPPER
 * 
 * Wraps any promise with a timeout, rejecting if it takes too long.
 */

function withTimeout(promise, timeoutMs, timeoutMessage = 'Operation timed out') {
    return new Promise((resolve, reject) => {
        // Create timeout promise
        const timeoutPromise = new Promise((_, timeoutReject) => {
            setTimeout(() => {
                timeoutReject(new Error(timeoutMessage));
            }, timeoutMs);
        });
        
        // Race between original promise and timeout
        Promise.race([promise, timeoutPromise])
            .then(resolve)
            .catch(reject);
    });
}

function demonstrateTimeoutPromise() {
    console.log('\n⏱️ Custom Timeout Promise:');
    
    // Fast operation (should succeed)
    const fastOperation = delay(800, 'Fast operation completed');
    
    withTimeout(fastOperation, 1000, 'Fast operation timed out')
        .then(result => console.log('✅ Fast result:', result))
        .catch(error => console.log('❌ Fast error:', error.message));
    
    // Slow operation (should timeout)
    setTimeout(() => {
        const slowOperation = delay(2000, 'Slow operation completed');
        
        withTimeout(slowOperation, 1000, 'Slow operation timed out')
            .then(result => console.log('✅ Slow result:', result))
            .catch(error => console.log('❌ Slow error:', error.message));
    }, 1200);
}

setTimeout(demonstrateTimeoutPromise, 2000);

/**
 * CUSTOM PROMISE: RETRY MECHANISM
 * 
 * Automatically retries a failed operation with exponential backoff.
 */

function retry(operation, maxAttempts = 3, baseDelay = 1000) {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        
        function attempt() {
            attempts++;
            console.log(`🔄 Attempt ${attempts}/${maxAttempts}`);
            
            operation()
                .then(resolve) // Success - resolve immediately
                .catch(error => {
                    if (attempts >= maxAttempts) {
                        console.log(`❌ All ${maxAttempts} attempts failed`);
                        reject(error);
                    } else {
                        // Calculate exponential backoff delay
                        const retryDelay = baseDelay * Math.pow(2, attempts - 1);
                        console.log(`⏳ Retrying in ${retryDelay}ms...`);
                        
                        setTimeout(attempt, retryDelay);
                    }
                });
        }
        
        attempt(); // Start first attempt
    });
}

function demonstrateRetryPromise() {
    console.log('\n🔄 Custom Retry Promise:');
    
    // Simulate unreliable operation
    function unreliableOperation() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                // 70% chance of failure
                if (Math.random() < 0.7) {
                    reject(new Error('Random failure'));
                } else {
                    resolve('Operation succeeded!');
                }
            }, 300);
        });
    }
    
    retry(unreliableOperation, 4, 500)
        .then(result => console.log('🎉 Final success:', result))
        .catch(error => console.log('💥 Final failure:', error.message));
}

setTimeout(demonstrateRetryPromise, 4000);

/**
 * CUSTOM PROMISE: RATE LIMITER
 * 
 * Limits the rate of promise execution to prevent overwhelming APIs.
 */

class RateLimiter {
    constructor(maxConcurrent = 3, delayBetween = 100) {
        this.maxConcurrent = maxConcurrent;
        this.delayBetween = delayBetween;
        this.running = 0;
        this.queue = [];
    }
    
    async execute(promiseFactory) {
        return new Promise((resolve, reject) => {
            this.queue.push({ promiseFactory, resolve, reject });
            this.processQueue();
        });
    }
    
    async processQueue() {
        if (this.running >= this.maxConcurrent || this.queue.length === 0) {
            return;
        }
        
        this.running++;
        const { promiseFactory, resolve, reject } = this.queue.shift();
        
        try {
            const result = await promiseFactory();
            resolve(result);
        } catch (error) {
            reject(error);
        } finally {
            this.running--;
            
            // Add delay between operations
            setTimeout(() => {
                this.processQueue();
            }, this.delayBetween);
        }
    }
}

function demonstrateRateLimiter() {
    console.log('\n🚦 Custom Rate Limiter:');
    
    const rateLimiter = new RateLimiter(2, 200); // Max 2 concurrent, 200ms delay
    
    // Create multiple operations
    const operations = Array.from({ length: 8 }, (_, i) => {
        return () => {
            console.log(`🚀 Starting operation ${i + 1}`);
            return delay(Math.random() * 1000 + 500, `Operation ${i + 1} completed`);
        };
    });
    
    // Execute all operations through rate limiter
    const promises = operations.map(op => 
        rateLimiter.execute(op).then(result => {
            console.log('✅', result);
            return result;
        })
    );
    
    Promise.all(promises)
        .then(results => {
            console.log('🏁 All rate-limited operations completed');
        });
}

setTimeout(demonstrateRateLimiter, 7000);

/**
 * CUSTOM PROMISE: CACHE WITH EXPIRATION
 * 
 * Caches promise results with automatic expiration.
 */

class PromiseCache {
    constructor(defaultTTL = 60000) { // 1 minute default
        this.cache = new Map();
        this.defaultTTL = defaultTTL;
    }
    
    async get(key, promiseFactory, ttl = this.defaultTTL) {
        const cached = this.cache.get(key);
        
        // Check if cached and not expired
        if (cached && Date.now() < cached.expiresAt) {
            console.log(`💾 Cache hit for key: ${key}`);
            return cached.value;
        }
        
        console.log(`🔄 Cache miss for key: ${key}, fetching...`);
        
        try {
            const value = await promiseFactory();
            
            // Cache the result
            this.cache.set(key, {
                value,
                expiresAt: Date.now() + ttl
            });
            
            return value;
        } catch (error) {
            // Don't cache errors
            throw error;
        }
    }
    
    clear() {
        this.cache.clear();
    }
    
    delete(key) {
        return this.cache.delete(key);
    }
}

function demonstratePromiseCache() {
    console.log('\n💾 Custom Promise Cache:');
    
    const cache = new PromiseCache(2000); // 2 second TTL
    
    // Simulate expensive operation
    function expensiveOperation(id) {
        return new Promise((resolve) => {
            console.log(`💰 Expensive operation for ID: ${id}`);
            setTimeout(() => {
                resolve(`Data for ${id} - ${Date.now()}`);
            }, 1000);
        });
    }
    
    // First call - cache miss
    cache.get('user:123', () => expensiveOperation('user:123'))
        .then(result => console.log('✅ First call:', result));
    
    // Second call (immediate) - cache hit
    setTimeout(() => {
        cache.get('user:123', () => expensiveOperation('user:123'))
            .then(result => console.log('✅ Second call (cached):', result));
    }, 100);
    
    // Third call (after expiration) - cache miss
    setTimeout(() => {
        cache.get('user:123', () => expensiveOperation('user:123'))
            .then(result => console.log('✅ Third call (expired):', result));
    }, 3000);
}

setTimeout(demonstratePromiseCache, 10000);
```#
## Promise Chaining and Composition

```javascript
/**
 * PROMISE CHAINING AND COMPOSITION
 * 
 * Learn how to chain promises effectively and compose complex async workflows.
 */

console.log('\n=== Promise Chaining and Composition ===');

/**
 * PROMISE CHAINING: SEQUENTIAL OPERATIONS
 * 
 * Promise chaining allows you to perform sequential async operations
 * in a clean, readable way.
 */

function demonstratePromiseChaining() {
    console.log('\n🔗 Promise Chaining:');
    
    // Simulate API calls
    function fetchUser(userId) {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`📡 Fetched user ${userId}`);
                resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });
            }, 500);
        });
    }
    
    function fetchUserPosts(user) {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`📡 Fetched posts for ${user.name}`);
                const posts = [
                    { id: 1, title: 'First Post', content: 'Hello World!' },
                    { id: 2, title: 'Second Post', content: 'Learning Promises!' }
                ];
                resolve({ ...user, posts });
            }, 700);
        });
    }
    
    function fetchPostComments(userWithPosts) {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`📡 Fetched comments for ${userWithPosts.posts.length} posts`);
                const postsWithComments = userWithPosts.posts.map(post => ({
                    ...post,
                    comments: [
                        { id: 1, text: 'Great post!', author: 'Alice' },
                        { id: 2, text: 'Thanks for sharing!', author: 'Bob' }
                    ]
                }));
                resolve({ ...userWithPosts, posts: postsWithComments });
            }, 400);
        });
    }
    
    // Chain the operations
    console.log('Starting promise chain...');
    
    fetchUser(123)
        .then(user => {
            console.log('✅ Step 1 complete:', user.name);
            return fetchUserPosts(user);
        })
        .then(userWithPosts => {
            console.log('✅ Step 2 complete:', `${userWithPosts.posts.length} posts`);
            return fetchPostComments(userWithPosts);
        })
        .then(fullUserData => {
            console.log('✅ Step 3 complete: Full user data loaded');
            console.log('🎉 Final result:', {
                user: fullUserData.name,
                postsCount: fullUserData.posts.length,
                totalComments: fullUserData.posts.reduce((sum, post) => sum + post.comments.length, 0)
            });
        })
        .catch(error => {
            console.error('❌ Chain failed:', error.message);
        });
}

demonstratePromiseChaining();

/**
 * PROMISE COMPOSITION: PARALLEL OPERATIONS
 * 
 * Use Promise.all(), Promise.allSettled(), Promise.race() for parallel operations.
 */

function demonstratePromiseComposition() {
    console.log('\n🎼 Promise Composition:');
    
    // Helper functions for different operations
    function fetchWeather(city) {
        return new Promise((resolve, reject) => {
            const delay = Math.random() * 1500 + 500;
            setTimeout(() => {
                if (Math.random() > 0.1) { // 90% success rate
                    resolve({
                        city,
                        temperature: Math.round(Math.random() * 30 + 10),
                        condition: ['Sunny', 'Cloudy', 'Rainy'][Math.floor(Math.random() * 3)]
                    });
                } else {
                    reject(new Error(`Weather service unavailable for ${city}`));
                }
            }, delay);
        });
    }
    
    function fetchNews(category) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve({
                    category,
                    articles: [
                        { title: `${category} News 1`, summary: 'Important update...' },
                        { title: `${category} News 2`, summary: 'Breaking news...' }
                    ]
                });
            }, Math.random() * 1000 + 300);
        });
    }
    
    function fetchStockPrice(symbol) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (Math.random() > 0.2) { // 80% success rate
                    resolve({
                        symbol,
                        price: (Math.random() * 1000 + 100).toFixed(2),
                        change: (Math.random() * 20 - 10).toFixed(2)
                    });
                } else {
                    reject(new Error(`Stock data unavailable for ${symbol}`));
                }
            }, Math.random() * 2000 + 200);
        });
    }
    
    // 1. Promise.all() - All must succeed
    console.log('\n1. Promise.all() - All or nothing:');
    
    const weatherPromises = [
        fetchWeather('New York'),
        fetchWeather('London'),
        fetchWeather('Tokyo')
    ];
    
    Promise.all(weatherPromises)
        .then(results => {
            console.log('✅ All weather data received:');
            results.forEach(weather => {
                console.log(`   ${weather.city}: ${weather.temperature}°C, ${weather.condition}`);
            });
        })
        .catch(error => {
            console.log('❌ Weather fetch failed:', error.message);
        });
    
    // 2. Promise.allSettled() - Get all results regardless of success/failure
    setTimeout(() => {
        console.log('\n2. Promise.allSettled() - All results:');
        
        const mixedPromises = [
            fetchNews('Technology'),
            fetchStockPrice('AAPL'),
            fetchStockPrice('INVALID'), // This might fail
            fetchNews('Sports')
        ];
        
        Promise.allSettled(mixedPromises)
            .then(results => {
                console.log('📊 All operations completed:');
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        console.log(`   ✅ Operation ${index + 1}: Success`);
                    } else {
                        console.log(`   ❌ Operation ${index + 1}: ${result.reason.message}`);
                    }
                });
            });
    }, 2000);
    
    // 3. Promise.race() - First to complete wins
    setTimeout(() => {
        console.log('\n3. Promise.race() - First to finish:');
        
        const racePromises = [
            fetchWeather('Paris'),
            fetchWeather('Berlin'),
            fetchWeather('Madrid')
        ];
        
        Promise.race(racePromises)
            .then(result => {
                console.log('🏆 First weather result:', `${result.city}: ${result.temperature}°C`);
            })
            .catch(error => {
                console.log('❌ First result was an error:', error.message);
            });
    }, 4000);
    
    // 4. Promise.any() - First successful result (ES2021)
    setTimeout(() => {
        console.log('\n4. Promise.any() - First success:');
        
        const anyPromises = [
            fetchStockPrice('FAIL1'), // Might fail
            fetchStockPrice('FAIL2'), // Might fail
            fetchStockPrice('AAPL'),  // More likely to succeed
            fetchStockPrice('GOOGL')  // More likely to succeed
        ];
        
        Promise.any(anyPromises)
            .then(result => {
                console.log('🎯 First successful stock:', `${result.symbol}: $${result.price}`);
            })
            .catch(error => {
                console.log('❌ All stock fetches failed:', error.message);
            });
    }, 6000);
}

setTimeout(demonstratePromiseComposition, 3000);

/**
 * ADVANCED PROMISE PATTERNS
 * 
 * Complex patterns for real-world scenarios.
 */

function demonstrateAdvancedPatterns() {
    console.log('\n🎯 Advanced Promise Patterns:');
    
    // Pattern 1: Promise Pipeline
    console.log('\n1. Promise Pipeline Pattern:');
    
    const pipeline = [
        (data) => Promise.resolve(data.toUpperCase()),
        (data) => new Promise(resolve => setTimeout(() => resolve(data + '!'), 200)),
        (data) => Promise.resolve(`Processed: ${data}`),
        (data) => new Promise(resolve => setTimeout(() => resolve(data.split('').reverse().join('')), 100))
    ];
    
    function runPipeline(initialValue, steps) {
        return steps.reduce((promise, step) => {
            return promise.then(step);
        }, Promise.resolve(initialValue));
    }
    
    runPipeline('hello world', pipeline)
        .then(result => console.log('🔄 Pipeline result:', result));
    
    // Pattern 2: Conditional Promise Chain
    setTimeout(() => {
        console.log('\n2. Conditional Promise Chain:');
        
        function processUser(userId, options = {}) {
            return fetchUser(userId)
                .then(user => {
                    // Conditional step 1
                    if (options.includePosts) {
                        return fetchUserPosts(user);
                    }
                    return user;
                })
                .then(userData => {
                    // Conditional step 2
                    if (options.includeComments && userData.posts) {
                        return fetchPostComments(userData);
                    }
                    return userData;
                })
                .then(finalData => {
                    console.log('🔀 Conditional processing complete:', {
                        name: finalData.name,
                        hasPosts: !!finalData.posts,
                        hasComments: finalData.posts && finalData.posts[0] && !!finalData.posts[0].comments
                    });
                    return finalData;
                });
        }
        
        // Test different configurations
        processUser(456, { includePosts: true, includeComments: true });
        processUser(789, { includePosts: false });
    }, 1000);
    
    // Pattern 3: Promise Memoization
    setTimeout(() => {
        console.log('\n3. Promise Memoization:');
        
        const memoizedFetch = (() => {
            const cache = new Map();
            
            return function(url) {
                if (cache.has(url)) {
                    console.log(`💾 Returning cached promise for: ${url}`);
                    return cache.get(url);
                }
                
                console.log(`🌐 Creating new promise for: ${url}`);
                const promise = new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(`Data from ${url}`);
                    }, 1000);
                });
                
                cache.set(url, promise);
                return promise;
            };
        })();
        
        // Multiple calls to same URL return same promise
        const url = '/api/users';
        memoizedFetch(url).then(result => console.log('✅ First call:', result));
        memoizedFetch(url).then(result => console.log('✅ Second call (cached):', result));
        memoizedFetch(url).then(result => console.log('✅ Third call (cached):', result));
    }, 2000);
}

setTimeout(demonstrateAdvancedPatterns, 8000);

// Helper functions for demonstrations
function fetchUser(userId) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });
        }, 300);
    });
}

function fetchUserPosts(user) {
    return new Promise((resolve) => {
        setTimeout(() => {
            const posts = [
                { id: 1, title: 'First Post', content: 'Hello World!' },
                { id: 2, title: 'Second Post', content: 'Learning Promises!' }
            ];
            resolve({ ...user, posts });
        }, 400);
    });
}

function fetchPostComments(userWithPosts) {
    return new Promise((resolve) => {
        setTimeout(() => {
            const postsWithComments = userWithPosts.posts.map(post => ({
                ...post,
                comments: [
                    { id: 1, text: 'Great post!', author: 'Alice' },
                    { id: 2, text: 'Thanks for sharing!', author: 'Bob' }
                ]
            }));
            resolve({ ...userWithPosts, posts: postsWithComments });
        }, 300);
    });
}

console.log('\n💡 Promise Key Benefits:');
console.log('✅ Cleaner syntax than callbacks');
console.log('✅ Better error handling with .catch()');
console.log('✅ Chainable for sequential operations');
console.log('✅ Composable for parallel operations');
console.log('✅ Immutable - can\'t change state once settled');
console.log('🚀 Foundation for async/await syntax!');
```

---

## 🎯 Async/Await: The Modern Syntax

Async/await is syntactic sugar built on top of Promises, making asynchronous code look and behave more like synchronous code.

### Understanding Async/Await

```javascript
/**
 * ASYNC/AWAIT: MODERN ASYNCHRONOUS SYNTAX
 * 
 * Async/await makes asynchronous code look synchronous, improving
 * readability and making error handling more intuitive.
 */

console.log('=== Async/Await Deep Dive ===');

/**
 * BASIC ASYNC/AWAIT SYNTAX
 * 
 * The 'async' keyword makes a function return a Promise.
 * The 'await' keyword pauses execution until the Promise resolves.
 */

async function demonstrateBasicAsyncAwait() {
    console.log('\n🎯 Basic Async/Await:');
    
    // Simple async function
    async function greetAsync(name) {
        // This function automatically returns a Promise
        return `Hello, ${name}!`;
    }
    
    // Using await to get the result
    try {
        console.log('1. Calling async function...');
        const greeting = await greetAsync('Alice');
        console.log('✅ Result:', greeting);
    } catch (error) {
        console.log('❌ Error:', error.message);
    }
    
    // Async function with actual asynchronous operation
    async function fetchDataAsync(id) {
        console.log(`🔄 Fetching data for ID: ${id}`);
        
        // Simulate API call with Promise
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Simulate random success/failure
        if (Math.random() > 0.3) {
            return { id, data: `Data for ${id}`, timestamp: new Date() };
        } else {
            throw new Error(`Failed to fetch data for ${id}`);
        }
    }
    
    // Using the async function
    try {
        console.log('\n2. Fetching data asynchronously...');
        const data = await fetchDataAsync(123);
        console.log('✅ Data received:', data);
    } catch (error) {
        console.log('❌ Fetch failed:', error.message);
    }
}

// Call the demo function
demonstrateBasicAsyncAwait();

/**
 * CONVERTING PROMISES TO ASYNC/AWAIT
 * 
 * Let's see how Promise chains convert to async/await syntax.
 */

function demonstratePromiseToAsyncConversion() {
    console.log('\n🔄 Promise vs Async/Await Comparison:');
    
    // Helper functions that return Promises
    function fetchUser(userId) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (userId > 0) {
                    resolve({ id: userId, name: `User ${userId}` });
                } else {
                    reject(new Error('Invalid user ID'));
                }
            }, 500);
        });
    }
    
    function fetchUserProfile(user) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve({
                    ...user,
                    profile: {
                        bio: `Bio for ${user.name}`,
                        joinDate: '2023-01-01',
                        posts: Math.floor(Math.random() * 100)
                    }
                });
            }, 700);
        });
    }
    
    function fetchUserSettings(userWithProfile) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve({
                    ...userWithProfile,
                    settings: {
                        theme: 'dark',
                        notifications: true,
                        privacy: 'public'
                    }
                });
            }, 300);
        });
    }
    
    // Promise chain approach
    function loadUserDataWithPromises(userId) {
        console.log('📦 Loading with Promises...');
        
        return fetchUser(userId)
            .then(user => {
                console.log('✅ User fetched:', user.name);
                return fetchUserProfile(user);
            })
            .then(userWithProfile => {
                console.log('✅ Profile fetched:', userWithProfile.profile.bio);
                return fetchUserSettings(userWithProfile);
            })
            .then(fullUserData => {
                console.log('✅ Settings fetched:', fullUserData.settings.theme);
                return fullUserData;
            })
            .catch(error => {
                console.log('❌ Promise chain error:', error.message);
                throw error;
            });
    }
    
    // Async/await approach
    async function loadUserDataWithAsync(userId) {
        console.log('🎯 Loading with Async/Await...');
        
        try {
            const user = await fetchUser(userId);
            console.log('✅ User fetched:', user.name);
            
            const userWithProfile = await fetchUserProfile(user);
            console.log('✅ Profile fetched:', userWithProfile.profile.bio);
            
            const fullUserData = await fetchUserSettings(userWithProfile);
            console.log('✅ Settings fetched:', fullUserData.settings.theme);
            
            return fullUserData;
        } catch (error) {
            console.log('❌ Async/await error:', error.message);
            throw error;
        }
    }
    
    // Test both approaches
    setTimeout(async () => {
        console.log('\n1. Promise Chain Approach:');
        try {
            const result1 = await loadUserDataWithPromises(456);
            console.log('🎉 Promise result:', result1.name);
        } catch (error) {
            console.log('💥 Promise approach failed');
        }
        
        setTimeout(async () => {
            console.log('\n2. Async/Await Approach:');
            try {
                const result2 = await loadUserDataWithAsync(789);
                console.log('🎉 Async/await result:', result2.name);
            } catch (error) {
                console.log('💥 Async/await approach failed');
            }
        }, 2000);
    }, 2000);
}

setTimeout(demonstratePromiseToAsyncConversion, 3000);

/**
 * ERROR HANDLING WITH ASYNC/AWAIT
 * 
 * Error handling is more intuitive with try/catch blocks.
 */

async function demonstrateAsyncErrorHandling() {
    console.log('\n🛡️ Async/Await Error Handling:');
    
    // Function that might fail
    async function riskyOperation(shouldFail = false) {
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (shouldFail) {
            throw new Error('Operation failed as requested');
        }
        
        return 'Operation succeeded!';
    }
    
    // Basic try/catch
    console.log('1. Basic Try/Catch:');
    try {
        const result = await riskyOperation(false);
        console.log('✅ Success:', result);
    } catch (error) {
        console.log('❌ Caught error:', error.message);
    }
    
    // Handling multiple operations
    console.log('\n2. Multiple Operations:');
    try {
        const result1 = await riskyOperation(false);
        console.log('✅ First operation:', result1);
        
        const result2 = await riskyOperation(true); // This will fail
        console.log('✅ Second operation:', result2);
        
        const result3 = await riskyOperation(false);
        console.log('✅ Third operation:', result3); // Won't execute
    } catch (error) {
        console.log('❌ One of the operations failed:', error.message);
    }
    
    // Handling errors individually
    console.log('\n3. Individual Error Handling:');
    
    async function handleIndividually() {
        let results = [];
        
        // Handle each operation separately
        try {
            const result1 = await riskyOperation(false);
            results.push({ success: true, data: result1 });
        } catch (error) {
            results.push({ success: false, error: error.message });
        }
        
        try {
            const result2 = await riskyOperation(true);
            results.push({ success: true, data: result2 });
        } catch (error) {
            results.push({ success: false, error: error.message });
        }
        
        try {
            const result3 = await riskyOperation(false);
            results.push({ success: true, data: result3 });
        } catch (error) {
            results.push({ success: false, error: error.message });
        }
        
        return results;
    }
    
    const individualResults = await handleIndividually();
    console.log('📊 Individual results:', individualResults);
}

setTimeout(demonstrateAsyncErrorHandling, 8000);

/**
 * PARALLEL EXECUTION WITH ASYNC/AWAIT
 * 
 * How to run multiple async operations in parallel using async/await.
 */

async function demonstrateParallelExecution() {
    console.log('\n⚡ Parallel Execution with Async/Await:');
    
    // Simulate different async operations
    async function operation1() {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return 'Operation 1 completed';
    }
    
    async function operation2() {
        await new Promise(resolve => setTimeout(resolve, 1500));
        return 'Operation 2 completed';
    }
    
    async function operation3() {
        await new Promise(resolve => setTimeout(resolve, 800));
        return 'Operation 3 completed';
    }
    
    // ❌ Sequential execution (slow)
    console.log('1. Sequential Execution (slow):');
    const sequentialStart = Date.now();
    
    const seq1 = await operation1();
    const seq2 = await operation2();
    const seq3 = await operation3();
    
    const sequentialTime = Date.now() - sequentialStart;
    console.log('📊 Sequential results:', [seq1, seq2, seq3]);
    console.log(`⏱️ Sequential time: ${sequentialTime}ms`);
    
    // ✅ Parallel execution (fast)
    console.log('\n2. Parallel Execution (fast):');
    const parallelStart = Date.now();
    
    // Start all operations simultaneously
    const promise1 = operation1();
    const promise2 = operation2();
    const promise3 = operation3();
    
    // Wait for all to complete
    const [par1, par2, par3] = await Promise.all([promise1, promise2, promise3]);
    
    const parallelTime = Date.now() - parallelStart;
    console.log('📊 Parallel results:', [par1, par2, par3]);
    console.log(`⏱️ Parallel time: ${parallelTime}ms`);
    console.log(`🚀 Speed improvement: ${((sequentialTime - parallelTime) / sequentialTime * 100).toFixed(1)}%`);
    
    // Alternative parallel syntax
    console.log('\n3. Alternative Parallel Syntax:');
    const altStart = Date.now();
    
    const results = await Promise.all([
        operation1(),
        operation2(),
        operation3()
    ]);
    
    const altTime = Date.now() - altStart;
    console.log('📊 Alternative results:', results);
    console.log(`⏱️ Alternative time: ${altTime}ms`);
}

setTimeout(demonstrateParallelExecution, 12000);
```###
 Advanced Async/Await Patterns

```javascript
/**
 * ADVANCED ASYNC/AWAIT PATTERNS
 * 
 * Sophisticated patterns for complex real-world scenarios.
 */

console.log('\n=== Advanced Async/Await Patterns ===');

/**
 * ASYNC ITERATION AND LOOPS
 * 
 * How to handle async operations in loops properly.
 */

async function demonstrateAsyncLoops() {
    console.log('\n🔄 Async Loops and Iteration:');
    
    // Sample data
    const userIds = [1, 2, 3, 4, 5];
    
    async function fetchUserData(id) {
        const delay = Math.random() * 1000 + 500;
        await new Promise(resolve => setTimeout(resolve, delay));
        return { id, name: `User ${id}`, fetchTime: delay.toFixed(0) + 'ms' };
    }
    
    // ❌ Wrong way - forEach with async (doesn't wait)
    console.log('1. ❌ Wrong: forEach with async');
    console.log('Starting forEach...');
    userIds.forEach(async (id) => {
        const user = await fetchUserData(id);
        console.log(`   forEach result: ${user.name} (${user.fetchTime})`);
    });
    console.log('forEach "completed" immediately (but operations still running)');
    
    // ✅ Sequential processing with for...of
    setTimeout(async () => {
        console.log('\n2. ✅ Sequential: for...of loop');
        const sequentialStart = Date.now();
        
        for (const id of userIds) {
            const user = await fetchUserData(id);
            console.log(`   Sequential: ${user.name} (${user.fetchTime})`);
        }
        
        const sequentialTime = Date.now() - sequentialStart;
        console.log(`   Sequential total time: ${sequentialTime}ms`);
    }, 2000);
    
    // ✅ Parallel processing with Promise.all
    setTimeout(async () => {
        console.log('\n3. ✅ Parallel: Promise.all with map');
        const parallelStart = Date.now();
        
        const users = await Promise.all(
            userIds.map(id => fetchUserData(id))
        );
        
        users.forEach(user => {
            console.log(`   Parallel: ${user.name} (${user.fetchTime})`);
        });
        
        const parallelTime = Date.now() - parallelStart;
        console.log(`   Parallel total time: ${parallelTime}ms`);
    }, 4000);
    
    // ✅ Controlled concurrency
    setTimeout(async () => {
        console.log('\n4. ✅ Controlled Concurrency (2 at a time):');
        
        async function processInBatches(items, batchSize, processor) {
            const results = [];
            
            for (let i = 0; i < items.length; i += batchSize) {
                const batch = items.slice(i, i + batchSize);
                console.log(`   Processing batch: ${batch.join(', ')}`);
                
                const batchResults = await Promise.all(
                    batch.map(processor)
                );
                
                results.push(...batchResults);
            }
            
            return results;
        }
        
        const batchStart = Date.now();
        const batchUsers = await processInBatches(userIds, 2, fetchUserData);
        const batchTime = Date.now() - batchStart;
        
        batchUsers.forEach(user => {
            console.log(`   Batch result: ${user.name} (${user.fetchTime})`);
        });
        console.log(`   Batch total time: ${batchTime}ms`);
    }, 6000);
}

demonstrateAsyncLoops();

/**
 * ASYNC GENERATORS AND FOR-AWAIT-OF
 * 
 * Advanced iteration patterns with async generators.
 */

async function demonstrateAsyncGenerators() {
    console.log('\n🔄 Async Generators:');
    
    // Async generator function
    async function* fetchUsersGenerator(userIds) {
        console.log('🚀 Starting async generator...');
        
        for (const id of userIds) {
            console.log(`   Fetching user ${id}...`);
            
            // Simulate API call
            await new Promise(resolve => setTimeout(resolve, 500));
            
            yield {
                id,
                name: `User ${id}`,
                email: `user${id}@example.com`,
                timestamp: new Date().toISOString()
            };
        }
        
        console.log('✅ Generator completed');
    }
    
    // Using for-await-of to consume async generator
    console.log('1. Consuming with for-await-of:');
    
    const userIds = [10, 11, 12];
    const userGenerator = fetchUsersGenerator(userIds);
    
    for await (const user of userGenerator) {
        console.log(`   📦 Received: ${user.name} at ${user.timestamp.split('T')[1].split('.')[0]}`);
    }
    
    // Manual iteration with async generator
    setTimeout(async () => {
        console.log('\n2. Manual iteration:');
        
        const manualGenerator = fetchUsersGenerator([20, 21]);
        
        let result = await manualGenerator.next();
        while (!result.done) {
            console.log(`   🔧 Manual: ${result.value.name}`);
            result = await manualGenerator.next();
        }
    }, 3000);
    
    // Async generator with error handling
    setTimeout(async () => {
        console.log('\n3. Error handling in async generators:');
        
        async function* errorProneGenerator() {
            yield 'First value';
            yield 'Second value';
            
            if (Math.random() > 0.5) {
                throw new Error('Random generator error');
            }
            
            yield 'Third value';
        }
        
        try {
            for await (const value of errorProneGenerator()) {
                console.log(`   ✅ Generated: ${value}`);
            }
        } catch (error) {
            console.log(`   ❌ Generator error: ${error.message}`);
        }
    }, 6000);
}

setTimeout(demonstrateAsyncGenerators, 8000);

/**
 * ASYNC FUNCTION COMPOSITION
 * 
 * Composing async functions for complex workflows.
 */

async function demonstrateAsyncComposition() {
    console.log('\n🎼 Async Function Composition:');
    
    // Base async operations
    async function validateInput(data) {
        await new Promise(resolve => setTimeout(resolve, 100));
        
        if (!data || typeof data !== 'string') {
            throw new Error('Invalid input: must be a non-empty string');
        }
        
        return data.trim();
    }
    
    async function processData(data) {
        await new Promise(resolve => setTimeout(resolve, 200));
        
        return {
            original: data,
            processed: data.toUpperCase(),
            length: data.length,
            words: data.split(' ').length
        };
    }
    
    async function saveData(processedData) {
        await new Promise(resolve => setTimeout(resolve, 300));
        
        const saved = {
            ...processedData,
            id: Math.random().toString(36).substr(2, 9),
            savedAt: new Date().toISOString()
        };
        
        return saved;
    }
    
    async function notifyCompletion(savedData) {
        await new Promise(resolve => setTimeout(resolve, 100));
        
        return {
            ...savedData,
            notificationSent: true,
            notifiedAt: new Date().toISOString()
        };
    }
    
    // Composition pattern 1: Simple pipeline
    console.log('1. Simple Pipeline:');
    
    async function simplePipeline(input) {
        try {
            const validated = await validateInput(input);
            const processed = await processData(validated);
            const saved = await saveData(processed);
            const notified = await notifyCompletion(saved);
            
            return notified;
        } catch (error) {
            console.log(`❌ Pipeline error: ${error.message}`);
            throw error;
        }
    }
    
    try {
        const result1 = await simplePipeline('hello world');
        console.log('✅ Pipeline result:', {
            id: result1.id,
            processed: result1.processed,
            notified: result1.notificationSent
        });
    } catch (error) {
        console.log('💥 Pipeline failed');
    }
    
    // Composition pattern 2: Functional composition
    console.log('\n2. Functional Composition:');
    
    function composeAsync(...functions) {
        return async function(input) {
            let result = input;
            
            for (const fn of functions) {
                result = await fn(result);
            }
            
            return result;
        };
    }
    
    const functionalPipeline = composeAsync(
        validateInput,
        processData,
        saveData,
        notifyCompletion
    );
    
    try {
        const result2 = await functionalPipeline('functional composition');
        console.log('✅ Functional result:', {
            id: result2.id,
            processed: result2.processed,
            words: result2.words
        });
    } catch (error) {
        console.log('💥 Functional pipeline failed');
    }
    
    // Composition pattern 3: Parallel with dependencies
    console.log('\n3. Parallel with Dependencies:');
    
    async function parallelWithDependencies(input) {
        try {
            // Step 1: Validation (required first)
            const validated = await validateInput(input);
            
            // Step 2: Parallel processing (both depend on validation)
            const [processed, metadata] = await Promise.all([
                processData(validated),
                (async () => {
                    await new Promise(resolve => setTimeout(resolve, 150));
                    return {
                        inputLength: validated.length,
                        timestamp: Date.now(),
                        source: 'parallel-demo'
                    };
                })()
            ]);
            
            // Step 3: Combine results and save
            const combined = { ...processed, metadata };
            const saved = await saveData(combined);
            
            // Step 4: Final notification
            const notified = await notifyCompletion(saved);
            
            return notified;
        } catch (error) {
            console.log(`❌ Parallel pipeline error: ${error.message}`);
            throw error;
        }
    }
    
    try {
        const result3 = await parallelWithDependencies('parallel processing');
        console.log('✅ Parallel result:', {
            id: result3.id,
            source: result3.metadata.source,
            inputLength: result3.metadata.inputLength
        });
    } catch (error) {
        console.log('💥 Parallel pipeline failed');
    }
}

setTimeout(demonstrateAsyncComposition, 15000);

/**
 * ASYNC RESOURCE MANAGEMENT
 * 
 * Patterns for managing resources in async operations.
 */

async function demonstrateAsyncResourceManagement() {
    console.log('\n🔧 Async Resource Management:');
    
    // Resource management with try/finally
    console.log('1. Resource Management with try/finally:');
    
    class DatabaseConnection {
        constructor(name) {
            this.name = name;
            this.isConnected = false;
        }
        
        async connect() {
            console.log(`   🔌 Connecting to ${this.name}...`);
            await new Promise(resolve => setTimeout(resolve, 200));
            this.isConnected = true;
            console.log(`   ✅ Connected to ${this.name}`);
        }
        
        async query(sql) {
            if (!this.isConnected) {
                throw new Error('Database not connected');
            }
            
            console.log(`   🔍 Executing query: ${sql}`);
            await new Promise(resolve => setTimeout(resolve, 300));
            return { rows: [{ id: 1, name: 'Sample Data' }] };
        }
        
        async disconnect() {
            if (this.isConnected) {
                console.log(`   🔌 Disconnecting from ${this.name}...`);
                await new Promise(resolve => setTimeout(resolve, 100));
                this.isConnected = false;
                console.log(`   ✅ Disconnected from ${this.name}`);
            }
        }
    }
    
    async function performDatabaseOperation() {
        const db = new DatabaseConnection('UserDB');
        
        try {
            await db.connect();
            const result = await db.query('SELECT * FROM users');
            console.log('   📊 Query result:', result.rows.length, 'rows');
            return result;
        } catch (error) {
            console.log(`   ❌ Database operation failed: ${error.message}`);
            throw error;
        } finally {
            // Always cleanup, even if error occurred
            await db.disconnect();
        }
    }
    
    try {
        await performDatabaseOperation();
    } catch (error) {
        console.log('💥 Operation failed but resources cleaned up');
    }
    
    // Resource pooling pattern
    setTimeout(async () => {
        console.log('\n2. Resource Pooling Pattern:');
        
        class ResourcePool {
            constructor(createResource, maxSize = 3) {
                this.createResource = createResource;
                this.maxSize = maxSize;
                this.available = [];
                this.inUse = new Set();
                this.waiting = [];
            }
            
            async acquire() {
                return new Promise(async (resolve) => {
                    // If resource available, use it
                    if (this.available.length > 0) {
                        const resource = this.available.pop();
                        this.inUse.add(resource);
                        console.log(`   📦 Acquired existing resource (${this.inUse.size} in use)`);
                        resolve(resource);
                        return;
                    }
                    
                    // If can create new resource, create it
                    if (this.inUse.size < this.maxSize) {
                        const resource = await this.createResource();
                        this.inUse.add(resource);
                        console.log(`   🆕 Created new resource (${this.inUse.size} in use)`);
                        resolve(resource);
                        return;
                    }
                    
                    // Otherwise, wait for resource to become available
                    console.log(`   ⏳ Waiting for resource (pool full: ${this.inUse.size}/${this.maxSize})`);
                    this.waiting.push(resolve);
                });
            }
            
            release(resource) {
                if (this.inUse.has(resource)) {
                    this.inUse.delete(resource);
                    
                    // If someone is waiting, give them the resource
                    if (this.waiting.length > 0) {
                        const resolve = this.waiting.shift();
                        this.inUse.add(resource);
                        console.log(`   🔄 Resource passed to waiting request (${this.inUse.size} in use)`);
                        resolve(resource);
                    } else {
                        // Return to available pool
                        this.available.push(resource);
                        console.log(`   📤 Resource returned to pool (${this.available.length} available)`);
                    }
                }
            }
        }
        
        // Create connection pool
        const connectionPool = new ResourcePool(
            async () => {
                const conn = new DatabaseConnection(`DB-${Date.now()}`);
                await conn.connect();
                return conn;
            },
            2 // Max 2 connections
        );
        
        // Simulate multiple concurrent operations
        async function useDatabase(operationId) {
            const connection = await connectionPool.acquire();
            
            try {
                await connection.query(`SELECT * FROM table_${operationId}`);
                console.log(`   ✅ Operation ${operationId} completed`);
            } finally {
                connectionPool.release(connection);
            }
        }
        
        // Start multiple operations concurrently
        const operations = [1, 2, 3, 4, 5].map(id => useDatabase(id));
        await Promise.all(operations);
        
        console.log('   🏁 All pooled operations completed');
    }, 2000);
}

setTimeout(demonstrateAsyncResourceManagement, 20000);

console.log('\n💡 Async/Await Key Benefits:');
console.log('✅ Synchronous-looking asynchronous code');
console.log('✅ Better error handling with try/catch');
console.log('✅ No callback hell or complex Promise chains');
console.log('✅ Easier debugging and stack traces');
console.log('✅ More intuitive control flow');
console.log('⚠️ Remember: async functions always return Promises');
console.log('⚠️ Use Promise.all() for parallel execution');
```

---

## 🌐 AJAX and the Fetch API

AJAX (Asynchronous JavaScript and XML) allows web pages to update content dynamically without reloading. The modern Fetch API provides a powerful, flexible way to make HTTP requests.

### Understanding AJAX and HTTP Requests

```javascript
/**
 * AJAX AND FETCH API: MODERN HTTP REQUESTS
 * 
 * Learn how to make HTTP requests, handle responses, and work with APIs
 * using the modern Fetch API and async/await.
 */

console.log('=== AJAX and Fetch API Deep Dive ===');

/**
 * FETCH API BASICS
 * 
 * The Fetch API provides a modern interface for making HTTP requests.
 */

async function demonstrateFetchBasics() {
    console.log('\n🌐 Fetch API Basics:');
    
    // Basic GET request
    console.log('1. Basic GET Request:');
    
    try {
        // Using a public API for demonstration
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        
        console.log('📡 Response received:');
        console.log('   Status:', response.status);
        console.log('   Status Text:', response.statusText);
        console.log('   OK:', response.ok);
        console.log('   Headers Content-Type:', response.headers.get('content-type'));
        
        // Parse JSON response
        const data = await response.json();
        console.log('✅ Data:', {
            id: data.id,
            title: data.title.substring(0, 30) + '...',
            userId: data.userId
        });
        
    } catch (error) {
        console.log('❌ Fetch error:', error.message);
    }
    
    // Handling different response types
    setTimeout(async () => {
        console.log('\n2. Different Response Types:');
        
        try {
            // JSON response
            const jsonResponse = await fetch('https://jsonplaceholder.typicode.com/users/1');
            const jsonData = await jsonResponse.json();
            console.log('📄 JSON data:', { name: jsonData.name, email: jsonData.email });
            
            // Text response
            const textResponse = await fetch('https://httpbin.org/uuid');
            const textData = await textResponse.text();
            console.log('📝 Text data:', textData.substring(0, 50));
            
        } catch (error) {
            console.log('❌ Response parsing error:', error.message);
        }
    }, 2000);
    
    // Error handling and status codes
    setTimeout(async () => {
        console.log('\n3. Error Handling and Status Codes:');
        
        async function fetchWithErrorHandling(url) {
            try {
                const response = await fetch(url);
                
                // Check if request was successful
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return { success: true, data };
                
            } catch (error) {
                console.log(`❌ Request failed: ${error.message}`);
                return { success: false, error: error.message };
            }
        }
        
        // Test with valid URL
        const validResult = await fetchWithErrorHandling('https://jsonplaceholder.typicode.com/posts/1');
        if (validResult.success) {
            console.log('✅ Valid request:', validResult.data.title.substring(0, 30));
        }
        
        // Test with invalid URL (404)
        const invalidResult = await fetchWithErrorHandling('https://jsonplaceholder.typicode.com/posts/999999');
        if (!invalidResult.success) {
            console.log('❌ Invalid request handled gracefully');
        }
    }, 4000);
}

demonstrateFetchBasics();

/**
 * ADVANCED FETCH CONFIGURATIONS
 * 
 * Explore advanced fetch options including headers, methods, and request configuration.
 */

async function demonstrateAdvancedFetch() {
    console.log('\n🔧 Advanced Fetch Configurations:');
    
    // POST request with JSON data
    console.log('1. POST Request with JSON:');
    
    try {
        const postData = {
            title: 'My New Post',
            body: 'This is the content of my new post.',
            userId: 1
        };
        
        const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer fake-token-for-demo'
            },
            body: JSON.stringify(postData)
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('✅ POST successful:', {
                id: result.id,
                title: result.title
            });
        }
        
    } catch (error) {
        console.log('❌ POST error:', error.message);
    }
    
    // PUT request (update)
    setTimeout(async () => {
        console.log('\n2. PUT Request (Update):');
        
        try {
            const updateData = {
                id: 1,
                title: 'Updated Post Title',
                body: 'This post has been updated.',
                userId: 1
            };
            
            const response = await fetch('https://jsonplaceholder.typicode.com/posts/1', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updateData)
            });
            
            if (response.ok) {
                const result = await response.json();
                console.log('✅ PUT successful:', result.title);
            }
            
        } catch (error) {
            console.log('❌ PUT error:', error.message);
        }
    }, 2000);
    
    // DELETE request
    setTimeout(async () => {
        console.log('\n3. DELETE Request:');
        
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts/1', {
                method: 'DELETE'
            });
            
            if (response.ok) {
                console.log('✅ DELETE successful, status:', response.status);
            }
            
        } catch (error) {
            console.log('❌ DELETE error:', error.message);
        }
    }, 4000);
    
    // Request with timeout
    setTimeout(async () => {
        console.log('\n4. Request with Timeout:');
        
        async function fetchWithTimeout(url, options = {}, timeout = 5000) {
            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                return response;
                
            } catch (error) {
                clearTimeout(timeoutId);
                
                if (error.name === 'AbortError') {
                    throw new Error(`Request timed out after ${timeout}ms`);
                }
                
                throw error;
            }
        }
        
        try {
            // This should succeed (fast endpoint)
            const fastResponse = await fetchWithTimeout(
                'https://jsonplaceholder.typicode.com/posts/1',
                {},
                3000
            );
            console.log('✅ Fast request completed:', fastResponse.status);
            
            // This might timeout (slow endpoint simulation)
            // Note: This is just for demonstration - the endpoint is actually fast
            console.log('⏳ Testing timeout handling...');
            
        } catch (error) {
            console.log('❌ Timeout error:', error.message);
        }
    }, 6000);
}

setTimeout(demonstrateAdvancedFetch, 8000);

/**
 * WORKING WITH DIFFERENT DATA FORMATS
 * 
 * Handle various response formats and content types.
 */

async function demonstrateDataFormats() {
    console.log('\n📊 Working with Different Data Formats:');
    
    // Form data submission
    console.log('1. Form Data Submission:');
    
    try {
        const formData = new FormData();
        formData.append('name', 'John Doe');
        formData.append('email', 'john@example.com');
        formData.append('age', '30');
        
        const response = await fetch('https://httpbin.org/post', {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('✅ Form data sent:', Object.keys(result.form));
        }
        
    } catch (error) {
        console.log('❌ Form data error:', error.message);
    }
    
    // URL-encoded data
    setTimeout(async () => {
        console.log('\n2. URL-Encoded Data:');
        
        try {
            const params = new URLSearchParams();
            params.append('username', 'johndoe');
            params.append('password', 'secret123');
            params.append('remember', 'true');
            
            const response = await fetch('https://httpbin.org/post', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params
            });
            
            if (response.ok) {
                const result = await response.json();
                console.log('✅ URL-encoded data sent:', Object.keys(result.form));
            }
            
        } catch (error) {
            console.log('❌ URL-encoded error:', error.message);
        }
    }, 2000);
    
    // Blob and file handling
    setTimeout(async () => {
        console.log('\n3. Blob and File Handling:');
        
        try {
            // Create a simple text blob
            const textBlob = new Blob(['Hello, World! This is a text blob.'], {
                type: 'text/plain'
            });
            
            const formData = new FormData();
            formData.append('file', textBlob, 'hello.txt');
            formData.append('description', 'A simple text file');
            
            const response = await fetch('https://httpbin.org/post', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                console.log('✅ Blob uploaded:', result.files ? 'File received' : 'Form data sent');
            }
            
        } catch (error) {
            console.log('❌ Blob upload error:', error.message);
        }
    }, 4000);
    
    // Streaming responses
    setTimeout(async () => {
        console.log('\n4. Streaming Response:');
        
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts');
            
            if (response.ok && response.body) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let receivedLength = 0;
                let chunks = [];
                
                console.log('📡 Streaming response...');
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    console.log(`   📦 Received ${receivedLength} bytes`);
                }
                
                // Combine chunks
                const chunksAll = new Uint8Array(receivedLength);
                let position = 0;
                for (let chunk of chunks) {
                    chunksAll.set(chunk, position);
                    position += chunk.length;
                }
                
                const result = decoder.decode(chunksAll);
                const data = JSON.parse(result);
                
                console.log('✅ Streaming complete:', `${data.length} posts received`);
            }
            
        } catch (error) {
            console.log('❌ Streaming error:', error.message);
        }
    }, 6000);
}

setTimeout(demonstrateDataFormats, 16000);
```### Bui
lding a Complete API Client

```javascript
/**
 * BUILDING A COMPLETE API CLIENT
 * 
 * Create a robust, reusable API client with error handling,
 * caching, retries, and more.
 */

console.log('\n=== Building a Complete API Client ===');

class APIClient {
    constructor(baseURL, options = {}) {
        this.baseURL = baseURL.replace(/\/$/, ''); // Remove trailing slash
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            ...options.headers
        };
        this.timeout = options.timeout || 10000;
        this.retries = options.retries || 3;
        this.retryDelay = options.retryDelay || 1000;
        
        // Simple cache implementation
        this.cache = new Map();
        this.cacheTimeout = options.cacheTimeout || 300000; // 5 minutes
        
        console.log(`🚀 API Client initialized for ${this.baseURL}`);
    }
    
    /**
     * Make HTTP request with full configuration
     */
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        const config = {
            method: 'GET',
            headers: { ...this.defaultHeaders, ...options.headers },
            ...options
        };
        
        // Check cache for GET requests
        if (config.method === 'GET') {
            const cached = this.getFromCache(url);
            if (cached) {
                console.log(`💾 Cache hit for ${endpoint}`);
                return cached;
            }
        }
        
        console.log(`📡 ${config.method} ${endpoint}`);
        
        let lastError;
        
        // Retry logic
        for (let attempt = 1; attempt <= this.retries; attempt++) {
            try {
                const response = await this.makeRequest(url, config);
                
                // Cache successful GET requests
                if (config.method === 'GET' && response.ok) {
                    const data = await response.clone().json();
                    this.setCache(url, data);
                }
                
                return await this.handleResponse(response);
                
            } catch (error) {
                lastError = error;
                
                if (attempt < this.retries && this.shouldRetry(error)) {
                    const delay = this.retryDelay * Math.pow(2, attempt - 1); // Exponential backoff
                    console.log(`⏳ Retry ${attempt}/${this.retries} in ${delay}ms`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    break;
                }
            }
        }
        
        throw lastError;
    }
    
    /**
     * Make the actual HTTP request with timeout
     */
    async makeRequest(url, config) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            const response = await fetch(url, {
                ...config,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            return response;
            
        } catch (error) {
            clearTimeout(timeoutId);
            
            if (error.name === 'AbortError') {
                throw new Error(`Request timeout after ${this.timeout}ms`);
            }
            
            throw error;
        }
    }
    
    /**
     * Handle response and errors
     */
    async handleResponse(response) {
        if (!response.ok) {
            const errorData = await response.text();
            throw new APIError(
                `HTTP ${response.status}: ${response.statusText}`,
                response.status,
                errorData
            );
        }
        
        const contentType = response.headers.get('content-type');
        
        if (contentType && contentType.includes('application/json')) {
            return await response.json();
        } else {
            return await response.text();
        }
    }
    
    /**
     * Determine if request should be retried
     */
    shouldRetry(error) {
        // Retry on network errors and 5xx server errors
        return error.name === 'TypeError' || // Network error
               error.message.includes('timeout') ||
               (error.status >= 500 && error.status < 600);
    }
    
    /**
     * Cache management
     */
    getFromCache(key) {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }
        
        if (cached) {
            this.cache.delete(key); // Remove expired cache
        }
        
        return null;
    }
    
    setCache(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }
    
    clearCache() {
        this.cache.clear();
        console.log('🧹 Cache cleared');
    }
    
    /**
     * Convenience methods for different HTTP verbs
     */
    async get(endpoint, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const url = queryString ? `${endpoint}?${queryString}` : endpoint;
        
        return this.request(url, { method: 'GET' });
    }
    
    async post(endpoint, data, options = {}) {
        return this.request(endpoint, {
            method: 'POST',
            body: JSON.stringify(data),
            ...options
        });
    }
    
    async put(endpoint, data, options = {}) {
        return this.request(endpoint, {
            method: 'PUT',
            body: JSON.stringify(data),
            ...options
        });
    }
    
    async patch(endpoint, data, options = {}) {
        return this.request(endpoint, {
            method: 'PATCH',
            body: JSON.stringify(data),
            ...options
        });
    }
    
    async delete(endpoint, options = {}) {
        return this.request(endpoint, {
            method: 'DELETE',
            ...options
        });
    }
    
    /**
     * Upload file with progress tracking
     */
    async upload(endpoint, file, onProgress) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const formData = new FormData();
            formData.append('file', file);
            
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable && onProgress) {
                    const percentComplete = (e.loaded / e.total) * 100;
                    onProgress(percentComplete);
                }
            });
            
            xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        resolve(response);
                    } catch (error) {
                        resolve(xhr.responseText);
                    }
                } else {
                    reject(new APIError(`Upload failed: ${xhr.statusText}`, xhr.status));
                }
            });
            
            xhr.addEventListener('error', () => {
                reject(new Error('Upload failed'));
            });
            
            xhr.open('POST', `${this.baseURL}${endpoint}`);
            
            // Add default headers (except Content-Type for FormData)
            Object.entries(this.defaultHeaders).forEach(([key, value]) => {
                if (key.toLowerCase() !== 'content-type') {
                    xhr.setRequestHeader(key, value);
                }
            });
            
            xhr.send(formData);
        });
    }
}

/**
 * Custom API Error class
 */
class APIError extends Error {
    constructor(message, status, data) {
        super(message);
        this.name = 'APIError';
        this.status = status;
        this.data = data;
    }
}

/**
 * DEMONSTRATION OF API CLIENT
 */

async function demonstrateAPIClient() {
    console.log('\n🎯 API Client Demonstration:');
    
    // Create API client instance
    const api = new APIClient('https://jsonplaceholder.typicode.com', {
        timeout: 5000,
        retries: 2,
        cacheTimeout: 60000, // 1 minute cache
        headers: {
            'User-Agent': 'MyApp/1.0'
        }
    });
    
    try {
        // GET request with caching
        console.log('1. GET request (will be cached):');
        const post = await api.get('/posts/1');
        console.log('✅ Post fetched:', post.title.substring(0, 30) + '...');
        
        // Same request (should hit cache)
        console.log('\n2. Same GET request (should hit cache):');
        const cachedPost = await api.get('/posts/1');
        console.log('✅ Cached post:', cachedPost.title.substring(0, 30) + '...');
        
        // GET with query parameters
        setTimeout(async () => {
            console.log('\n3. GET with query parameters:');
            const posts = await api.get('/posts', { userId: 1, _limit: 3 });
            console.log('✅ User posts:', posts.length, 'posts');
        }, 1000);
        
        // POST request
        setTimeout(async () => {
            console.log('\n4. POST request:');
            const newPost = await api.post('/posts', {
                title: 'My New Post',
                body: 'This is the content of my new post.',
                userId: 1
            });
            console.log('✅ Post created:', newPost.id);
        }, 2000);
        
        // PUT request
        setTimeout(async () => {
            console.log('\n5. PUT request:');
            const updatedPost = await api.put('/posts/1', {
                id: 1,
                title: 'Updated Post Title',
                body: 'This post has been updated.',
                userId: 1
            });
            console.log('✅ Post updated:', updatedPost.title);
        }, 3000);
        
        // DELETE request
        setTimeout(async () => {
            console.log('\n6. DELETE request:');
            await api.delete('/posts/1');
            console.log('✅ Post deleted');
        }, 4000);
        
        // Error handling demonstration
        setTimeout(async () => {
            console.log('\n7. Error handling:');
            try {
                await api.get('/posts/999999'); // Non-existent post
            } catch (error) {
                if (error instanceof APIError) {
                    console.log('❌ API Error:', error.message, `(Status: ${error.status})`);
                } else {
                    console.log('❌ Network Error:', error.message);
                }
            }
        }, 5000);
        
    } catch (error) {
        console.log('❌ API Client error:', error.message);
    }
}

demonstrateAPIClient();

/**
 * REAL-WORLD API INTEGRATION EXAMPLE
 * 
 * A practical example showing how to integrate with a real API.
 */

class UserService {
    constructor() {
        this.api = new APIClient('https://jsonplaceholder.typicode.com', {
            timeout: 8000,
            retries: 3,
            cacheTimeout: 120000 // 2 minutes
        });
    }
    
    async getUser(id) {
        try {
            const user = await this.api.get(`/users/${id}`);
            return {
                id: user.id,
                name: user.name,
                email: user.email,
                website: user.website,
                company: user.company.name
            };
        } catch (error) {
            throw new Error(`Failed to fetch user ${id}: ${error.message}`);
        }
    }
    
    async getUserPosts(userId) {
        try {
            const posts = await this.api.get('/posts', { userId });
            return posts.map(post => ({
                id: post.id,
                title: post.title,
                summary: post.body.substring(0, 100) + '...'
            }));
        } catch (error) {
            throw new Error(`Failed to fetch posts for user ${userId}: ${error.message}`);
        }
    }
    
    async getUserProfile(userId) {
        try {
            // Fetch user and posts in parallel
            const [user, posts] = await Promise.all([
                this.getUser(userId),
                this.getUserPosts(userId)
            ]);
            
            return {
                ...user,
                postsCount: posts.length,
                recentPosts: posts.slice(0, 3)
            };
        } catch (error) {
            throw new Error(`Failed to fetch user profile: ${error.message}`);
        }
    }
    
    async createPost(userId, postData) {
        try {
            const post = await this.api.post('/posts', {
                ...postData,
                userId
            });
            
            console.log('📝 Post created successfully');
            return post;
        } catch (error) {
            throw new Error(`Failed to create post: ${error.message}`);
        }
    }
}

async function demonstrateUserService() {
    console.log('\n👤 User Service Demonstration:');
    
    const userService = new UserService();
    
    try {
        // Get user profile
        console.log('1. Fetching user profile...');
        const profile = await userService.getUserProfile(1);
        
        console.log('✅ User Profile:', {
            name: profile.name,
            email: profile.email,
            company: profile.company,
            postsCount: profile.postsCount,
            recentPostTitles: profile.recentPosts.map(p => p.title.substring(0, 30))
        });
        
        // Create new post
        setTimeout(async () => {
            console.log('\n2. Creating new post...');
            const newPost = await userService.createPost(1, {
                title: 'My API Integration Post',
                body: 'This post was created using our API client!'
            });
            
            console.log('✅ New post created:', {
                id: newPost.id,
                title: newPost.title
            });
        }, 2000);
        
    } catch (error) {
        console.log('❌ User service error:', error.message);
    }
}

setTimeout(demonstrateUserService, 8000);

console.log('\n💡 API Client Key Features:');
console.log('✅ Automatic retries with exponential backoff');
console.log('✅ Request/response caching');
console.log('✅ Timeout handling');
console.log('✅ Error handling and custom error types');
console.log('✅ Convenience methods for HTTP verbs');
console.log('✅ File upload with progress tracking');
console.log('✅ Configurable base URL and headers');
console.log('✅ Promise-based API with async/await support');
```

---

## 🎯 Real-World Project: Weather Dashboard

Let's build a comprehensive weather dashboard that demonstrates all the async concepts we've learned.

```javascript
/**
 * REAL-WORLD PROJECT: WEATHER DASHBOARD
 * 
 * A complete application demonstrating:
 * - API integration with error handling
 * - Async/await patterns
 * - Promise composition
 * - Caching and performance optimization
 * - User interface updates
 * - Real-time data updates
 */

console.log('=== Weather Dashboard Project ===');

class WeatherDashboard {
    constructor() {
        this.apiKey = 'demo-key'; // In real app, use environment variables
        this.baseURL = 'https://api.openweathermap.org/data/2.5';
        this.cache = new Map();
        this.cacheTimeout = 600000; // 10 minutes
        this.updateInterval = null;
        
        this.locations = [
            { name: 'New York', lat: 40.7128, lon: -74.0060 },
            { name: 'London', lat: 51.5074, lon: -0.1278 },
            { name: 'Tokyo', lat: 35.6762, lon: 139.6503 },
            { name: 'Sydney', lat: -33.8688, lon: 151.2093 }
        ];
        
        this.init();
    }
    
    async init() {
        console.log('🌤️ Initializing Weather Dashboard...');
        
        try {
            await this.loadInitialData();
            this.startAutoUpdate();
            console.log('✅ Weather Dashboard initialized successfully');
        } catch (error) {
            console.error('❌ Failed to initialize dashboard:', error.message);
        }
    }
    
    /**
     * Load initial weather data for all locations
     */
    async loadInitialData() {
        console.log('📡 Loading initial weather data...');
        
        // Load weather data for all locations in parallel
        const weatherPromises = this.locations.map(location => 
            this.getWeatherData(location).catch(error => ({
                location: location.name,
                error: error.message
            }))
        );
        
        const results = await Promise.allSettled(weatherPromises);
        
        results.forEach((result, index) => {
            const location = this.locations[index];
            
            if (result.status === 'fulfilled') {
                if (result.value.error) {
                    console.log(`❌ ${location.name}: ${result.value.error}`);
                } else {
                    console.log(`✅ ${location.name}: ${result.value.temperature}°C, ${result.value.description}`);
                }
            } else {
                console.log(`❌ ${location.name}: Failed to load`);
            }
        });
    }
    
    /**
     * Get weather data for a specific location
     */
    async getWeatherData(location) {
        const cacheKey = `${location.lat},${location.lon}`;
        
        // Check cache first
        const cached = this.getFromCache(cacheKey);
        if (cached) {
            console.log(`💾 Using cached data for ${location.name}`);
            return cached;
        }
        
        try {
            // Simulate API call (using mock data since we don't have a real API key)
            const weatherData = await this.simulateWeatherAPI(location);
            
            // Cache the result
            this.setCache(cacheKey, weatherData);
            
            return weatherData;
            
        } catch (error) {
            throw new Error(`Weather API error for ${location.name}: ${error.message}`);
        }
    }
    
    /**
     * Simulate weather API call (replace with real API in production)
     */
    async simulateWeatherAPI(location) {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
        
        // Simulate occasional API failures
        if (Math.random() < 0.1) {
            throw new Error('API temporarily unavailable');
        }
        
        // Generate mock weather data
        const conditions = ['Clear', 'Cloudy', 'Rainy', 'Sunny', 'Partly Cloudy'];
        const temperature = Math.round(Math.random() * 30 + 5); // 5-35°C
        const humidity = Math.round(Math.random() * 40 + 40); // 40-80%
        const windSpeed = Math.round(Math.random() * 20 + 5); // 5-25 km/h
        
        return {
            location: location.name,
            temperature,
            description: conditions[Math.floor(Math.random() * conditions.length)],
            humidity,
            windSpeed,
            timestamp: new Date().toISOString(),
            coordinates: { lat: location.lat, lon: location.lon }
        };
    }
    
    /**
     * Get forecast data (5-day forecast)
     */
    async getForecastData(location) {
        console.log(`📅 Getting forecast for ${location.name}...`);
        
        try {
            // Simulate forecast API call
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const forecast = [];
            const today = new Date();
            
            for (let i = 1; i <= 5; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + i);
                
                forecast.push({
                    date: date.toISOString().split('T')[0],
                    temperature: {
                        high: Math.round(Math.random() * 10 + 20),
                        low: Math.round(Math.random() * 10 + 10)
                    },
                    description: ['Sunny', 'Cloudy', 'Rainy'][Math.floor(Math.random() * 3)],
                    precipitation: Math.round(Math.random() * 100)
                });
            }
            
            return forecast;
            
        } catch (error) {
            throw new Error(`Forecast API error: ${error.message}`);
        }
    }
    
    /**
     * Get detailed weather information including forecast
     */
    async getDetailedWeather(location) {
        console.log(`🔍 Getting detailed weather for ${location.name}...`);
        
        try {
            // Fetch current weather and forecast in parallel
            const [currentWeather, forecast] = await Promise.all([
                this.getWeatherData(location),
                this.getForecastData(location)
            ]);
            
            return {
                current: currentWeather,
                forecast: forecast,
                lastUpdated: new Date().toISOString()
            };
            
        } catch (error) {
            throw new Error(`Failed to get detailed weather: ${error.message}`);
        }
    }
    
    /**
     * Update weather data for all locations
     */
    async updateAllLocations() {
        console.log('🔄 Updating weather data for all locations...');
        
        const updatePromises = this.locations.map(async (location) => {
            try {
                const weather = await this.getWeatherData(location);
                return { location: location.name, weather, success: true };
            } catch (error) {
                return { location: location.name, error: error.message, success: false };
            }
        });
        
        const results = await Promise.allSettled(updatePromises);
        
        let successCount = 0;
        let errorCount = 0;
        
        results.forEach(result => {
            if (result.status === 'fulfilled' && result.value.success) {
                successCount++;
            } else {
                errorCount++;
            }
        });
        
        console.log(`📊 Update complete: ${successCount} successful, ${errorCount} failed`);
        return { successCount, errorCount };
    }
    
    /**
     * Start automatic updates
     */
    startAutoUpdate() {
        console.log('⏰ Starting automatic updates every 5 minutes...');
        
        this.updateInterval = setInterval(async () => {
            try {
                await this.updateAllLocations();
            } catch (error) {
                console.error('❌ Auto-update failed:', error.message);
            }
        }, 300000); // 5 minutes
    }
    
    /**
     * Stop automatic updates
     */
    stopAutoUpdate() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
            console.log('⏹️ Automatic updates stopped');
        }
    }
    
    /**
     * Search weather by city name
     */
    async searchWeather(cityName) {
        console.log(`🔍 Searching weather for: ${cityName}`);
        
        try {
            // Simulate geocoding API to get coordinates
            await new Promise(resolve => setTimeout(resolve, 600));
            
            // Mock coordinates for demo
            const mockLocation = {
                name: cityName,
                lat: Math.random() * 180 - 90,
                lon: Math.random() * 360 - 180
            };
            
            const weather = await this.getWeatherData(mockLocation);
            console.log(`✅ Found weather for ${cityName}:`, weather);
            
            return weather;
            
        } catch (error) {
            throw new Error(`Search failed for ${cityName}: ${error.message}`);
        }
    }
    
    /**
     * Cache management
     */
    getFromCache(key) {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }
        
        if (cached) {
            this.cache.delete(key);
        }
        
        return null;
    }
    
    setCache(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }
    
    clearCache() {
        this.cache.clear();
        console.log('🧹 Weather cache cleared');
    }
    
    /**
     * Get dashboard statistics
     */
    getStats() {
        return {
            locationsTracked: this.locations.length,
            cacheSize: this.cache.size,
            autoUpdateActive: !!this.updateInterval,
            cacheTimeout: this.cacheTimeout / 1000 / 60 // minutes
        };
    }
    
    /**
     * Cleanup resources
     */
    destroy() {
        this.stopAutoUpdate();
        this.clearCache();
        console.log('🧹 Weather Dashboard destroyed');
    }
}

/**
 * DEMONSTRATION OF WEATHER DASHBOARD
 */

async function demonstrateWeatherDashboard() {
    console.log('\n🌤️ Weather Dashboard Demonstration:');
    
    // Create dashboard instance
    const dashboard = new WeatherDashboard();
    
    // Wait for initialization
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Get detailed weather for a specific location
    setTimeout(async () => {
        console.log('\n📊 Getting detailed weather...');
        try {
            const detailed = await dashboard.getDetailedWeather(dashboard.locations[0]);
            console.log('✅ Detailed weather:', {
                current: `${detailed.current.temperature}°C, ${detailed.current.description}`,
                forecastDays: detailed.forecast.length,
                lastUpdated: detailed.lastUpdated.split('T')[1].split('.')[0]
            });
        } catch (error) {
            console.log('❌ Detailed weather error:', error.message);
        }
    }, 4000);
    
    // Search for weather in a new city
    setTimeout(async () => {
        console.log('\n🔍 Searching for weather in Paris...');
        try {
            const parisWeather = await dashboard.searchWeather('Paris');
            console.log('✅ Paris weather found:', `${parisWeather.temperature}°C`);
        } catch (error) {
            console.log('❌ Paris search error:', error.message);
        }
    }, 6000);
    
    // Show dashboard statistics
    setTimeout(() => {
        console.log('\n📈 Dashboard Statistics:');
        const stats = dashboard.getStats();
        console.log('📊 Stats:', stats);
    }, 8000);
    
    // Cleanup after demo
    setTimeout(() => {
        dashboard.destroy();
    }, 10000);
}

demonstrateWeatherDashboard();

console.log('\n💡 Weather Dashboard Features:');
console.log('✅ Parallel API calls for multiple locations');
console.log('✅ Intelligent caching with expiration');
console.log('✅ Automatic data updates');
console.log('✅ Error handling and graceful degradation');
console.log('✅ Promise composition for complex operations');
console.log('✅ Async/await for clean, readable code');
console.log('✅ Resource management and cleanup');
console.log('🚀 Production-ready async patterns!');
```

---

## 🎓 Summary and Best Practices

### Key Takeaways

```
🏆 Async JavaScript Mastery Checklist:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Understand the event loop and non-blocking nature        │
│ ✅ Master callbacks and avoid callback hell                │
│ ✅ Create and consume Promises effectively                  │
│ ✅ Use async/await for clean, readable code                │
│ ✅ Handle errors properly with try/catch                   │
│ ✅ Compose parallel and sequential operations              │
│ ✅ Build robust API clients with error handling           │
│ ✅ Implement caching and performance optimizations        │
└─────────────────────────────────────────────────────────────┘
```

### Best Practices Summary

1. **Choose the Right Tool**
   - Use async/await for most scenarios (cleanest syntax)
   - Use Promises directly for complex compositions
   - Avoid callbacks for new code (legacy support only)

2. **Error Handling**
   - Always handle errors in async operations
   - Use try/catch with async/await
   - Implement proper error boundaries
   - Provide meaningful error messages

3. **Performance Optimization**
   - Use Promise.all() for parallel operations
   - Implement caching for repeated requests
   - Add timeouts to prevent hanging requests
   - Use request deduplication for identical calls

4. **Code Organization**
   - Keep async functions focused and small
   - Use proper separation of concerns
   - Implement retry logic for unreliable operations
   - Clean up resources properly

You've now mastered asynchronous JavaScript! These patterns will help you build responsive, efficient applications that handle real-world async operations gracefully. 🚀