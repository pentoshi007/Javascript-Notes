# 🔢 10. Working With Arrays

> **Ultimate JavaScript Arrays Masterclass** - Master array methods, data transformations, and functional programming patterns

---

## 🎯 What You'll Master

```
🚀 Array Mastery Arsenal:
┌─────────────────────────────────────────────────────────────┐
│ • Array Creation & Basic Methods                            │
│ • Modern Array Methods (ES6+)                              │
│ • Data Transformations (map, filter, reduce)               │
│ • Array Iteration Patterns (forEach, for-of)               │
│ • Search & Test Methods (find, some, every)                │
│ • Sorting & Flattening Arrays                              │
│ • Method Chaining & Functional Programming                 │
│ • Real-World Banking Application Project                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔧 Simple Array Methods

### Array Creation and Basic Operations

```javascript
// Different ways to create arrays
const fruits = ['apple', 'banana', 'orange'];
const numbers = new Array(1, 2, 3, 4, 5);
const mixed = ['text', 42, true, null, { name: 'object' }];

console.log('Fruits:', fruits);
// Output: Fruits: ['apple', 'banana', 'orange']

console.log('Numbers:', numbers);
// Output: Numbers: [1, 2, 3, 4, 5]

// Accessing elements
console.log('First fruit:', fruits[0]);        // Output: apple
console.log('Last fruit:', fruits[fruits.length - 1]); // Output: orange

// Modifying elements
fruits[1] = 'grape';
console.log('Modified fruits:', fruits);
// Output: Modified fruits: ['apple', 'grape', 'orange']

// Array length
console.log('Array length:', fruits.length);   // Output: 3
```

### Essential Array Methods

```javascript
const animals = ['dog', 'cat', 'bird'];

// toString() - convert to string
console.log(animals.toString());
// Output: dog,cat,bird

// join() - join with custom separator
console.log(animals.join(' | '));
// Output: dog | cat | bird

console.log(animals.join(''));
// Output: dogcatbird

// Adding elements
animals.push('fish');           // Add to end
console.log('After push:', animals);
// Output: After push: ['dog', 'cat', 'bird', 'fish']

animals.unshift('hamster');     // Add to beginning
console.log('After unshift:', animals);
// Output: After unshift: ['hamster', 'dog', 'cat', 'bird', 'fish']

// Removing elements
const lastAnimal = animals.pop();        // Remove from end
console.log('Removed:', lastAnimal);     // Output: fish
console.log('After pop:', animals);
// Output: After pop: ['hamster', 'dog', 'cat', 'bird']

const firstAnimal = animals.shift();     // Remove from beginning
console.log('Removed:', firstAnimal);    // Output: hamster
console.log('After shift:', animals);
// Output: After shift: ['dog', 'cat', 'bird']

// Finding elements
console.log('Index of cat:', animals.indexOf('cat'));      // Output: 1
console.log('Last index of dog:', animals.lastIndexOf('dog')); // Output: 0
console.log('Includes bird:', animals.includes('bird'));   // Output: true
```

### Advanced Array Manipulation

```javascript
const letters = ['a', 'b', 'c', 'd', 'e'];

// slice() - extract portion (doesn't modify original)
console.log('Original:', letters);
// Output: Original: ['a', 'b', 'c', 'd', 'e']

console.log('Slice(2):', letters.slice(2));
// Output: Slice(2): ['c', 'd', 'e']

console.log('Slice(2, 4):', letters.slice(2, 4));
// Output: Slice(2, 4): ['c', 'd']

console.log('Slice(-2):', letters.slice(-2));
// Output: Slice(-2): ['d', 'e']

console.log('Slice(1, -2):', letters.slice(1, -2));
// Output: Slice(1, -2): ['b', 'c']

// Create shallow copy
const lettersCopy = letters.slice();
const lettersCopy2 = [...letters]; // Modern alternative
console.log('Copy methods equal:', JSON.stringify(lettersCopy) === JSON.stringify(lettersCopy2));
// Output: true

// splice() - modify original array
const testArray = ['a', 'b', 'c', 'd', 'e'];
console.log('Before splice:', testArray);
// Output: Before splice: ['a', 'b', 'c', 'd', 'e']

const removed = testArray.splice(2, 2, 'X', 'Y');
console.log('Removed elements:', removed);
// Output: Removed elements: ['c', 'd']

console.log('After splice:', testArray);
// Output: After splice: ['a', 'b', 'X', 'Y', 'e']

// reverse() - modifies original array
const numbers = [1, 2, 3, 4, 5];
console.log('Before reverse:', numbers);
// Output: Before reverse: [1, 2, 3, 4, 5]

numbers.reverse();
console.log('After reverse:', numbers);
// Output: After reverse: [5, 4, 3, 2, 1]

// concat() - combine arrays (doesn't modify originals)
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = arr1.concat(arr2);
const combinedModern = [...arr1, ...arr2]; // Modern alternative

console.log('Concat result:', combined);
// Output: Concat result: [1, 2, 3, 4, 5, 6]

console.log('Spread result:', combinedModern);
// Output: Spread result: [1, 2, 3, 4, 5, 6]
```

---

## 🆕 The at() Method (ES2022)

### Modern Array Element Access

```javascript
const arr = [23, 11, 64, 89, 45];

// Traditional way to access elements
console.log('First element (traditional):', arr[0]);
// Output: First element (traditional): 23

// Modern way with at()
console.log('First element (at method):', arr.at(0));
// Output: First element (at method): 23

// Getting last element - traditional ways
console.log('Last element (bracket):', arr[arr.length - 1]);
// Output: Last element (bracket): 45

console.log('Last element (slice):', arr.slice(-1)[0]);
// Output: Last element (slice): 45

// ✅ Modern way with at() - much cleaner!
console.log('Last element (at method):', arr.at(-1));
// Output: Last element (at method): 45

console.log('Second to last:', arr.at(-2));
// Output: Second to last: 89

// Works with strings too!
const name = 'JavaScript';
console.log('First char:', name.at(0));     // Output: J
console.log('Last char:', name.at(-1));     // Output: t
console.log('Second char:', name.at(1));    // Output: a

// Practical example: Safe array access
function getLastElement(array) {
    return array.length > 0 ? array.at(-1) : undefined;
}

console.log(getLastElement([1, 2, 3]));     // Output: 3
console.log(getLastElement([]));            // Output: undefined

// Method chaining with at()
const users = [
    { name: 'Alice', scores: [85, 92, 78] },
    { name: 'Bob', scores: [90, 88, 95] },
    { name: 'Charlie', scores: [76, 82, 89] }
];

// Get the last score of the first user
console.log('Alice last score:', users.at(0).scores.at(-1));
// Output: Alice last score: 78

// Get the first score of the last user
console.log('Charlie first score:', users.at(-1).scores.at(0));
// Output: Charlie first score: 76
```

---

## 🔄 Looping Arrays: forEach

### Understanding forEach

```
🔄 forEach vs for-of Loop:
┌─────────────────────────────────────────────────────────────┐
│ forEach:                                                    │
│ • Method on arrays                                          │
│ • Cannot break or continue                                  │
│ • Always returns undefined                                  │
│ • Provides index automatically                              │
│                                                             │
│ for-of:                                                     │
│ • Works with any iterable                                   │
│ • Can break and continue                                    │
│ • Can return values                                         │
│ • Need .entries() for index                                 │
└─────────────────────────────────────────────────────────────┘
```

### Basic forEach Usage

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Traditional for loop
console.log('=== Traditional for loop ===');
for (let i = 0; i < movements.length; i++) {
    const movement = movements[i];
    if (movement > 0) {
        console.log(`Movement ${i + 1}: You deposited ${movement}`);
    } else {
        console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
    }
}

// for-of loop with entries
console.log('\n=== for-of loop ===');
for (const [i, movement] of movements.entries()) {
    if (movement > 0) {
        console.log(`Movement ${i + 1}: You deposited ${movement}`);
    } else {
        console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
    }
}

// ✅ forEach method (most functional approach)
console.log('\n=== forEach method ===');
movements.forEach(function(movement, index, array) {
    if (movement > 0) {
        console.log(`Movement ${index + 1}: You deposited ${movement}`);
    } else {
        console.log(`Movement ${index + 1}: You withdrew ${Math.abs(movement)}`);
    }
});

// Arrow function version
console.log('\n=== forEach with arrow function ===');
movements.forEach((mov, i) => {
    const type = mov > 0 ? 'deposited' : 'withdrew';
    const amount = Math.abs(mov);
    console.log(`Movement ${i + 1}: You ${type} ${amount}`);
});

// Output for all versions:
// Movement 1: You deposited 200
// Movement 2: You deposited 450
// Movement 3: You withdrew 400
// Movement 4: You deposited 3000
// Movement 5: You withdrew 650
// Movement 6: You withdrew 130
// Movement 7: You deposited 70
// Movement 8: You deposited 1300
```

### forEach with Maps and Sets

```javascript
// forEach with Maps
const currencies = new Map([
    ['USD', 'United States Dollar'],
    ['EUR', 'Euro'],
    ['GBP', 'Pound Sterling'],
    ['JPY', 'Japanese Yen']
]);

console.log('=== Map forEach ===');
currencies.forEach(function(value, key, map) {
    console.log(`${key}: ${value}`);
});
// Output: USD: United States Dollar
//         EUR: Euro
//         GBP: Pound Sterling
//         JPY: Japanese Yen

// forEach with Sets
const currenciesUnique = new Set(['USD', 'GBP', 'USD', 'EUR', 'EUR', 'JPY']);
console.log('\nUnique currencies:', currenciesUnique);
// Output: Set(4) {'USD', 'GBP', 'EUR', 'JPY'}

console.log('\n=== Set forEach ===');
currenciesUnique.forEach(function(value, _, set) {
    // Note: Sets don't have keys, so key === value
    console.log(`Currency: ${value}`);
});
// Output: Currency: USD
//         Currency: GBP
//         Currency: EUR
//         Currency: JPY

// Practical example: Processing user data
const users = [
    { name: 'Alice', age: 25, active: true },
    { name: 'Bob', age: 30, active: false },
    { name: 'Charlie', age: 35, active: true }
];

console.log('\n=== User Processing ===');
users.forEach((user, index) => {
    const status = user.active ? 'Active' : 'Inactive';
    console.log(`${index + 1}. ${user.name} (${user.age}) - ${status}`);
});
// Output: 1. Alice (25) - Active
//         2. Bob (30) - Inactive
//         3. Charlie (35) - Active

// When NOT to use forEach
console.log('\n=== When forEach limitations matter ===');

// ❌ Cannot break out of forEach
try {
    movements.forEach((mov, i) => {
        if (mov < 0) {
            console.log(`First withdrawal found at index ${i}: ${mov}`);
            // break; // SyntaxError! Cannot use break in forEach
            // return; // Only exits current iteration, not the loop
        }
    });
} catch (error) {
    console.log('Error:', error.message);
}

// ✅ Use for-of when you need to break
for (const [i, mov] of movements.entries()) {
    if (mov < 0) {
        console.log(`First withdrawal found at index ${i}: ${mov}`);
        break; // This works!
    }
}
// Output: First withdrawal found at index 2: -400
```

---

## 🎨 Data Transformations: map, filter, reduce

### The Big Three Array Methods

```
🎯 Data Transformation Methods:
┌─────────────────────────────────────────────────────────────┐
│ map()    │ Transform each element → New array same length   │
│ filter() │ Select elements by condition → New array subset  │
│ reduce() │ Accumulate elements → Single value              │
└─────────────────────────────────────────────────────────────┘
```

### The map() Method

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Convert EUR to USD
const eurToUsd = 1.1;

// Traditional approach with for loop
const movementsUSDfor = [];
for (const mov of movements) {
    movementsUSDfor.push(mov * eurToUsd);
}
console.log('USD (for loop):', movementsUSDfor);

// ✅ Functional approach with map
const movementsUSD = movements.map(function(mov) {
    return mov * eurToUsd;
});
console.log('USD (map):', movementsUSD);
// Output: USD (map): [220, 495, -440, 3300, -715, -143, 77, 1430]

// Arrow function version (more concise)
const movementsUSDArrow = movements.map(mov => mov * eurToUsd);
console.log('USD (arrow):', movementsUSDArrow);

// More complex transformation with index
const movementsDescriptions = movements.map((mov, i) => {
    const type = mov > 0 ? 'deposited' : 'withdrew';
    return `Movement ${i + 1}: You ${type} ${Math.abs(mov)}`;
});

console.log('Descriptions:', movementsDescriptions);
// Output: [
//   'Movement 1: You deposited 200',
//   'Movement 2: You deposited 450',
//   'Movement 3: You withdrew 400',
//   'Movement 4: You deposited 3000',
//   'Movement 5: You withdrew 650',
//   'Movement 6: You withdrew 130',
//   'Movement 7: You deposited 70',
//   'Movement 8: You deposited 1300'
// ]

// Real-world example: Processing user data
const users = [
    { firstName: 'John', lastName: 'Doe', age: 30 },
    { firstName: 'Jane', lastName: 'Smith', age: 25 },
    { firstName: 'Bob', lastName: 'Johnson', age: 35 }
];

// Create display names
const displayNames = users.map(user => `${user.firstName} ${user.lastName}`);
console.log('Display names:', displayNames);
// Output: ['John Doe', 'Jane Smith', 'Bob Johnson']

// Create user cards with computed properties
const userCards = users.map((user, index) => ({
    id: index + 1,
    fullName: `${user.firstName} ${user.lastName}`,
    initials: `${user.firstName[0]}${user.lastName[0]}`,
    isAdult: user.age >= 18,
    birthYear: new Date().getFullYear() - user.age
}));

console.log('User cards:', userCards);
// Output: [
//   { id: 1, fullName: 'John Doe', initials: 'JD', isAdult: true, birthYear: 1994 },
//   { id: 2, fullName: 'Jane Smith', initials: 'JS', isAdult: true, birthYear: 1999 },
//   { id: 3, fullName: 'Bob Johnson', initials: 'BJ', isAdult: true, birthYear: 1989 }
// ]
```

### The filter() Method

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Filter deposits (positive movements)
const deposits = movements.filter(function(mov) {
    return mov > 0;
});
console.log('Deposits:', deposits);
// Output: Deposits: [200, 450, 3000, 70, 1300]

// Traditional approach with for loop
const depositsFor = [];
for (const mov of movements) {
    if (mov > 0) depositsFor.push(mov);
}
console.log('Deposits (for loop):', depositsFor);

// Filter withdrawals (negative movements)
const withdrawals = movements.filter(mov => mov < 0);
console.log('Withdrawals:', withdrawals);
// Output: Withdrawals: [-400, -650, -130]

// More complex filtering
const largeDeposits = movements.filter(mov => mov > 1000);
console.log('Large deposits:', largeDeposits);
// Output: Large deposits: [3000, 1300]

// Real-world example: Filter users
const users = [
    { name: 'Alice', age: 17, active: true, role: 'user' },
    { name: 'Bob', age: 25, active: false, role: 'admin' },
    { name: 'Charlie', age: 30, active: true, role: 'user' },
    { name: 'Diana', age: 22, active: true, role: 'moderator' }
];

// Filter active adult users
const activeAdults = users.filter(user => user.active && user.age >= 18);
console.log('Active adults:', activeAdults);
// Output: [
//   { name: 'Charlie', age: 30, active: true, role: 'user' },
//   { name: 'Diana', age: 22, active: true, role: 'moderator' }
// ]

// Filter by multiple conditions
const adminUsers = users.filter(user => 
    user.role === 'admin' || user.role === 'moderator'
);
console.log('Admin users:', adminUsers);
// Output: [
//   { name: 'Bob', age: 25, active: false, role: 'admin' },
//   { name: 'Diana', age: 22, active: true, role: 'moderator' }
// ]

// Filter with complex logic
const eligibleUsers = users.filter(user => {
    const isAdult = user.age >= 18;
    const isActive = user.active;
    const hasPermissions = user.role !== 'user';
    
    return isAdult && (isActive || hasPermissions);
});
console.log('Eligible users:', eligibleUsers);
// Output: [
//   { name: 'Bob', age: 25, active: false, role: 'admin' },
//   { name: 'Charlie', age: 30, active: true, role: 'user' },
//   { name: 'Diana', age: 22, active: true, role: 'moderator' }
// ]
```

### The reduce() Method

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Calculate total balance
console.log('Movements:', movements);

// Traditional approach with for loop
let balance2 = 0;
for (const mov of movements) {
    balance2 += mov;
}
console.log('Balance (for loop):', balance2);

// ✅ Functional approach with reduce
const balance = movements.reduce(function(accumulator, current, index, array) {
    console.log(`Iteration ${index}: acc=${accumulator}, cur=${current}`);
    return accumulator + current;
}, 0); // 0 is the initial value

console.log('Final balance:', balance);
// Output: Final balance: 2840

// Arrow function version (more concise)
const balanceArrow = movements.reduce((acc, cur) => acc + cur, 0);
console.log('Balance (arrow):', balanceArrow);

// Find maximum value
const maxMovement = movements.reduce((acc, mov) => {
    return acc > mov ? acc : mov;
}, movements[0]); // Use first element as initial value

console.log('Maximum movement:', maxMovement);
// Output: Maximum movement: 3000

// Find minimum value
const minMovement = movements.reduce((acc, mov) => 
    acc < mov ? acc : mov, movements[0]
);
console.log('Minimum movement:', minMovement);
// Output: Minimum movement: -650

// Complex reduce: Calculate statistics
const stats = movements.reduce((acc, mov) => {
    acc.sum += mov;
    acc.count++;
    acc.max = Math.max(acc.max, mov);
    acc.min = Math.min(acc.min, mov);
    acc.average = acc.sum / acc.count;
    
    if (mov > 0) {
        acc.deposits.push(mov);
    } else {
        acc.withdrawals.push(mov);
    }
    
    return acc;
}, {
    sum: 0,
    count: 0,
    max: -Infinity,
    min: Infinity,
    average: 0,
    deposits: [],
    withdrawals: []
});

console.log('Movement statistics:', stats);
// Output: {
//   sum: 2840,
//   count: 8,
//   max: 3000,
//   min: -650,
//   average: 355,
//   deposits: [200, 450, 3000, 70, 1300],
//   withdrawals: [-400, -650, -130]
// }

// Real-world example: Group and count items
const products = [
    { name: 'Laptop', category: 'Electronics', price: 999 },
    { name: 'Phone', category: 'Electronics', price: 599 },
    { name: 'Shirt', category: 'Clothing', price: 29 },
    { name: 'Jeans', category: 'Clothing', price: 79 },
    { name: 'Book', category: 'Books', price: 15 }
];

const categoryStats = products.reduce((acc, product) => {
    const category = product.category;
    
    if (!acc[category]) {
        acc[category] = {
            count: 0,
            totalValue: 0,
            products: []
        };
    }
    
    acc[category].count++;
    acc[category].totalValue += product.price;
    acc[category].products.push(product.name);
    
    return acc;
}, {});

console.log('Category statistics:', categoryStats);
// Output: {
//   Electronics: { count: 2, totalValue: 1598, products: ['Laptop', 'Phone'] },
//   Clothing: { count: 2, totalValue: 108, products: ['Shirt', 'Jeans'] },
//   Books: { count: 1, totalValue: 15, products: ['Book'] }
// }
```---


## 🔗 The Magic of Chaining Methods

### Method Chaining Fundamentals

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
const eurToUsd = 1.1;

// Without chaining (step by step)
const deposits = movements.filter(mov => mov > 0);
const depositsUSD = deposits.map(mov => mov * eurToUsd);
const totalDepositsUSD = depositsUSD.reduce((acc, mov) => acc + mov, 0);

console.log('Step by step result:', totalDepositsUSD);
// Output: Step by step result: 5522

// ✅ With method chaining (functional pipeline)
const totalDepositsUSDChained = movements
    .filter(mov => mov > 0)                    // Keep only deposits
    .map(mov => mov * eurToUsd)                // Convert to USD
    .reduce((acc, mov) => acc + mov, 0);       // Sum them up

console.log('Chained result:', totalDepositsUSDChained);
// Output: Chained result: 5522

// Debugging chained methods
const totalDepositsUSDDebug = movements
    .filter(mov => {
        console.log('Filtering:', mov, mov > 0 ? '✅' : '❌');
        return mov > 0;
    })
    .map((mov, i, arr) => {
        console.log('Converting to USD:', mov, '→', mov * eurToUsd);
        console.log('Current array:', arr); // Shows filtered array
        return mov * eurToUsd;
    })
    .reduce((acc, mov, i, arr) => {
        console.log(`Reducing step ${i + 1}: ${acc} + ${mov} = ${acc + mov}`);
        return acc + mov;
    }, 0);

console.log('Final result:', totalDepositsUSDDebug);
```

### Real-World Chaining Examples

```javascript
// E-commerce order processing pipeline
const orders = [
    { id: 1, items: [{ price: 25, quantity: 2 }, { price: 15, quantity: 1 }], status: 'completed' },
    { id: 2, items: [{ price: 100, quantity: 1 }], status: 'pending' },
    { id: 3, items: [{ price: 50, quantity: 3 }, { price: 20, quantity: 2 }], status: 'completed' },
    { id: 4, items: [{ price: 75, quantity: 1 }], status: 'cancelled' }
];

// Calculate total revenue from completed orders
const totalRevenue = orders
    .filter(order => order.status === 'completed')
    .map(order => order.items.reduce((sum, item) => sum + (item.price * item.quantity), 0))
    .reduce((total, orderValue) => total + orderValue, 0);

console.log('Total revenue from completed orders:', totalRevenue);
// Output: Total revenue from completed orders: 255

// User data processing pipeline
const users = [
    { name: 'alice johnson', email: 'ALICE@EXAMPLE.COM', age: 25, posts: 15 },
    { name: 'bob smith', email: 'bob@example.com', age: 17, posts: 8 },
    { name: 'charlie brown', email: 'CHARLIE@EXAMPLE.COM', age: 30, posts: 25 },
    { name: 'diana prince', email: 'diana@example.com', age: 28, posts: 12 }
];

// Process users: normalize data, filter adults, create summaries
const processedUsers = users
    .filter(user => user.age >= 18)
    .map(user => ({
        id: user.name.replace(/\s+/g, '').toLowerCase(),
        displayName: user.name
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' '),
        email: user.email.toLowerCase(),
        age: user.age,
        posts: user.posts,
        isActive: user.posts > 10
    }))
    .sort((a, b) => b.posts - a.posts);

console.log('Processed users:', processedUsers);
// Output: Processed users: [
//   { id: 'charliebrown', displayName: 'Charlie Brown', email: 'charlie@example.com', age: 30, posts: 25, isActive: true },
//   { id: 'alicejohnson', displayName: 'Alice Johnson', email: 'alice@example.com', age: 25, posts: 15, isActive: true },
//   { id: 'dianaprince', displayName: 'Diana Prince', email: 'diana@example.com', age: 28, posts: 12, isActive: true }
// ]
```

### Chaining Best Practices

```javascript
// ✅ Good: Readable chaining with proper formatting
const result = data
    .filter(item => item.isValid)
    .map(item => item.value * 2)
    .reduce((sum, value) => sum + value, 0);

// ❌ Bad: Too long chain, hard to debug
const badResult = data.filter(x => x.a > 0).map(x => x.b * x.c).filter(x => x < 100).map(x => x / 2).reduce((a, b) => a + b, 0);

// ✅ Good: Break complex chains into steps
const validItems = data.filter(item => item.isValid && item.value > 0);
const processedItems = validItems.map(item => ({
    ...item,
    processedValue: item.value * item.multiplier
}));
const finalResult = processedItems.reduce((sum, item) => sum + item.processedValue, 0);

// ✅ Good: Use intermediate variables for debugging
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

const pipeline = movements
    .filter(mov => {
        const isDeposit = mov > 0;
        console.log(`${mov} is ${isDeposit ? 'deposit' : 'withdrawal'}`);
        return isDeposit;
    })
    .map(mov => {
        const usdAmount = mov * 1.1;
        console.log(`${mov} EUR = ${usdAmount} USD`);
        return usdAmount;
    })
    .reduce((acc, mov) => {
        console.log(`Adding ${mov} to ${acc}`);
        return acc + mov;
    }, 0);

console.log('Pipeline result:', pipeline);
```

---

## 🔍 The find() Method

### Finding Single Elements

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Find first withdrawal (negative movement)
const firstWithdrawal = movements.find(mov => mov < 0);
console.log('First withdrawal:', firstWithdrawal);
// Output: First withdrawal: -400

// Find first large deposit
const largeDeposit = movements.find(mov => mov > 1000);
console.log('First large deposit:', largeDeposit);
// Output: First large deposit: 3000

// Find returns undefined if nothing found
const hugeWithdrawal = movements.find(mov => mov < -1000);
console.log('Huge withdrawal:', hugeWithdrawal);
// Output: Huge withdrawal: undefined

// Real-world example: Find user by property
const accounts = [
    { owner: 'Jonas Schmedtmann', username: 'js', pin: 1111, movements: [200, 450, -400, 3000, -650, -130, 70, 1300] },
    { owner: 'Jessica Davis', username: 'jd', pin: 2222, movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30] },
    { owner: 'Steven Thomas Williams', username: 'stw', pin: 3333, movements: [200, -200, 340, -300, -20, 50, 400, -460] },
    { owner: 'Sarah Smith', username: 'ss', pin: 4444, movements: [430, 1000, 700, 50, 90] }
];

// Find account by owner name
const jessicaAccount = accounts.find(acc => acc.owner === 'Jessica Davis');
console.log('Jessica\'s account:', jessicaAccount);
// Output: Jessica's account: { owner: 'Jessica Davis', username: 'jd', pin: 2222, movements: [...] }

// Find account by username
const account = accounts.find(acc => acc.username === 'stw');
console.log('STW account:', account);

// Traditional approach with for loop (for comparison)
let accountFor;
for (const acc of accounts) {
    if (acc.owner === 'Jessica Davis') {
        accountFor = acc;
        break;
    }
}
console.log('Found with for loop:', accountFor);

// Complex find with multiple conditions
const users = [
    { id: 1, name: 'Alice', age: 25, active: true, role: 'admin' },
    { id: 2, name: 'Bob', age: 30, active: false, role: 'user' },
    { id: 3, name: 'Charlie', age: 35, active: true, role: 'moderator' },
    { id: 4, name: 'Diana', age: 28, active: true, role: 'user' }
];

// Find first active admin
const activeAdmin = users.find(user => user.active && user.role === 'admin');
console.log('Active admin:', activeAdmin);
// Output: Active admin: { id: 1, name: 'Alice', age: 25, active: true, role: 'admin' }

// Find user by complex criteria
const eligibleModerator = users.find(user => {
    return user.age >= 30 && 
           user.active && 
           (user.role === 'moderator' || user.role === 'admin');
});
console.log('Eligible moderator:', eligibleModerator);
// Output: Eligible moderator: { id: 3, name: 'Charlie', age: 35, active: true, role: 'moderator' }
```

### The findIndex() Method

```javascript
// findIndex returns the index instead of the element
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

const firstWithdrawalIndex = movements.findIndex(mov => mov < 0);
console.log('First withdrawal index:', firstWithdrawalIndex);
// Output: First withdrawal index: 2

// Compare with indexOf (only works with exact values)
const indexOfExact = movements.indexOf(-400);
console.log('Index of -400:', indexOfExact);
// Output: Index of -400: 2

// findIndex is more flexible (works with conditions)
const largeDepositIndex = movements.findIndex(mov => mov > 1000);
console.log('Large deposit index:', largeDepositIndex);
// Output: Large deposit index: 3

// Real-world example: Remove account
const accounts = [
    { owner: 'Jonas Schmedtmann', username: 'js', pin: 1111 },
    { owner: 'Jessica Davis', username: 'jd', pin: 2222 },
    { owner: 'Steven Thomas Williams', username: 'stw', pin: 3333 },
    { owner: 'Sarah Smith', username: 'ss', pin: 4444 }
];

// Find and remove account
function closeAccount(username, pin) {
    const accountIndex = accounts.findIndex(acc => 
        acc.username === username && acc.pin === pin
    );
    
    if (accountIndex !== -1) {
        const removedAccount = accounts.splice(accountIndex, 1)[0];
        console.log('Account closed:', removedAccount.owner);
        return true;
    } else {
        console.log('Account not found or invalid credentials');
        return false;
    }
}

console.log('Accounts before:', accounts.length);
closeAccount('jd', 2222);
console.log('Accounts after:', accounts.length);
// Output: Accounts before: 4
//         Account closed: Jessica Davis
//         Accounts after: 3

// Find index with complex conditions
const products = [
    { id: 1, name: 'Laptop', price: 999, inStock: true },
    { id: 2, name: 'Phone', price: 599, inStock: false },
    { id: 3, name: 'Tablet', price: 399, inStock: true },
    { id: 4, name: 'Watch', price: 299, inStock: false }
];

const expensiveInStockIndex = products.findIndex(product => 
    product.price > 500 && product.inStock
);
console.log('Expensive in-stock product index:', expensiveInStockIndex);
// Output: Expensive in-stock product index: 0
```

---

## ✅ Testing Arrays: some() and every()

### The some() Method

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Check if array includes exact value
console.log('Includes -130:', movements.includes(-130));
// Output: Includes -130: true

// Check if any movement satisfies condition
console.log('Any positive movements:', movements.some(mov => mov > 0));
// Output: Any positive movements: true

console.log('Any movements > 5000:', movements.some(mov => mov > 5000));
// Output: Any movements > 5000: false

console.log('Any large deposits:', movements.some(mov => mov > 1500));
// Output: Any large deposits: true

// Real-world example: Loan approval
function checkLoanEligibility(movements, loanAmount) {
    // Bank rule: any deposit should be at least 10% of loan amount
    const hasLargeEnoughDeposit = movements.some(mov => 
        mov >= loanAmount * 0.1
    );
    
    return hasLargeEnoughDeposit;
}

const loanAmount = 1000;
const isEligible = checkLoanEligibility(movements, loanAmount);
console.log(`Eligible for ${loanAmount} loan:`, isEligible);
// Output: Eligible for 1000 loan: true

// Complex conditions with some()
const users = [
    { name: 'Alice', age: 17, hasLicense: false },
    { name: 'Bob', age: 25, hasLicense: true },
    { name: 'Charlie', age: 16, hasLicense: false },
    { name: 'Diana', age: 30, hasLicense: true }
];

// Check if any user can drive (age >= 18 AND has license)
const anyoneCanDrive = users.some(user => 
    user.age >= 18 && user.hasLicense
);
console.log('Anyone can drive:', anyoneCanDrive);
// Output: Anyone can drive: true

// Check if any minor has license (shouldn't happen)
const minorWithLicense = users.some(user => 
    user.age < 18 && user.hasLicense
);
console.log('Minor with license:', minorWithLicense);
// Output: Minor with license: false
```

### The every() Method

```javascript
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

// Check if ALL movements are positive
console.log('All movements positive:', movements.every(mov => mov > 0));
// Output: All movements positive: false

// Check if ALL movements are numbers
console.log('All movements are numbers:', movements.every(mov => typeof mov === 'number'));
// Output: All movements are numbers: true

// Account with only deposits
const account4Movements = [430, 1000, 700, 50, 90];
console.log('All deposits in account4:', account4Movements.every(mov => mov > 0));
// Output: All deposits in account4: true

// Real-world example: Form validation
const formData = {
    name: 'John Doe',
    email: 'john@example.com',
    age: 25,
    terms: true
};

const requiredFields = ['name', 'email', 'age', 'terms'];

// Check if all required fields are present and valid
const isFormValid = requiredFields.every(field => {
    const value = formData[field];
    
    if (field === 'email') {
        return value && value.includes('@');
    }
    if (field === 'age') {
        return value && value >= 18;
    }
    if (field === 'terms') {
        return value === true;
    }
    
    return value && value.toString().trim().length > 0;
});

console.log('Form is valid:', isFormValid);
// Output: Form is valid: true

// Separate callback for reusability
const isPositive = mov => mov > 0;
const isNegative = mov => mov < 0;

console.log('Some positive:', movements.some(isPositive));
// Output: Some positive: true

console.log('Every positive:', movements.every(isPositive));
// Output: Every positive: false

console.log('Some negative:', movements.some(isNegative));
// Output: Some negative: true

console.log('Filter positive:', movements.filter(isPositive));
// Output: Filter positive: [200, 450, 3000, 70, 1300]

// Complex validation example
const products = [
    { name: 'Laptop', price: 999, category: 'Electronics', inStock: true },
    { name: 'Phone', price: 599, category: 'Electronics', inStock: true },
    { name: 'Shirt', price: 29, category: 'Clothing', inStock: true }
];

// Check if all products meet quality standards
const allProductsValid = products.every(product => {
    const hasName = product.name && product.name.length > 0;
    const hasValidPrice = product.price && product.price > 0;
    const hasCategory = product.category && product.category.length > 0;
    const isInStock = product.inStock === true;
    
    return hasName && hasValidPrice && hasCategory && isInStock;
});

console.log('All products valid:', allProductsValid);
// Output: All products valid: true

// Check if all products are expensive (> 500)
const allExpensive = products.every(product => product.price > 500);
console.log('All products expensive:', allExpensive);
// Output: All products expensive: false
```

---

## 🎯 Coding Challenge Solutions

### Challenge #1: Dog Age Checker

```javascript
// Challenge: Check if dogs are adults or puppies
// Adult: >= 3 years, Puppy: < 3 years

const checkDogs = function(dogsJulia, dogsKate) {
    // 1. Remove cat ages from Julia's data (first and last two)
    const dogsJuliaCorrected = dogsJulia.slice(1, -2);
    console.log('Julia corrected:', dogsJuliaCorrected);
    
    // 2. Combine both datasets
    const allDogs = dogsJuliaCorrected.concat(dogsKate);
    // Alternative: const allDogs = [...dogsJuliaCorrected, ...dogsKate];
    
    console.log('All dogs:', allDogs);
    
    // 3. Check each dog and log result
    allDogs.forEach(function(age, i) {
        const dogNumber = i + 1;
        const type = age >= 3 ? 'adult' : 'puppy 🐶';
        
        console.log(`Dog number ${dogNumber} is an ${type}, and is ${age} years old`);
    });
};

// Test data
console.log('=== Test Data 1 ===');
checkDogs([3, 5, 2, 12, 7], [4, 1, 15, 8, 3]);

console.log('\n=== Test Data 2 ===');
checkDogs([9, 16, 6, 8, 3], [10, 5, 6, 1, 4]);

// Output for Test Data 1:
// Julia corrected: [5, 2, 12]
// All dogs: [5, 2, 12, 4, 1, 15, 8, 3]
// Dog number 1 is an adult, and is 5 years old
// Dog number 2 is an puppy 🐶, and is 2 years old
// Dog number 3 is an adult, and is 12 years old
// Dog number 4 is an adult, and is 4 years old
// Dog number 5 is an puppy 🐶, and is 1 years old
// Dog number 6 is an adult, and is 15 years old
// Dog number 7 is an adult, and is 8 years old
// Dog number 8 is an adult, and is 3 years old
```

### Challenge #2: Calculate Average Human Age

```javascript
// Challenge: Convert dog ages to human ages and calculate average
// Formula: <= 2 years: humanAge = 2 * dogAge
//          > 2 years: humanAge = 16 + dogAge * 4

const calcAverageHumanAge = function(ages) {
    console.log('Dog ages:', ages);
    
    // 1. Calculate human ages
    const humanAges = ages.map(age => 
        age <= 2 ? 2 * age : 16 + age * 4
    );
    console.log('Human ages:', humanAges);
    
    // 2. Filter adults (>= 18 human years)
    const adults = humanAges.filter(age => age >= 18);
    console.log('Adult dogs (human years):', adults);
    
    // 3. Calculate average
    const average = adults.reduce((acc, age) => acc + age, 0) / adults.length;
    
    // Alternative calculation (more elegant):
    // const average = adults.reduce((acc, age, i, arr) => acc + age / arr.length, 0);
    
    console.log('Average human age of adult dogs:', average);
    return average;
};

// Test data
console.log('=== Test Data 1 ===');
const avg1 = calcAverageHumanAge([5, 2, 4, 1, 15, 8, 3]);

console.log('\n=== Test Data 2 ===');
const avg2 = calcAverageHumanAge([16, 6, 10, 5, 6, 1, 4]);

console.log(`\nFinal averages: ${avg1.toFixed(1)}, ${avg2.toFixed(1)}`);

// Output for Test Data 1:
// Dog ages: [5, 2, 4, 1, 15, 8, 3]
// Human ages: [36, 4, 32, 2, 76, 48, 28]
// Adult dogs (human years): [36, 32, 76, 48, 28]
// Average human age of adult dogs: 44
```

### Challenge #3: Chained Version

```javascript
// Challenge: Rewrite calcAverageHumanAge using chaining

const calcAverageHumanAgeChained = ages =>
    ages
        .map(age => age <= 2 ? 2 * age : 16 + age * 4)
        .filter(age => age >= 18)
        .reduce((acc, age, i, arr) => acc + age / arr.length, 0);

// Test with same data
const avg1Chained = calcAverageHumanAgeChained([5, 2, 4, 1, 15, 8, 3]);
const avg2Chained = calcAverageHumanAgeChained([16, 6, 10, 5, 6, 1, 4]);

console.log('Chained results:', avg1Chained.toFixed(1), avg2Chained.toFixed(1));
// Output: Chained results: 44.0 47.3

// Step-by-step breakdown for understanding
const calcAverageHumanAgeExplained = function(ages) {
    console.log('Original ages:', ages);
    
    const pipeline = ages
        .map(age => {
            const humanAge = age <= 2 ? 2 * age : 16 + age * 4;
            console.log(`Dog age ${age} → Human age ${humanAge}`);
            return humanAge;
        })
        .filter(age => {
            const isAdult = age >= 18;
            console.log(`Human age ${age} is ${isAdult ? 'adult' : 'child'}`);
            return isAdult;
        })
        .reduce((acc, age, i, arr) => {
            const contribution = age / arr.length;
            console.log(`Adding ${age} (${contribution.toFixed(2)}) to average`);
            return acc + contribution;
        }, 0);
    
    return pipeline;
};

console.log('\n=== Explained Version ===');
const explainedResult = calcAverageHumanAgeExplained([5, 2, 4, 1, 15, 8, 3]);
console.log('Final average:', explainedResult.toFixed(1));
```---


## 📊 Flattening Arrays: flat() and flatMap()

### The flat() Method

```javascript
// Basic array flattening
const nestedArray = [[1, 2, 3], [4, 5, 6], 7, 8];
console.log('Original nested array:', nestedArray);
// Output: Original nested array: [[1, 2, 3], [4, 5, 6], 7, 8]

const flattened = nestedArray.flat();
console.log('Flattened array:', flattened);
// Output: Flattened array: [1, 2, 3, 4, 5, 6, 7, 8]

// Deep nesting requires depth parameter
const deeplyNested = [[[1, 2], 3], [4, [5, 6]], 7, 8];
console.log('Deeply nested:', deeplyNested);

console.log('Flat depth 1:', deeplyNested.flat());
// Output: Flat depth 1: [[1, 2], 3, 4, [5, 6], 7, 8]

console.log('Flat depth 2:', deeplyNested.flat(2));
// Output: Flat depth 2: [1, 2, 3, 4, 5, 6, 7, 8]

// Real-world example: Flatten account movements
const accounts = [
    { owner: 'Jonas', movements: [200, 450, -400, 3000] },
    { owner: 'Jessica', movements: [5000, 3400, -150, -790] },
    { owner: 'Steven', movements: [200, -200, 340, -300] },
    { owner: 'Sarah', movements: [430, 1000, 700, 50] }
];

// Get all movements from all accounts
const allMovements = accounts
    .map(acc => acc.movements)
    .flat();

console.log('All movements:', allMovements);
// Output: All movements: [200, 450, -400, 3000, 5000, 3400, -150, -790, 200, -200, 340, -300, 430, 1000, 700, 50]

// Calculate overall balance
const overallBalance = allMovements.reduce((acc, mov) => acc + mov, 0);
console.log('Overall balance:', overallBalance);
// Output: Overall balance: 17340
```

### The flatMap() Method

```javascript
// flatMap() combines map() and flat() in one step
const accounts = [
    { owner: 'Jonas', movements: [200, 450, -400, 3000] },
    { owner: 'Jessica', movements: [5000, 3400, -150, -790] },
    { owner: 'Steven', movements: [200, -200, 340, -300] },
    { owner: 'Sarah', movements: [430, 1000, 700, 50] }
];

// Using map() + flat()
const allMovements1 = accounts
    .map(acc => acc.movements)
    .flat();

// ✅ Using flatMap() (more efficient)
const allMovements2 = accounts
    .flatMap(acc => acc.movements);

console.log('Map + flat:', allMovements1);
console.log('FlatMap:', allMovements2);
console.log('Results equal:', JSON.stringify(allMovements1) === JSON.stringify(allMovements2));
// Output: Results equal: true

// Calculate overall balance with flatMap
const overallBalance2 = accounts
    .flatMap(acc => acc.movements)
    .reduce((acc, mov) => acc + mov, 0);

console.log('Overall balance (flatMap):', overallBalance2);
// Output: Overall balance (flatMap): 17340

// ⚠️ flatMap only goes one level deep
const deepArray = [[[1, 2]], [[3, 4]]];
console.log('Deep array flatMap:', deepArray.flatMap(x => x));
// Output: Deep array flatMap: [[1, 2], [3, 4]] (still nested!)

// For deeper nesting, use map + flat with depth
console.log('Deep array map + flat:', deepArray.map(x => x).flat(2));
// Output: Deep array map + flat: [1, 2, 3, 4]

// Real-world example: Process user tags
const users = [
    { name: 'Alice', tags: ['developer', 'javascript', 'react'] },
    { name: 'Bob', tags: ['designer', 'ui', 'ux'] },
    { name: 'Charlie', tags: ['manager', 'agile', 'scrum'] }
];

// Get all unique tags
const allTags = users
    .flatMap(user => user.tags)
    .filter((tag, index, array) => array.indexOf(tag) === index)
    .sort();

console.log('All unique tags:', allTags);
// Output: All unique tags: ['agile', 'designer', 'developer', 'javascript', 'manager', 'react', 'scrum', 'ui', 'ux']

// Count tag frequency
const tagFrequency = users
    .flatMap(user => user.tags)
    .reduce((acc, tag) => {
        acc[tag] = (acc[tag] || 0) + 1;
        return acc;
    }, {});

console.log('Tag frequency:', tagFrequency);
// Output: Tag frequency: { developer: 1, javascript: 1, react: 1, designer: 1, ui: 1, ux: 1, manager: 1, agile: 1, scrum: 1 }
```

---

## 🔤 Sorting Arrays

### Basic Sorting

```javascript
// Sorting strings (works by default)
const owners = ['Jonas', 'Zach', 'Adam', 'Martha'];
console.log('Original owners:', owners);
// Output: Original owners: ['Jonas', 'Zach', 'Adam', 'Martha']

console.log('Sorted owners:', owners.sort());
// Output: Sorted owners: ['Adam', 'Jonas', 'Martha', 'Zach']

console.log('Owners after sort:', owners);
// Output: Owners after sort: ['Adam', 'Jonas', 'Martha', 'Zach']
// ⚠️ sort() mutates the original array!

// Sorting numbers (requires compare function)
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
console.log('Original movements:', movements);

// ❌ Wrong: Default sort converts to strings
console.log('Default sort (wrong):', movements.sort());
// Output: Default sort (wrong): [-130, -400, -650, 1300, 200, 3000, 450, 70]
// This is wrong because it sorts as strings: "-130" comes before "200"

// ✅ Correct: Ascending order
movements.sort((a, b) => {
    if (a > b) return 1;   // a should come after b
    if (a < b) return -1;  // a should come before b
    return 0;              // a and b are equal
});
console.log('Ascending sort:', movements);
// Output: Ascending sort: [-650, -400, -130, 70, 200, 450, 1300, 3000]

// ✅ Simplified ascending sort
const movements2 = [200, 450, -400, 3000, -650, -130, 70, 1300];
movements2.sort((a, b) => a - b);
console.log('Ascending (simplified):', movements2);
// Output: Ascending (simplified): [-650, -400, -130, 70, 200, 450, 1300, 3000]

// ✅ Descending order
const movements3 = [200, 450, -400, 3000, -650, -130, 70, 1300];
movements3.sort((a, b) => b - a);
console.log('Descending sort:', movements3);
// Output: Descending sort: [3000, 1300, 450, 200, 70, -130, -400, -650]
```

### Advanced Sorting

```javascript
// Sorting objects by property
const users = [
    { name: 'Alice', age: 25, salary: 50000 },
    { name: 'Bob', age: 30, salary: 60000 },
    { name: 'Charlie', age: 22, salary: 45000 },
    { name: 'Diana', age: 28, salary: 55000 }
];

// Sort by age (ascending)
const usersByAge = [...users].sort((a, b) => a.age - b.age);
console.log('Users by age:', usersByAge.map(u => `${u.name} (${u.age})`));
// Output: Users by age: ['Charlie (22)', 'Alice (25)', 'Diana (28)', 'Bob (30)']

// Sort by salary (descending)
const usersBySalary = [...users].sort((a, b) => b.salary - a.salary);
console.log('Users by salary:', usersBySalary.map(u => `${u.name} ($${u.salary})`));
// Output: Users by salary: ['Bob ($60000)', 'Diana ($55000)', 'Alice ($50000)', 'Charlie ($45000)']

// Sort by name (alphabetical)
const usersByName = [...users].sort((a, b) => a.name.localeCompare(b.name));
console.log('Users by name:', usersByName.map(u => u.name));
// Output: Users by name: ['Alice', 'Bob', 'Charlie', 'Diana']

// Multi-level sorting (age first, then salary)
const usersMultiSort = [...users].sort((a, b) => {
    if (a.age !== b.age) {
        return a.age - b.age; // Sort by age first
    }
    return b.salary - a.salary; // If ages are equal, sort by salary (desc)
});

console.log('Multi-sort (age, then salary):', 
    usersMultiSort.map(u => `${u.name}: ${u.age}y, $${u.salary}`)
);

// Sorting with custom logic
const products = [
    { name: 'Laptop', price: 999, category: 'Electronics', inStock: true },
    { name: 'Phone', price: 599, category: 'Electronics', inStock: false },
    { name: 'Shirt', price: 29, category: 'Clothing', inStock: true },
    { name: 'Jeans', price: 79, category: 'Clothing', inStock: false }
];

// Sort by availability first, then by price
const productsSorted = [...products].sort((a, b) => {
    // In-stock items first
    if (a.inStock !== b.inStock) {
        return b.inStock - a.inStock; // true (1) - false (0) = 1, false - true = -1
    }
    // Then by price (ascending)
    return a.price - b.price;
});

console.log('Products sorted:', 
    productsSorted.map(p => `${p.name}: $${p.price} ${p.inStock ? '✅' : '❌'}`)
);
// Output: Products sorted: ['Shirt: $29 ✅', 'Laptop: $999 ✅', 'Jeans: $79 ❌', 'Phone: $599 ❌']

// Random shuffle (Fisher-Yates algorithm)
function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log('Original:', numbers);
console.log('Shuffled:', shuffleArray(numbers));
console.log('Shuffled again:', shuffleArray(numbers));
```

---

## 🏗️ Creating and Filling Arrays

### Different Ways to Create Arrays

```javascript
// 1. Array literal (most common)
const arr1 = [1, 2, 3, 4, 5, 6, 7];
console.log('Array literal:', arr1);

// 2. Array constructor with elements
const arr2 = new Array(1, 2, 3, 4, 5, 6, 7);
console.log('Array constructor:', arr2);

// 3. Array constructor with length (creates empty slots)
const arr3 = new Array(7);
console.log('Empty array:', arr3);
console.log('Length:', arr3.length);
// Output: Empty array: [empty × 7]
//         Length: 7

// ⚠️ Empty arrays have limitations
// console.log(arr3.map(() => 5)); // Doesn't work with empty slots!

// 4. Fill method to populate empty array
const arr4 = new Array(7);
arr4.fill(1);
console.log('Filled with 1:', arr4);
// Output: Filled with 1: [1, 1, 1, 1, 1, 1, 1]

// Fill with start and end positions
const arr5 = new Array(7);
arr5.fill(1, 3, 5); // fill(value, start, end)
console.log('Partial fill:', arr5);
// Output: Partial fill: [empty, empty, empty, 1, 1, empty, empty]

// Fill existing array
const arr6 = [1, 2, 3, 4, 5, 6, 7];
arr6.fill(23, 2, 6);
console.log('Fill existing:', arr6);
// Output: Fill existing: [1, 2, 23, 23, 23, 23, 7]

// 5. Array.from() - most flexible
const arr7 = Array.from({ length: 7 }, () => 1);
console.log('Array.from with callback:', arr7);
// Output: Array.from with callback: [1, 1, 1, 1, 1, 1, 1]

// Array.from with index
const arr8 = Array.from({ length: 7 }, (_, i) => i + 1);
console.log('Array.from with index:', arr8);
// Output: Array.from with index: [1, 2, 3, 4, 5, 6, 7]

// More complex Array.from examples
const arr9 = Array.from({ length: 10 }, (_, i) => i * 2);
console.log('Even numbers:', arr9);
// Output: Even numbers: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

const arr10 = Array.from({ length: 5 }, () => Math.floor(Math.random() * 6) + 1);
console.log('Random dice rolls:', arr10);
// Output: Random dice rolls: [3, 1, 6, 2, 4] (random)
```

### Real-World Array Creation

```javascript
// Create range of numbers
function range(start, end, step = 1) {
    const length = Math.floor((end - start) / step) + 1;
    return Array.from({ length }, (_, i) => start + i * step);
}

console.log('Range 1-10:', range(1, 10));
// Output: Range 1-10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

console.log('Range 0-20 step 2:', range(0, 20, 2));
// Output: Range 0-20 step 2: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

// Create alphabet array
const alphabet = Array.from({ length: 26 }, (_, i) => 
    String.fromCharCode(65 + i)
);
console.log('Alphabet:', alphabet);
// Output: Alphabet: ['A', 'B', 'C', ..., 'Z']

// Convert NodeList to Array (DOM manipulation)
// Simulating DOM elements
const mockElements = [
    { textContent: '€100', className: 'movements__value' },
    { textContent: '€250', className: 'movements__value' },
    { textContent: '€-50', className: 'movements__value' }
];

// Convert and process (simulating document.querySelectorAll)
const movementsUI = Array.from(
    mockElements,
    el => Number(el.textContent.replace('€', ''))
);
console.log('Movements from UI:', movementsUI);
// Output: Movements from UI: [100, 250, -50]

// Alternative with spread operator
const movementsUI2 = [...mockElements].map(el => 
    Number(el.textContent.replace('€', ''))
);
console.log('Movements with spread:', movementsUI2);

// Create 2D array (matrix)
function createMatrix(rows, cols, fillValue = 0) {
    return Array.from({ length: rows }, () => 
        Array.from({ length: cols }, () => fillValue)
    );
}

const matrix = createMatrix(3, 4, 0);
console.log('3x4 matrix:', matrix);
// Output: 3x4 matrix: [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

// Create multiplication table
function multiplicationTable(size) {
    return Array.from({ length: size }, (_, i) =>
        Array.from({ length: size }, (_, j) => (i + 1) * (j + 1))
    );
}

const table = multiplicationTable(5);
console.log('5x5 multiplication table:');
table.forEach((row, i) => {
    console.log(`Row ${i + 1}:`, row);
});
// Output: 5x5 multiplication table:
//         Row 1: [1, 2, 3, 4, 5]
//         Row 2: [2, 4, 6, 8, 10]
//         Row 3: [3, 6, 9, 12, 15]
//         Row 4: [4, 8, 12, 16, 20]
//         Row 5: [5, 10, 15, 20, 25]
```

---

## 📋 Array Methods Summary & Decision Guide

### When to Use Which Method

```
🎯 Array Method Selection Guide:
┌─────────────────────────────────────────────────────────────┐
│ TO MUTATE ORIGINAL ARRAY:                                   │
│ • push/unshift    → Add elements                            │
│ • pop/shift       → Remove elements                         │
│ • splice          → Add/remove at any position              │
│ • reverse/sort    → Reorder elements                        │
│ • fill            → Replace all/some elements               │
│                                                             │
│ TO CREATE NEW ARRAY:                                        │
│ • map             → Transform all elements                  │
│ • filter          → Select elements by condition            │
│ • slice           → Extract portion                         │
│ • concat/spread   → Combine arrays                          │
│ • flat/flatMap    → Flatten nested arrays                  │
│                                                             │
│ TO GET ARRAY INDEX:                                         │
│ • indexOf         → Find by value                           │
│ • findIndex       → Find by condition                       │
│                                                             │
│ TO GET ARRAY ELEMENT:                                       │
│ • find            → First element by condition              │
│ • at              → Element at index (supports negative)    │
│                                                             │
│ TO TEST ARRAY:                                              │
│ • includes        → Test for value                          │
│ • some            → Test if any match condition             │
│ • every           → Test if all match condition             │
│                                                             │
│ TO TRANSFORM TO VALUE:                                      │
│ • reduce          → Accumulate to single value              │
│ • join            → Create string                           │
│                                                             │
│ TO LOOP ARRAY:                                              │
│ • forEach         → Execute function for each element       │
│ • for-of          → Loop with ability to break              │
└─────────────────────────────────────────────────────────────┘
```

### Method Chaining Decision Tree

```javascript
// Decision tree for method chaining
const data = [
    { name: 'Alice', age: 25, salary: 50000, department: 'Engineering' },
    { name: 'Bob', age: 30, salary: 60000, department: 'Marketing' },
    { name: 'Charlie', age: 22, salary: 45000, department: 'Engineering' },
    { name: 'Diana', age: 28, salary: 55000, department: 'Marketing' },
    { name: 'Eve', age: 35, salary: 70000, department: 'Engineering' }
];

// Question: "What's the average salary of engineers over 25?"
const avgEngineerSalary = data
    .filter(person => person.department === 'Engineering')  // Select engineers
    .filter(person => person.age > 25)                     // Over 25
    .map(person => person.salary)                          // Extract salaries
    .reduce((sum, salary, _, arr) => sum + salary / arr.length, 0); // Average

console.log('Average engineer salary (>25):', avgEngineerSalary);
// Output: Average engineer salary (>25): 60000

// Question: "Get names of all employees, sorted by salary"
const namesBySalary = data
    .sort((a, b) => b.salary - a.salary)                   // Sort by salary (desc)
    .map(person => person.name);                           // Extract names

console.log('Names by salary:', namesBySalary);
// Output: Names by salary: ['Eve', 'Bob', 'Diana', 'Alice', 'Charlie']

// Question: "Do all marketing employees earn more than 50k?"
const allMarketingWellPaid = data
    .filter(person => person.department === 'Marketing')    // Select marketing
    .every(person => person.salary > 50000);              // Test condition

console.log('All marketing > 50k:', allMarketingWellPaid);
// Output: All marketing > 50k: true

// Question: "Find the youngest employee in each department"
const youngestByDept = data
    .reduce((acc, person) => {
        const dept = person.department;
        if (!acc[dept] || person.age < acc[dept].age) {
            acc[dept] = person;
        }
        return acc;
    }, {});

console.log('Youngest by department:', youngestByDept);
// Output: Youngest by department: {
//   Engineering: { name: 'Charlie', age: 22, salary: 45000, department: 'Engineering' },
//   Marketing: { name: 'Diana', age: 28, salary: 55000, department: 'Marketing' }
// }
```

---

## 🎯 Key Takeaways & Best Practices

### Performance Considerations

```javascript
// ✅ Performance best practices

// 1. Use appropriate method for the task
const numbers = [1, 2, 3, 4, 5];

// ❌ Inefficient: Using reduce for simple sum
const sum1 = numbers.reduce((acc, num) => acc + num, 0);

// ✅ More efficient: Simple loop for basic operations
let sum2 = 0;
for (const num of numbers) sum2 += num;

// 2. Avoid unnecessary array creation
// ❌ Creates intermediate arrays
const result1 = data
    .map(item => item.value)
    .filter(value => value > 0)
    .map(value => value * 2);

// ✅ Combine operations when possible
const result2 = data.reduce((acc, item) => {
    if (item.value > 0) {
        acc.push(item.value * 2);
    }
    return acc;
}, []);

// 3. Use for-of when you need to break
// ❌ forEach can't break
let found1;
numbers.forEach(num => {
    if (num > 3) {
        found1 = num;
        // return; // Only exits current iteration
    }
});

// ✅ for-of can break
let found2;
for (const num of numbers) {
    if (num > 3) {
        found2 = num;
        break; // Exits entire loop
    }
}

// 4. Cache array length in performance-critical loops
const largeArray = new Array(1000000).fill(0);

// ❌ Recalculates length each iteration
for (let i = 0; i < largeArray.length; i++) {
    // Process item
}

// ✅ Cache length
const length = largeArray.length;
for (let i = 0; i < length; i++) {
    // Process item
}
```

### Functional Programming Patterns

```javascript
// ✅ Functional programming best practices

// 1. Pure functions (no side effects)
// ❌ Impure: modifies external state
let total = 0;
function addToTotal(num) {
    total += num; // Side effect
    return total;
}

// ✅ Pure: returns new value
function add(a, b) {
    return a + b; // No side effects
}

// 2. Immutability
const originalArray = [1, 2, 3];

// ❌ Mutates original
originalArray.push(4);

// ✅ Creates new array
const newArray = [...originalArray, 4];

// 3. Function composition
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const transform = compose(square, double, addOne);
console.log(transform(3)); // ((3 + 1) * 2)² = 64

// 4. Currying for reusable functions
const filterBy = (predicate) => (array) => array.filter(predicate);
const mapWith = (transform) => (array) => array.map(transform);

const filterPositive = filterBy(x => x > 0);
const doubleValues = mapWith(x => x * 2);

const pipeline = compose(doubleValues, filterPositive);
console.log(pipeline([-2, -1, 0, 1, 2, 3])); // [2, 4, 6]
```

---

## 🏆 Mastery Checklist

```
🎯 Array Methods Mastery:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Master all basic array methods (push, pop, slice, etc.) │
│ ✅ Transform data with map, filter, and reduce effectively  │
│ ✅ Chain methods for elegant data processing pipelines     │
│ ✅ Search and test arrays with find, some, and every       │
│ ✅ Sort and flatten arrays for complex data structures     │
│ ✅ Create arrays programmatically with various techniques  │
│ ✅ Choose the right method for each specific use case      │
│ ✅ Apply functional programming principles                  │
└─────────────────────────────────────────────────────────────┘
```

**Remember:** Arrays are the backbone of data manipulation in JavaScript. Mastering these methods allows you to write more expressive, functional, and maintainable code. The key is knowing when to use each method and how to combine them effectively.

**Next Steps:**
1. Practice building data processing pipelines
2. Learn about advanced array patterns and algorithms
3. Explore performance optimization techniques
4. Study how popular libraries use these patterns
5. Build real applications that showcase array mastery

The power of JavaScript arrays lies not just in individual methods, but in how they can be combined to create elegant solutions to complex data problems!