# 🏗️ 13. Object-Oriented Programming (OOP) With JavaScript

> **Master Object-Oriented Programming in JavaScript** - From fundamental concepts to advanced patterns, learn how to build scalable, maintainable applications using OOP principles.

---

## 🎯 Learning Objectives

By the end of this comprehensive guide, you will master:

```
🚀 OOP Mastery Roadmap:
┌─────────────────────────────────────────────────────────────┐
│ • Core OOP Principles (Abstraction, Encapsulation, etc.)   │
│ • JavaScript's Prototypal Inheritance System               │
│ • Constructor Functions vs ES6 Classes                     │
│ • Advanced Inheritance Patterns                            │
│ • Private Fields and Methods                               │
│ • Design Patterns and Best Practices                       │
│ • Real-World Application Architecture                      │
└─────────────────────────────────────────────────────────────┘
```

### 📚 Prerequisites
- Solid understanding of JavaScript fundamentals
- Knowledge of functions, objects, and arrays
- Familiarity with `this` keyword and scope
- Basic understanding of prototypes

---

## 🤔 What is Object-Oriented Programming?

**Object-Oriented Programming (OOP)** is a programming paradigm that organizes code around **objects** rather than functions and logic. It's based on the concept of "objects" which contain data (properties) and code (methods).

### Why Use OOP?

```
🎯 Benefits of Object-Oriented Programming:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Code Reusability - Write once, use many times           │
│ ✅ Modularity - Break complex problems into smaller parts   │
│ ✅ Maintainability - Easier to update and debug            │
│ ✅ Scalability - Better structure for large applications    │
│ ✅ Real-world Modeling - Mirror real-world relationships   │
│ ✅ Team Collaboration - Clear structure for multiple devs  │
└─────────────────────────────────────────────────────────────┘
```

### Classes and Instances: The Foundation

In traditional OOP, a **class** is like a blueprint or template, while an **instance** is an actual object created from that blueprint.

```javascript
/**
 * UNDERSTANDING CLASSES AND INSTANCES
 * 
 * Think of a class as a cookie cutter and instances as the actual cookies.
 * The cookie cutter (class) defines the shape and properties,
 * but each cookie (instance) is a separate, individual object.
 */

// Example: Real-world analogy
console.log('=== Classes vs Instances Analogy ===');

/**
 * CLASS: Car Blueprint
 * - Defines what properties a car should have (make, model, year)
 * - Defines what actions a car can perform (start, stop, accelerate)
 * - This is NOT an actual car, just the blueprint
 */

/**
 * INSTANCES: Actual Cars
 * - myCar = new Car('Toyota', 'Camry', 2023)
 * - yourCar = new Car('Honda', 'Civic', 2022)
 * - Each instance has its own unique property values
 * - Each can perform the same actions but with different results
 */

// Let's demonstrate this concept with a simple example
function demonstrateClassVsInstance() {
    console.log('\n🏗️ Class vs Instance Demonstration:');
    
    // This is like our "blueprint" or "class" (we'll learn proper syntax later)
    function CarBlueprint(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.isRunning = false;
    }
    
    // Add methods to the blueprint
    CarBlueprint.prototype.start = function() {
        this.isRunning = true;
        console.log(`${this.make} ${this.model} is now running! 🚗`);
    };
    
    CarBlueprint.prototype.getInfo = function() {
        return `${this.year} ${this.make} ${this.model}`;
    };
    
    // Create instances (actual cars) from the blueprint
    const car1 = new CarBlueprint('Toyota', 'Camry', 2023);
    const car2 = new CarBlueprint('Honda', 'Civic', 2022);
    const car3 = new CarBlueprint('Ford', 'Mustang', 2024);
    
    console.log('📋 Created three car instances:');
    console.log(`Car 1: ${car1.getInfo()}`);
    console.log(`Car 2: ${car2.getInfo()}`);
    console.log(`Car 3: ${car3.getInfo()}`);
    
    // Each instance is independent
    car1.start(); // Only car1 starts
    console.log(`Car 1 running: ${car1.isRunning}`); // true
    console.log(`Car 2 running: ${car2.isRunning}`); // false
    
    // They share the same methods but have different data
    console.log('\n🔍 Instance Independence:');
    console.log(`Same blueprint? ${car1.constructor === car2.constructor}`); // true
    console.log(`Same instance? ${car1 === car2}`); // false
    console.log(`Same methods? ${car1.start === car2.start}`); // true (shared via prototype)
}

demonstrateClassVsInstance();
```

---

## 🏛️ The Four Pillars of OOP

Object-Oriented Programming is built on four fundamental principles. Let's explore each one with practical examples and understand **why** they matter.

### 1. 🎭 Abstraction

**Abstraction** means hiding complex implementation details and showing only the essential features of an object. It's like using a car - you don't need to understand how the engine works internally, you just need to know how to use the steering wheel, pedals, and gear shift.

```javascript
/**
 * ABSTRACTION: HIDING COMPLEXITY
 * 
 * Abstraction allows us to:
 * - Hide complex internal workings
 * - Provide simple interfaces for complex operations
 * - Focus on WHAT an object does, not HOW it does it
 * - Reduce cognitive load for developers using our code
 */

console.log('=== Abstraction Demonstration ===');

/**
 * Example: Email Service
 * Users don't need to know about SMTP protocols, server connections, etc.
 * They just want to send an email with a simple interface.
 */

class EmailService {
    constructor() {
        // These are internal implementation details (abstracted away)
        this._smtpServer = 'smtp.gmail.com';
        this._port = 587;
        this._connectionPool = [];
        this._authToken = null;
    }
    
    /**
     * PUBLIC INTERFACE (What users interact with)
     * Simple, clean methods that hide the complexity
     */
    
    sendEmail(to, subject, body) {
        console.log(`📧 Sending email to: ${to}`);
        console.log(`📋 Subject: ${subject}`);
        
        // Behind the scenes (abstracted complexity):
        this._authenticate();
        this._establishConnection();
        this._formatMessage(to, subject, body);
        this._transmitMessage();
        this._closeConnection();
        
        console.log('✅ Email sent successfully!');
    }
    
    /**
     * PRIVATE METHODS (Hidden implementation details)
     * Users don't need to know these exist or how they work
     */
    
    _authenticate() {
        // Complex authentication logic hidden from user
        console.log('  🔐 Authenticating with email server...');
        this._authToken = 'auth_token_12345';
    }
    
    _establishConnection() {
        // Complex network connection logic
        console.log('  🌐 Establishing SMTP connection...');
    }
    
    _formatMessage(to, subject, body) {
        // Complex message formatting according to email standards
        console.log('  📝 Formatting message according to RFC standards...');
    }
    
    _transmitMessage() {
        // Complex transmission protocol
        console.log('  📤 Transmitting message via SMTP...');
    }
    
    _closeConnection() {
        // Cleanup and connection management
        console.log('  🔌 Closing connection and cleaning up...');
    }
}

// Usage: Simple and clean interface
const emailService = new EmailService();

// Users only need to know this simple interface:
emailService.sendEmail(
    'user@example.com', 
    'Welcome!', 
    'Thank you for joining our service!'
);

console.log('\n💡 Abstraction Benefits:');
console.log('- Users have a simple interface: sendEmail()');
console.log('- Complex SMTP details are hidden');
console.log('- Implementation can change without affecting users');
console.log('- Reduces cognitive load and potential for errors');

/**
 * Real-world Abstraction Examples:
 * - Array.sort() - You don't need to know the sorting algorithm
 * - fetch() - You don't need to understand HTTP protocol details
 * - document.querySelector() - You don't need to know DOM traversal internals
 */
```

### 2. 🔒 Encapsulation

**Encapsulation** is about bundling data and methods together and controlling access to them. It's like having a capsule that protects the internal components and only allows controlled access through specific interfaces.

```javascript
/**
 * ENCAPSULATION: BUNDLING DATA AND CONTROLLING ACCESS
 * 
 * Encapsulation provides:
 * - Data protection from external interference
 * - Controlled access through public methods
 * - Internal state management
 * - Prevention of invalid state changes
 */

console.log('\n=== Encapsulation Demonstration ===');

/**
 * Example: Bank Account
 * We want to protect the balance from direct manipulation
 * and ensure all transactions go through proper validation.
 */

class BankAccount {
    constructor(accountHolder, initialBalance = 0) {
        this.accountHolder = accountHolder;
        
        // Private properties (encapsulated data)
        this._balance = initialBalance;
        this._transactionHistory = [];
        this._accountNumber = this._generateAccountNumber();
        
        console.log(`🏦 Account created for ${accountHolder}`);
        console.log(`📊 Initial balance: $${initialBalance}`);
    }
    
    /**
     * PUBLIC INTERFACE - Controlled access to account operations
     */
    
    // Getter for balance (read-only access)
    getBalance() {
        console.log(`💰 Current balance: $${this._balance}`);
        return this._balance;
    }
    
    // Controlled deposit method
    deposit(amount) {
        // Input validation (part of encapsulation)
        if (amount <= 0) {
            console.log('❌ Invalid deposit amount. Must be positive.');
            return false;
        }
        
        if (amount > 10000) {
            console.log('❌ Deposit amount exceeds daily limit ($10,000)');
            return false;
        }
        
        // Update internal state safely
        this._balance += amount;
        this._recordTransaction('deposit', amount);
        
        console.log(`✅ Deposited $${amount}. New balance: $${this._balance}`);
        return true;
    }
    
    // Controlled withdrawal method
    withdraw(amount) {
        // Validation and business logic
        if (amount <= 0) {
            console.log('❌ Invalid withdrawal amount. Must be positive.');
            return false;
        }
        
        if (amount > this._balance) {
            console.log('❌ Insufficient funds for withdrawal.');
            return false;
        }
        
        if (amount > 5000) {
            console.log('❌ Withdrawal amount exceeds daily limit ($5,000)');
            return false;
        }
        
        // Safe state update
        this._balance -= amount;
        this._recordTransaction('withdrawal', amount);
        
        console.log(`✅ Withdrew $${amount}. New balance: $${this._balance}`);
        return true;
    }
    
    // Controlled access to transaction history
    getTransactionHistory() {
        console.log('📋 Transaction History:');
        this._transactionHistory.forEach((transaction, index) => {
            console.log(`  ${index + 1}. ${transaction.type}: $${transaction.amount} on ${transaction.date}`);
        });
        return [...this._transactionHistory]; // Return copy, not original
    }
    
    /**
     * PRIVATE METHODS - Internal implementation (encapsulated)
     */
    
    _generateAccountNumber() {
        // Private method for internal use only
        return Math.random().toString(36).substr(2, 9).toUpperCase();
    }
    
    _recordTransaction(type, amount) {
        // Private method to maintain transaction history
        this._transactionHistory.push({
            type,
            amount,
            date: new Date().toLocaleString(),
            balance: this._balance
        });
    }
}

// Demonstration of encapsulation
console.log('\n🔒 Encapsulation in Action:');

const account = new BankAccount('Alice Johnson', 1000);

// ✅ Proper way to interact with the account (through public interface)
account.deposit(500);
account.withdraw(200);
account.getBalance();

// ❌ Direct access to private properties (should be avoided)
console.log('\n⚠️ What happens if we try to bypass encapsulation:');
console.log(`Direct balance access: $${account._balance}`); // Works but breaks encapsulation
account._balance = 1000000; // Dangerous! Bypasses all validation
console.log(`After direct manipulation: $${account._balance}`);

// This is why we need proper encapsulation!
console.log('\n💡 Encapsulation Benefits:');
console.log('- Prevents invalid state changes');
console.log('- Ensures business rules are followed');
console.log('- Provides controlled access to data');
console.log('- Makes debugging easier (controlled entry points)');

/**
 * Modern JavaScript Encapsulation with Private Fields
 * (We'll cover this in detail later)
 */

class ModernBankAccount {
    // Private fields (truly private in modern JavaScript)
    #balance;
    #transactionHistory = [];
    
    constructor(accountHolder, initialBalance = 0) {
        this.accountHolder = accountHolder;
        this.#balance = initialBalance;
    }
    
    getBalance() {
        return this.#balance;
    }
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            return true;
        }
        return false;
    }
}

const modernAccount = new ModernBankAccount('Bob Smith', 500);
console.log('\n🔐 Modern Encapsulation:');
console.log(`Balance: $${modernAccount.getBalance()}`);

// This will throw an error - truly private!
try {
    console.log(modernAccount.#balance);
} catch (error) {
    console.log('❌ Cannot access private field: #balance');
}
```

### 3. 🧬 Inheritance

**Inheritance** allows a class to inherit properties and methods from another class, creating a hierarchical relationship. It's like how children inherit traits from their parents, but can also have their own unique characteristics.

```javascript
/**
 * INHERITANCE: BUILDING HIERARCHICAL RELATIONSHIPS
 * 
 * Inheritance enables:
 * - Code reuse through shared functionality
 * - Hierarchical organization of related classes
 * - Specialization of general concepts
 * - Polymorphic behavior (we'll see this next)
 */

console.log('\n=== Inheritance Demonstration ===');

/**
 * Example: Vehicle Hierarchy
 * We'll create a general Vehicle class and then specialize it
 * for different types of vehicles.
 */

// Base class (Parent/Superclass)
class Vehicle {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.isRunning = false;
        this.speed = 0;
        
        console.log(`🚗 Created ${year} ${make} ${model}`);
    }
    
    // Methods that all vehicles share
    start() {
        this.isRunning = true;
        console.log(`${this.make} ${this.model} is now running!`);
    }
    
    stop() {
        this.isRunning = false;
        this.speed = 0;
        console.log(`${this.make} ${this.model} has stopped.`);
    }
    
    accelerate(amount) {
        if (this.isRunning) {
            this.speed += amount;
            console.log(`${this.make} ${this.model} accelerated to ${this.speed} mph`);
        } else {
            console.log('Cannot accelerate - vehicle is not running!');
        }
    }
    
    getInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
}

/**
 * Specialized classes (Children/Subclasses)
 * Each inherits from Vehicle but adds its own specific features
 */

// Car class - inherits from Vehicle
class Car extends Vehicle {
    constructor(make, model, year, doors, fuelType) {
        // Call parent constructor
        super(make, model, year);
        
        // Add car-specific properties
        this.doors = doors;
        this.fuelType = fuelType;
        this.trunkOpen = false;
    }
    
    // Car-specific methods
    openTrunk() {
        this.trunkOpen = true;
        console.log(`🚗 ${this.make} ${this.model} trunk opened`);
    }
    
    closeTrunk() {
        this.trunkOpen = false;
        console.log(`🚗 ${this.make} ${this.model} trunk closed`);
    }
    
    // Override parent method with car-specific behavior
    accelerate(amount) {
        if (this.isRunning) {
            // Cars have speed limits and different acceleration
            const maxSpeed = 120;
            this.speed = Math.min(this.speed + amount, maxSpeed);
            console.log(`🚗 Car accelerated to ${this.speed} mph (max: ${maxSpeed})`);
        } else {
            console.log('Cannot accelerate - car is not running!');
        }
    }
}

// Motorcycle class - inherits from Vehicle
class Motorcycle extends Vehicle {
    constructor(make, model, year, engineSize) {
        super(make, model, year);
        this.engineSize = engineSize;
        this.hasHelmet = false;
    }
    
    // Motorcycle-specific methods
    putOnHelmet() {
        this.hasHelmet = true;
        console.log(`🏍️ Helmet is now on - safety first!`);
    }
    
    // Override with motorcycle-specific behavior
    start() {
        if (!this.hasHelmet) {
            console.log('⚠️ Please put on helmet before starting motorcycle!');
            return;
        }
        super.start(); // Call parent method
        console.log('🏍️ Motorcycle engine roaring!');
    }
    
    accelerate(amount) {
        if (this.isRunning) {
            // Motorcycles can go faster but are more dangerous
            const maxSpeed = 180;
            this.speed = Math.min(this.speed + amount * 1.5, maxSpeed);
            console.log(`🏍️ Motorcycle accelerated to ${this.speed} mph (max: ${maxSpeed})`);
        } else {
            console.log('Cannot accelerate - motorcycle is not running!');
        }
    }
}

// Truck class - inherits from Vehicle
class Truck extends Vehicle {
    constructor(make, model, year, cargoCapacity) {
        super(make, model, year);
        this.cargoCapacity = cargoCapacity;
        this.currentCargo = 0;
    }
    
    loadCargo(weight) {
        if (this.currentCargo + weight <= this.cargoCapacity) {
            this.currentCargo += weight;
            console.log(`🚛 Loaded ${weight} lbs. Total cargo: ${this.currentCargo}/${this.cargoCapacity} lbs`);
        } else {
            console.log(`❌ Cannot load ${weight} lbs - exceeds capacity!`);
        }
    }
    
    // Trucks accelerate slower when loaded
    accelerate(amount) {
        if (this.isRunning) {
            const maxSpeed = 80;
            // Reduce acceleration based on cargo load
            const loadFactor = 1 - (this.currentCargo / this.cargoCapacity) * 0.5;
            const actualAcceleration = amount * loadFactor;
            
            this.speed = Math.min(this.speed + actualAcceleration, maxSpeed);
            console.log(`🚛 Truck accelerated to ${this.speed.toFixed(1)} mph (load factor: ${loadFactor.toFixed(2)})`);
        } else {
            console.log('Cannot accelerate - truck is not running!');
        }
    }
}

// Demonstration of inheritance
console.log('\n🧬 Inheritance in Action:');

// Create instances of different vehicle types
const car = new Car('Toyota', 'Camry', 2023, 4, 'Gasoline');
const motorcycle = new Motorcycle('Harley-Davidson', 'Street 750', 2023, 750);
const truck = new Truck('Ford', 'F-150', 2023, 2000);

console.log('\n📋 All vehicles share common behavior:');
// All can use inherited methods
car.start();
motorcycle.putOnHelmet(); // Motorcycle-specific requirement
motorcycle.start();
truck.start();

console.log('\n🚀 Each vehicle type has specialized behavior:');
// Each has specialized acceleration
car.accelerate(30);
motorcycle.accelerate(30);
truck.loadCargo(1500); // Load the truck
truck.accelerate(30);

console.log('\n🔍 Inheritance Verification:');
console.log(`Car is instance of Vehicle: ${car instanceof Vehicle}`); // true
console.log(`Car is instance of Car: ${car instanceof Car}`); // true
console.log(`Motorcycle is instance of Vehicle: ${motorcycle instanceof Vehicle}`); // true
console.log(`Truck is instance of Vehicle: ${truck instanceof Vehicle}`); // true

/**
 * Inheritance Benefits Demonstrated:
 * 1. Code Reuse - All vehicles share start(), stop(), getInfo() methods
 * 2. Specialization - Each vehicle type adds its own specific features
 * 3. Polymorphism - Same method (accelerate) behaves differently for each type
 * 4. Maintainability - Changes to Vehicle class affect all subclasses
 */

console.log('\n💡 Inheritance Benefits:');
console.log('- Eliminates code duplication');
console.log('- Creates logical hierarchies');
console.log('- Enables polymorphic behavior');
console.log('- Makes maintenance easier');
console.log('- Models real-world relationships');
```

### 4. 🎭 Polymorphism

**Polymorphism** means "many forms" - it allows objects of different types to be treated as instances of the same type through a common interface. The same method call can produce different behaviors depending on the object type.

```javascript
/**
 * POLYMORPHISM: ONE INTERFACE, MANY IMPLEMENTATIONS
 * 
 * Polymorphism enables:
 * - Same method name, different behaviors
 * - Flexible and extensible code
 * - Runtime method resolution
 * - Simplified client code
 */

console.log('\n=== Polymorphism Demonstration ===');

/**
 * Example: Shape Drawing System
 * Different shapes implement the same interface but behave differently
 */

// Base class defining the common interface
class Shape {
    constructor(color) {
        this.color = color;
    }
    
    // Abstract methods - to be implemented by subclasses
    draw() {
        throw new Error('draw() method must be implemented by subclass');
    }
    
    calculateArea() {
        throw new Error('calculateArea() method must be implemented by subclass');
    }
    
    // Common method for all shapes
    getInfo() {
        return `${this.constructor.name} (${this.color})`;
    }
}

// Different shape implementations
class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    draw() {
        console.log(`🔵 Drawing a ${this.color} circle with radius ${this.radius}`);
        // In a real app, this might render to canvas or SVG
        return `<circle r="${this.radius}" fill="${this.color}" />`;
    }
    
    calculateArea() {
        const area = Math.PI * this.radius * this.radius;
        console.log(`📐 Circle area: ${area.toFixed(2)} square units`);
        return area;
    }
}

class Rectangle extends Shape {
    constructor(color, width, height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    draw() {
        console.log(`🟦 Drawing a ${this.color} rectangle ${this.width}x${this.height}`);
        return `<rect width="${this.width}" height="${this.height}" fill="${this.color}" />`;
    }
    
    calculateArea() {
        const area = this.width * this.height;
        console.log(`📐 Rectangle area: ${area} square units`);
        return area;
    }
}

class Triangle extends Shape {
    constructor(color, base, height) {
        super(color);
        this.base = base;
        this.height = height;
    }
    
    draw() {
        console.log(`🔺 Drawing a ${this.color} triangle with base ${this.base} and height ${this.height}`);
        return `<polygon points="0,${this.height} ${this.base/2},0 ${this.base},${this.height}" fill="${this.color}" />`;
    }
    
    calculateArea() {
        const area = (this.base * this.height) / 2;
        console.log(`📐 Triangle area: ${area} square units`);
        return area;
    }
}

/**
 * Drawing Application - Demonstrates Polymorphism
 * The same code works with different shape types!
 */

class DrawingApplication {
    constructor() {
        this.shapes = [];
    }
    
    addShape(shape) {
        // We don't need to know what type of shape this is!
        // Polymorphism allows us to treat all shapes the same way
        this.shapes.push(shape);
        console.log(`➕ Added ${shape.getInfo()} to drawing`);
    }
    
    drawAllShapes() {
        console.log('\n🎨 Drawing all shapes:');
        
        // This is polymorphism in action!
        // Same method call (draw()) works differently for each shape type
        this.shapes.forEach((shape, index) => {
            console.log(`${index + 1}. ${shape.getInfo()}`);
            shape.draw(); // Polymorphic method call
        });
    }
    
    calculateTotalArea() {
        console.log('\n📊 Calculating total area:');
        
        let totalArea = 0;
        this.shapes.forEach(shape => {
            // Another polymorphic method call!
            const area = shape.calculateArea();
            totalArea += area;
        });
        
        console.log(`📈 Total area of all shapes: ${totalArea.toFixed(2)} square units`);
        return totalArea;
    }
    
    // This method works with ANY shape that implements the Shape interface
    processShape(shape) {
        console.log(`\n🔄 Processing ${shape.getInfo()}:`);
        shape.draw();
        shape.calculateArea();
        
        // We can add new shape types without changing this method!
        // This is the power of polymorphism
    }
}

// Demonstration of polymorphism
console.log('\n🎭 Polymorphism in Action:');

const app = new DrawingApplication();

// Create different types of shapes
const circle = new Circle('red', 5);
const rectangle = new Rectangle('blue', 10, 6);
const triangle = new Triangle('green', 8, 4);

// Add shapes to the application
app.addShape(circle);
app.addShape(rectangle);
app.addShape(triangle);

// Polymorphic behavior - same method calls, different implementations
app.drawAllShapes();
app.calculateTotalArea();

// Process each shape individually (polymorphic method)
console.log('\n🔄 Individual Shape Processing:');
app.shapes.forEach(shape => app.processShape(shape));

/**
 * Advanced Polymorphism Example: Plugin System
 * Shows how polymorphism enables extensible architectures
 */

console.log('\n🔌 Advanced Polymorphism: Plugin System');

// Base plugin interface
class Plugin {
    constructor(name) {
        this.name = name;
    }
    
    execute() {
        throw new Error('execute() method must be implemented');
    }
    
    getDescription() {
        return `Plugin: ${this.name}`;
    }
}

// Different plugin implementations
class EmailPlugin extends Plugin {
    constructor() {
        super('Email Sender');
    }
    
    execute(data) {
        console.log(`📧 Sending email to ${data.recipient}: ${data.message}`);
        return { status: 'sent', timestamp: new Date() };
    }
}

class DatabasePlugin extends Plugin {
    constructor() {
        super('Database Logger');
    }
    
    execute(data) {
        console.log(`💾 Logging to database: ${JSON.stringify(data)}`);
        return { status: 'logged', id: Math.random().toString(36) };
    }
}

class NotificationPlugin extends Plugin {
    constructor() {
        super('Push Notification');
    }
    
    execute(data) {
        console.log(`🔔 Sending push notification: ${data.message}`);
        return { status: 'pushed', deviceCount: 42 };
    }
}

// Plugin manager - uses polymorphism
class PluginManager {
    constructor() {
        this.plugins = [];
    }
    
    registerPlugin(plugin) {
        this.plugins.push(plugin);
        console.log(`🔌 Registered ${plugin.getDescription()}`);
    }
    
    executeAll(data) {
        console.log('\n⚡ Executing all plugins:');
        
        // Polymorphic execution - same interface, different behaviors
        const results = this.plugins.map(plugin => {
            console.log(`  Running ${plugin.name}...`);
            return plugin.execute(data);
        });
        
        return results;
    }
}

// Demonstrate plugin system polymorphism
const pluginManager = new PluginManager();

// Register different types of plugins
pluginManager.registerPlugin(new EmailPlugin());
pluginManager.registerPlugin(new DatabasePlugin());
pluginManager.registerPlugin(new NotificationPlugin());

// Execute all plugins with the same interface
const testData = {
    recipient: 'user@example.com',
    message: 'Welcome to our service!',
    userId: 12345
};

const results = pluginManager.executeAll(testData);
console.log('\n📊 Plugin execution results:', results);

console.log('\n💡 Polymorphism Benefits:');
console.log('- Same interface, different implementations');
console.log('- Easy to add new types without changing existing code');
console.log('- Enables flexible and extensible architectures');
console.log('- Simplifies client code (no need to know specific types)');
console.log('- Runtime method resolution based on object type');
```

---

## 🔧 OOP in JavaScript: The Prototypal Way

JavaScript implements OOP differently from traditional class-based languages. Instead of classes, JavaScript uses **prototypes** - a more flexible and powerful system once you understand it.

### Understanding JavaScript's Prototypal Inheritance

```javascript
/**
 * JAVASCRIPT'S PROTOTYPAL INHERITANCE SYSTEM
 * 
 * Unlike class-based languages, JavaScript uses prototypes:
 * - Every object has a prototype (except Object.prototype)
 * - Objects inherit directly from other objects
 * - More flexible than traditional class inheritance
 * - Enables dynamic behavior modification
 */

console.log('=== JavaScript Prototypal Inheritance ===');

/**
 * The Prototype Chain Explained
 * 
 * When you access a property on an object:
 * 1. JavaScript first looks on the object itself
 * 2. If not found, it looks on the object's prototype
 * 3. If not found, it looks on the prototype's prototype
 * 4. This continues until it reaches Object.prototype
 * 5. If still not found, returns undefined
 */

function demonstratePrototypeChain() {
    console.log('\n🔗 Prototype Chain Demonstration:');
    
    // Create a simple object
    const person = {
        name: 'Alice',
        greet() {
            console.log(`Hello, I'm ${this.name}`);
        }
    };
    
    // Create another object that inherits from person
    const student = Object.create(person);
    student.studentId = 12345;
    student.study = function() {
        console.log(`${this.name} is studying`);
    };
    
    // Create a graduate student that inherits from student
    const gradStudent = Object.create(student);
    gradStudent.researchTopic = 'Machine Learning';
    gradStudent.research = function() {
        console.log(`${this.name} is researching ${this.researchTopic}`);
    };
    
    // Set properties
    gradStudent.name = 'Bob';
    
    console.log('🔍 Property Lookup Demonstration:');
    
    // When we access gradStudent.name:
    console.log(`gradStudent.name: ${gradStudent.name}`); // Found on gradStudent itself
    
    // When we access gradStudent.studentId:
    console.log(`gradStudent.studentId: ${gradStudent.studentId}`); // Found on student prototype
    
    // When we access gradStudent.greet:
    gradStudent.greet(); // Found on person prototype
    
    // Method calls work through the prototype chain
    gradStudent.study(); // From student prototype
    gradStudent.research(); // From gradStudent itself
    
    console.log('\n🔍 Prototype Chain Inspection:');
    console.log('gradStudent.__proto__ === student:', gradStudent.__proto__ === student);
    console.log('student.__proto__ === person:', student.__proto__ === person);
    console.log('person.__proto__ === Object.prototype:', person.__proto__ === Object.prototype);
    
    // Visualize the prototype chain
    console.log('\n📊 Prototype Chain Visualization:');
    let current = gradStudent;
    let level = 0;
    
    while (current) {
        const indent = '  '.repeat(level);
        const objName = current.constructor?.name || 'Object';
        const ownProps = Object.getOwnPropertyNames(current).filter(prop => prop !== '__proto__');
        
        console.log(`${indent}Level ${level}: ${objName}`);
        console.log(`${indent}  Own properties: [${ownProps.join(', ')}]`);
        
        current = Object.getPrototypeOf(current);
        level++;
        
        if (level > 5) break; // Prevent infinite loop
    }
}

demonstratePrototypeChain();

/**
 * Three Ways to Implement Prototypal Inheritance in JavaScript
 */

console.log('\n🛠️ Three Ways to Implement Prototypal Inheritance:');

// 1. Constructor Functions (ES5 and earlier)
console.log('\n1️⃣ Constructor Functions:');

function Animal(name, species) {
    this.name = name;
    this.species = species;
}

Animal.prototype.makeSound = function() {
    console.log(`${this.name} makes a sound`);
};

Animal.prototype.getInfo = function() {
    return `${this.name} is a ${this.species}`;
};

const dog = new Animal('Buddy', 'Dog');
dog.makeSound();
console.log(dog.getInfo());

// 2. ES6 Classes (syntactic sugar over constructor functions)
console.log('\n2️⃣ ES6 Classes:');

class Plant {
    constructor(name, type) {
        this.name = name;
        this.type = type;
    }
    
    photosynthesize() {
        console.log(`${this.name} is photosynthesizing`);
    }
    
    getInfo() {
        return `${this.name} is a ${this.type}`;
    }
}

const rose = new Plant('Rose', 'Flower');
rose.photosynthesize();
console.log(rose.getInfo());

// 3. Object.create() (direct prototype linking)
console.log('\n3️⃣ Object.create():');

const vehiclePrototype = {
    start() {
        console.log(`${this.name} is starting`);
    },
    
    getInfo() {
        return `${this.name} - ${this.type}`;
    }
};

const car = Object.create(vehiclePrototype);
car.name = 'Tesla Model 3';
car.type = 'Electric Car';
car.start();
console.log(car.getInfo());

/**
 * Comparison of the Three Approaches
 */

console.log('\n📊 Comparison of Approaches:');

console.log('\n🏗️ Constructor Functions:');
console.log('  ✅ Widely supported (all browsers)');
console.log('  ✅ Clear instantiation with "new"');
console.log('  ❌ Verbose syntax');
console.log('  ❌ Easy to forget "new" keyword');

console.log('\n🎓 ES6 Classes:');
console.log('  ✅ Clean, familiar syntax');
console.log('  ✅ Built-in inheritance with "extends"');
console.log('  ✅ Static methods support');
console.log('  ❌ Just syntactic sugar (same prototype system underneath)');
console.log('  ❌ Not supported in older browsers without transpilation');

console.log('\n🔗 Object.create():');
console.log('  ✅ Direct prototype manipulation');
console.log('  ✅ Most flexible approach');
console.log('  ✅ No constructor function needed');
console.log('  ❌ Less intuitive for developers from class-based languages');
console.log('  ❌ Manual property initialization');

/**
 * When to Use Each Approach
 */

console.log('\n🎯 When to Use Each Approach:');
console.log('\n🏗️ Use Constructor Functions when:');
console.log('  - Supporting older browsers');
console.log('  - Working with legacy codebases');
console.log('  - Need maximum compatibility');

console.log('\n🎓 Use ES6 Classes when:');
console.log('  - Building modern applications');
console.log('  - Team familiar with class-based OOP');
console.log('  - Want clean, readable syntax');
console.log('  - Using inheritance extensively');

console.log('\n🔗 Use Object.create() when:');
console.log('  - Need maximum flexibility');
console.log('  - Creating simple object hierarchies');
console.log('  - Implementing mixins or composition');
console.log('  - Performance is critical (no constructor overhead)');
```---

#
# 🏗️ Constructor Functions and the `new` Operator

Constructor functions are the traditional way to create objects in JavaScript. They're regular functions that are called with the `new` operator to create instances.

### Understanding Constructor Functions

```javascript
/**
 * CONSTRUCTOR FUNCTIONS: THE TRADITIONAL APPROACH
 * 
 * Constructor functions are:
 * - Regular functions called with the 'new' operator
 * - Used to create multiple instances of similar objects
 * - The foundation of JavaScript's object creation before ES6 classes
 * - Still widely used and important to understand
 */

console.log('=== Constructor Functions Deep Dive ===');

/**
 * What happens when you use the 'new' operator:
 * 
 * 1. A new empty object {} is created
 * 2. The function is called with 'this' pointing to the new object
 * 3. The new object is linked to the function's prototype
 * 4. The function automatically returns the new object (unless explicitly returning another object)
 */

function Person(firstName, birthYear) {
    console.log('🏗️ Constructor function called with:', { firstName, birthYear });
    console.log('🔍 this before assignment:', this);
    
    // Step 2: Set properties on the new object (this)
    this.firstName = firstName;
    this.birthYear = birthYear;
    
    // ❌ NEVER do this in a constructor function!
    // Creating methods inside constructor means each instance gets its own copy
    // This wastes memory and defeats the purpose of prototypes
    // this.calcAge = function() {
    //     return 2024 - this.birthYear;
    // };
    
    console.log('🔍 this after assignment:', this);
    
    // Step 4: The new object is automatically returned
    // (unless we explicitly return a different object)
}

/**
 * Demonstration of the 'new' operator process
 */

console.log('\n🔍 Step-by-step "new" operator demonstration:');

console.log('\n1️⃣ Creating first person...');
const alice = new Person('Alice', 1990);

console.log('\n2️⃣ Creating second person...');
const bob = new Person('Bob', 1985);

console.log('\n✅ Final objects:');
console.log('Alice:', alice);
console.log('Bob:', bob);

// Verify they are instances of Person
console.log('\n🔍 Instance verification:');
console.log('alice instanceof Person:', alice instanceof Person); // true
console.log('bob instanceof Person:', bob instanceof Person); // true
console.log('alice instanceof Object:', alice instanceof Object); // true

/**
 * What happens if you forget the 'new' operator?
 */

console.log('\n⚠️ What happens without "new"?');

// ❌ Calling constructor function without 'new'
const charlie = Person('Charlie', 1995);

console.log('charlie:', charlie); // undefined (function doesn't explicitly return anything)
console.log('window.firstName:', globalThis.firstName); // 'Charlie' (in browser, this would be window.firstName)

// The properties were set on the global object instead of a new object!
// This is a common source of bugs

/**
 * Best Practices for Constructor Functions
 */

console.log('\n📋 Constructor Function Best Practices:');

// ✅ Good constructor function
function Vehicle(make, model, year) {
    // 1. Validate input parameters
    if (!make || !model || !year) {
        throw new Error('Make, model, and year are required');
    }
    
    // 2. Use clear, descriptive property names
    this.make = make;
    this.model = model;
    this.year = year;
    
    // 3. Set default values for optional properties
    this.isRunning = false;
    this.mileage = 0;
    
    // 4. Initialize arrays and objects as new instances
    this.maintenanceHistory = []; // Each instance gets its own array
    
    // 5. Call initialization methods if needed
    this._initialize();
}

// ✅ Add methods to prototype (shared by all instances)
Vehicle.prototype.start = function() {
    if (this.isRunning) {
        console.log(`${this.make} ${this.model} is already running`);
        return;
    }
    
    this.isRunning = true;
    console.log(`🚗 ${this.make} ${this.model} started`);
};

Vehicle.prototype.stop = function() {
    if (!this.isRunning) {
        console.log(`${this.make} ${this.model} is already stopped`);
        return;
    }
    
    this.isRunning = false;
    console.log(`🛑 ${this.make} ${this.model} stopped`);
};

Vehicle.prototype.drive = function(miles) {
    if (!this.isRunning) {
        console.log('Cannot drive - vehicle is not running!');
        return;
    }
    
    this.mileage += miles;
    console.log(`🛣️ Drove ${miles} miles. Total mileage: ${this.mileage}`);
};

Vehicle.prototype.addMaintenance = function(description) {
    const maintenanceRecord = {
        date: new Date().toLocaleDateString(),
        description: description,
        mileage: this.mileage
    };
    
    this.maintenanceHistory.push(maintenanceRecord);
    console.log(`🔧 Maintenance added: ${description}`);
};

Vehicle.prototype.getInfo = function() {
    return `${this.year} ${this.make} ${this.model} (${this.mileage} miles)`;
};

// Private method (convention: prefix with underscore)
Vehicle.prototype._initialize = function() {
    console.log(`🏗️ Initializing ${this.make} ${this.model}`);
};

/**
 * Demonstration of well-designed constructor function
 */

console.log('\n🚗 Vehicle Constructor Demonstration:');

try {
    const car1 = new Vehicle('Toyota', 'Camry', 2022);
    const car2 = new Vehicle('Honda', 'Civic', 2023);
    
    console.log('\n🔧 Testing vehicle operations:');
    
    // Test car1
    console.log(`\n${car1.getInfo()}:`);
    car1.start();
    car1.drive(150);
    car1.addMaintenance('Oil change');
    car1.stop();
    
    // Test car2
    console.log(`\n${car2.getInfo()}:`);
    car2.start();
    car2.drive(75);
    car2.addMaintenance('Tire rotation');
    
    // Verify shared methods but separate data
    console.log('\n🔍 Shared methods, separate data:');
    console.log('Same start method?', car1.start === car2.start); // true
    console.log('Same maintenance history?', car1.maintenanceHistory === car2.maintenanceHistory); // false
    console.log('Car1 maintenance:', car1.maintenanceHistory);
    console.log('Car2 maintenance:', car2.maintenanceHistory);
    
} catch (error) {
    console.error('❌ Error creating vehicle:', error.message);
}

/**
 * Advanced Constructor Function Patterns
 */

console.log('\n🎯 Advanced Constructor Patterns:');

// Pattern 1: Factory Constructor (returns different types based on input)
function AnimalFactory(type, name) {
    // Return different constructor based on type
    switch (type.toLowerCase()) {
        case 'dog':
            return new Dog(name);
        case 'cat':
            return new Cat(name);
        case 'bird':
            return new Bird(name);
        default:
            throw new Error(`Unknown animal type: ${type}`);
    }
}

// Base animal constructor
function Animal(name, species) {
    this.name = name;
    this.species = species;
    this.energy = 100;
}

Animal.prototype.eat = function() {
    this.energy = Math.min(this.energy + 20, 100);
    console.log(`${this.name} ate food. Energy: ${this.energy}`);
};

Animal.prototype.sleep = function() {
    this.energy = 100;
    console.log(`${this.name} slept and restored energy to ${this.energy}`);
};

// Specific animal constructors
function Dog(name) {
    Animal.call(this, name, 'Dog'); // Call parent constructor
    this.loyalty = 100;
}

// Set up inheritance
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    this.energy -= 5;
    console.log(`${this.name} barks! Woof! Energy: ${this.energy}`);
};

Dog.prototype.fetch = function() {
    this.energy -= 15;
    this.loyalty += 5;
    console.log(`${this.name} fetched the ball! Loyalty: ${this.loyalty}, Energy: ${this.energy}`);
};

function Cat(name) {
    Animal.call(this, name, 'Cat');
    this.independence = 80;
}

Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Cat;

Cat.prototype.meow = function() {
    this.energy -= 3;
    console.log(`${this.name} meows! Meow! Energy: ${this.energy}`);
};

Cat.prototype.purr = function() {
    console.log(`${this.name} purrs contentedly`);
};

function Bird(name) {
    Animal.call(this, name, 'Bird');
    this.canFly = true;
}

Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;

Bird.prototype.chirp = function() {
    this.energy -= 2;
    console.log(`${this.name} chirps! Tweet! Energy: ${this.energy}`);
};

Bird.prototype.fly = function() {
    if (this.canFly && this.energy >= 20) {
        this.energy -= 20;
        console.log(`${this.name} flies gracefully! Energy: ${this.energy}`);
    } else {
        console.log(`${this.name} is too tired to fly or cannot fly`);
    }
};

// Demonstrate factory pattern
console.log('\n🏭 Factory Constructor Pattern:');

const pets = [
    AnimalFactory('dog', 'Buddy'),
    AnimalFactory('cat', 'Whiskers'),
    AnimalFactory('bird', 'Tweety')
];

pets.forEach(pet => {
    console.log(`\n${pet.name} the ${pet.species}:`);
    pet.eat();
    
    // Call species-specific methods
    if (pet instanceof Dog) {
        pet.bark();
        pet.fetch();
    } else if (pet instanceof Cat) {
        pet.meow();
        pet.purr();
    } else if (pet instanceof Bird) {
        pet.chirp();
        pet.fly();
    }
});

/**
 * Constructor Function vs Regular Function
 */

console.log('\n🔍 Constructor vs Regular Function:');

// Same function can be used both ways
function FlexibleFunction(value) {
    // Detect if called with 'new'
    if (new.target) {
        // Called as constructor
        console.log('📦 Called as constructor');
        this.value = value;
        this.type = 'instance';
    } else {
        // Called as regular function
        console.log('🔧 Called as regular function');
        return {
            value: value,
            type: 'object literal'
        };
    }
}

FlexibleFunction.prototype.getValue = function() {
    return this.value;
};

const instance = new FlexibleFunction('constructor call');
const object = FlexibleFunction('function call');

console.log('Instance:', instance);
console.log('Object:', object);
console.log('Instance has getValue method:', typeof instance.getValue); // function
console.log('Object has getValue method:', typeof object.getValue); // undefined

console.log('\n💡 Constructor Function Key Points:');
console.log('- Use PascalCase naming convention');
console.log('- Always call with "new" operator');
console.log('- Add methods to prototype, not inside constructor');
console.log('- Use "this" to set instance properties');
console.log('- Validate input parameters');
console.log('- Handle the case where "new" is forgotten');
```

---

## 🔗 Prototypes and the Prototype Chain

Prototypes are the mechanism by which JavaScript objects inherit features from one another. Understanding prototypes is crucial for mastering JavaScript OOP.

### Deep Dive into Prototypes

```javascript
/**
 * PROTOTYPES: THE HEART OF JAVASCRIPT OOP
 * 
 * Key concepts:
 * - Every function has a 'prototype' property
 * - Every object has a '__proto__' property (link to its prototype)
 * - Prototype chain enables inheritance
 * - Methods are shared via prototypes (memory efficient)
 */

console.log('=== Prototypes Deep Dive ===');

/**
 * Understanding the Prototype Property
 */

function Person(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
}

console.log('\n🔍 Exploring Function Prototypes:');
console.log('Person.prototype:', Person.prototype);
console.log('Person.prototype is an object:', typeof Person.prototype); // object
console.log('Person.prototype.constructor:', Person.prototype.constructor === Person); // true

// Add methods to the prototype
Person.prototype.calcAge = function() {
    const age = 2024 - this.birthYear;
    console.log(`${this.firstName} is ${age} years old`);
    return age;
};

Person.prototype.greet = function() {
    console.log(`Hello, I'm ${this.firstName}!`);
};

// Add properties to the prototype (shared by all instances)
Person.prototype.species = 'Homo Sapiens';

/**
 * Creating Instances and Exploring Prototype Links
 */

console.log('\n👥 Creating Person Instances:');

const alice = new Person('Alice', 1990);
const bob = new Person('Bob', 1985);

console.log('Alice:', alice);
console.log('Bob:', bob);

// Instances can use prototype methods
console.log('\n🔧 Using Prototype Methods:');
alice.calcAge();
bob.greet();

// Accessing prototype properties
console.log('\n🧬 Accessing Prototype Properties:');
console.log(`Alice species: ${alice.species}`);
console.log(`Bob species: ${bob.species}`);

/**
 * Understanding __proto__ vs prototype
 */

console.log('\n🔍 __proto__ vs prototype:');

console.log('alice.__proto__ === Person.prototype:', alice.__proto__ === Person.prototype); // true
console.log('bob.__proto__ === Person.prototype:', bob.__proto__ === Person.prototype); // true

// Common misconception clarification
console.log('Person.prototype is NOT the prototype OF Person');
console.log('Person.prototype is the prototype FOR objects created by Person');
console.log('Person.prototype.isPrototypeOf(alice):', Person.prototype.isPrototypeOf(alice)); // true
console.log('Person.prototype.isPrototypeOf(Person):', Person.prototype.isPrototypeOf(Person)); // false

/**
 * Property Lookup in the Prototype Chain
 */

console.log('\n🔍 Property Lookup Demonstration:');

// Own properties vs inherited properties
console.log('alice.hasOwnProperty("firstName"):', alice.hasOwnProperty('firstName')); // true
console.log('alice.hasOwnProperty("species"):', alice.hasOwnProperty('species')); // false
console.log('alice.hasOwnProperty("calcAge"):', alice.hasOwnProperty('calcAge')); // false

// Where properties are found
console.log('\n📍 Property Location:');
console.log('alice.firstName (own property):', alice.firstName);
console.log('alice.species (prototype property):', alice.species);

// Overriding prototype properties
alice.species = 'Homo Sapiens Sapiens'; // Creates own property
console.log('After override - alice.species:', alice.species);
console.log('Bob still has original - bob.species:', bob.species);
console.log('alice.hasOwnProperty("species"):', alice.hasOwnProperty('species')); // now true

/**
 * The Complete Prototype Chain
 */

console.log('\n🔗 Complete Prototype Chain Exploration:');

function explorePrototypeChain(obj, objName) {
    console.log(`\n📊 Prototype chain for ${objName}:`);
    
    let current = obj;
    let level = 0;
    
    while (current) {
        const indent = '  '.repeat(level);
        
        if (level === 0) {
            console.log(`${indent}${objName} (the object itself)`);
            console.log(`${indent}  Own properties: [${Object.getOwnPropertyNames(current).join(', ')}]`);
        } else {
            const constructorName = current.constructor?.name || 'Unknown';
            console.log(`${indent}Level ${level}: ${constructorName}.prototype`);
            
            const ownProps = Object.getOwnPropertyNames(current)
                .filter(prop => prop !== 'constructor' && typeof current[prop] === 'function');
            console.log(`${indent}  Methods: [${ownProps.join(', ')}]`);
        }
        
        current = Object.getPrototypeOf(current);
        level++;
        
        if (level > 5) break; // Safety check
    }
}

explorePrototypeChain(alice, 'alice');

/**
 * Prototype Chain in Built-in Objects
 */

console.log('\n🏗️ Built-in Object Prototype Chains:');

// Array prototype chain
const arr = [1, 2, 3];
console.log('\n📊 Array prototype chain:');
console.log('arr.__proto__ === Array.prototype:', arr.__proto__ === Array.prototype);
console.log('Array.prototype.__proto__ === Object.prototype:', Array.prototype.__proto__ === Object.prototype);
console.log('Object.prototype.__proto__:', Object.prototype.__proto__); // null (end of chain)

// Function prototype chain
function myFunction() {}
console.log('\n📊 Function prototype chain:');
console.log('myFunction.__proto__ === Function.prototype:', myFunction.__proto__ === Function.prototype);
console.log('Function.prototype.__proto__ === Object.prototype:', Function.prototype.__proto__ === Object.prototype);

/**
 * Dynamic Prototype Modification
 */

console.log('\n🔄 Dynamic Prototype Modification:');

// Add method to existing prototype
Person.prototype.getFullInfo = function() {
    return `${this.firstName}, born in ${this.birthYear}, age ${2024 - this.birthYear}`;
};

// All existing instances immediately get the new method!
console.log('Alice full info:', alice.getFullInfo());
console.log('Bob full info:', bob.getFullInfo());

// Add method to built-in prototype (generally not recommended)
Array.prototype.unique = function() {
    return [...new Set(this)];
};

const numbers = [1, 2, 2, 3, 3, 3, 4];
console.log('Original array:', numbers);
console.log('Unique values:', numbers.unique());

// ⚠️ Warning about modifying built-in prototypes
console.log('\n⚠️ Modifying built-in prototypes:');
console.log('✅ Pros: Adds functionality to all instances');
console.log('❌ Cons: Can break other code, pollutes global namespace');
console.log('❌ Cons: Future JS versions might add conflicting methods');
console.log('🎯 Recommendation: Avoid in production code');

/**
 * Prototype-based Inheritance Example
 */

console.log('\n🧬 Prototype-based Inheritance:');

// Parent constructor
function Animal(name, species) {
    this.name = name;
    this.species = species;
}

Animal.prototype.makeSound = function() {
    console.log(`${this.name} makes a generic animal sound`);
};

Animal.prototype.getInfo = function() {
    return `${this.name} is a ${this.species}`;
};

// Child constructor
function Dog(name, breed) {
    Animal.call(this, name, 'Dog'); // Call parent constructor
    this.breed = breed;
}

// Set up inheritance - IMPORTANT: Do this before adding methods to Dog.prototype
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // Fix constructor reference

// Add Dog-specific methods
Dog.prototype.makeSound = function() {
    console.log(`${this.name} barks: Woof! Woof!`);
};

Dog.prototype.wagTail = function() {
    console.log(`${this.name} wags tail happily!`);
};

// Create instances
const genericAnimal = new Animal('Generic', 'Unknown');
const buddy = new Dog('Buddy', 'Golden Retriever');

console.log('\n🐕 Testing inheritance:');
console.log(genericAnimal.getInfo());
genericAnimal.makeSound();

console.log(buddy.getInfo()); // Inherited from Animal
buddy.makeSound(); // Overridden in Dog
buddy.wagTail(); // Dog-specific method

// Verify inheritance
console.log('\n🔍 Inheritance verification:');
console.log('buddy instanceof Dog:', buddy instanceof Dog); // true
console.log('buddy instanceof Animal:', buddy instanceof Animal); // true
console.log('buddy instanceof Object:', buddy instanceof Object); // true

/**
 * Prototype Performance Considerations
 */

console.log('\n⚡ Prototype Performance Benefits:');

// Memory usage comparison
function MemoryHeavyPerson(name) {
    this.name = name;
    
    // ❌ Bad: Each instance gets its own copy of the method
    this.greet = function() {
        console.log(`Hello, I'm ${this.name}`);
    };
}

function MemoryEfficientPerson(name) {
    this.name = name;
}

// ✅ Good: All instances share the same method
MemoryEfficientPerson.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

// Create multiple instances
const heavyPeople = [];
const efficientPeople = [];

for (let i = 0; i < 1000; i++) {
    heavyPeople.push(new MemoryHeavyPerson(`Person${i}`));
    efficientPeople.push(new MemoryEfficientPerson(`Person${i}`));
}

console.log('Created 1000 instances of each type');
console.log('Heavy approach: Each instance has its own greet method');
console.log('Efficient approach: All instances share one greet method via prototype');
console.log('Memory savings: Significant when creating many instances');

// Verify method sharing
console.log('\nMethod sharing verification:');
console.log('Heavy - same method?', heavyPeople[0].greet === heavyPeople[1].greet); // false
console.log('Efficient - same method?', efficientPeople[0].greet === efficientPeople[1].greet); // true

console.log('\n💡 Prototype Key Takeaways:');
console.log('- Prototypes enable efficient method sharing');
console.log('- __proto__ links objects to their prototype');
console.log('- Prototype chain enables inheritance');
console.log('- Methods should be on prototype, not in constructor');
console.log('- Prototype chain lookup has performance cost');
console.log('- Understanding prototypes is key to mastering JavaScript');
```

---

## 🎓 ES6 Classes: Modern JavaScript OOP

ES6 introduced class syntax to JavaScript, providing a more familiar and cleaner way to create objects and implement inheritance. However, it's important to understand that classes are syntactic sugar over the existing prototype system.

### ES6 Classes Fundamentals

```javascript
/**
 * ES6 CLASSES: MODERN JAVASCRIPT OOP SYNTAX
 * 
 * ES6 Classes provide:
 * - Cleaner, more familiar syntax
 * - Built-in inheritance with 'extends'
 * - Static methods and properties
 * - Private fields and methods (modern browsers)
 * - Better tooling support
 * 
 * Important: Classes are syntactic sugar over prototypes!
 */

console.log('=== ES6 Classes Comprehensive Guide ===');

/**
 * Basic Class Declaration
 */

class Person {
    // Constructor method - called when creating new instances
    constructor(firstName, lastName, birthYear) {
        // Validate input (good practice)
        if (!firstName || !lastName || !birthYear) {
            throw new Error('firstName, lastName, and birthYear are required');
        }
        
        // Instance properties
        this.firstName = firstName;
        this.lastName = lastName;
        this.birthYear = birthYear;
        
        // Private properties (convention: prefix with _)
        this._id = Math.random().toString(36).substr(2, 9);
        
        console.log(`👤 Created person: ${this.firstName} ${this.lastName}`);
    }
    
    // Instance methods (added to prototype automatically)
    calcAge() {
        const age = 2024 - this.birthYear;
        console.log(`${this.firstName} is ${age} years old`);
        return age;
    }
    
    greet() {
        console.log(`Hello! I'm ${this.firstName} ${this.lastName}`);
    }
    
    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    
    // Method with parameters
    introduce(context = 'everyone') {
        console.log(`Hi ${context}, I'm ${this.getFullName()} and I'm ${this.calcAge()} years old`);
    }
    
    // Static method (belongs to class, not instances)
    static createFromString(personString) {
        const [firstName, lastName, birthYear] = personString.split(',');
        return new Person(firstName.trim(), lastName.trim(), parseInt(birthYear.trim()));
    }
    
    static compareAges(person1, person2) {
        const age1 = 2024 - person1.birthYear;
        const age2 = 2024 - person2.birthYear;
        
        if (age1 > age2) {
            return `${person1.getFullName()} is older than ${person2.getFullName()}`;
        } else if (age2 > age1) {
            return `${person2.getFullName()} is older than ${person1.getFullName()}`;
        } else {
            return `${person1.getFullName()} and ${person2.getFullName()} are the same age`;
        }
    }
}

/**
 * Using ES6 Classes
 */

console.log('\n👥 Creating Person Instances:');

const alice = new Person('Alice', 'Johnson', 1990);
const bob = new Person('Bob', 'Smith', 1985);

// Using instance methods
alice.greet();
bob.introduce('Alice');

// Using static methods
console.log('\n🔧 Using Static Methods:');
const charlie = Person.createFromString('Charlie, Brown, 1992');
charlie.greet();

console.log(Person.compareAges(alice, bob));

/**
 * Getters and Setters
 */

console.log('\n🔧 Getters and Setters:');

class BankAccount {
    constructor(owner, initialBalance = 0) {
        this.owner = owner;
        this._balance = initialBalance; // Private by convention
        this._transactions = [];
    }
    
    // Getter - access like a property
    get balance() {
        return this._balance;
    }
    
    // Getter for computed property
    get formattedBalance() {
        return `$${this._balance.toFixed(2)}`;
    }
    
    // Setter - set like a property but with validation
    set balance(amount) {
        if (amount < 0) {
            throw new Error('Balance cannot be negative');
        }
        this._balance = amount;
    }
    
    // Getter for transaction history
    get transactionHistory() {
        return [...this._transactions]; // Return copy, not original
    }
    
    // Methods for account operations
    deposit(amount) {
        if (amount <= 0) {
            throw new Error('Deposit amount must be positive');
        }
        
        this._balance += amount;
        this._transactions.push({
            type: 'deposit',
            amount,
            date: new Date(),
            balance: this._balance
        });
        
        console.log(`💰 Deposited ${this.formattedBalance.replace('$', '$')}${amount}. New balance: ${this.formattedBalance}`);
    }
    
    withdraw(amount) {
        if (amount <= 0) {
            throw new Error('Withdrawal amount must be positive');
        }
        
        if (amount > this._balance) {
            throw new Error('Insufficient funds');
        }
        
        this._balance -= amount;
        this._transactions.push({
            type: 'withdrawal',
            amount,
            date: new Date(),
            balance: this._balance
        });
        
        console.log(`💸 Withdrew $${amount}. New balance: ${this.formattedBalance}`);
    }
}

// Demonstrate getters and setters
const account = new BankAccount('Alice Johnson', 1000);

console.log(`Initial balance: ${account.formattedBalance}`); // Using getter
console.log(`Raw balance: ${account.balance}`); // Using getter

account.deposit(500);
account.withdraw(200);

// Using setter (with validation)
try {
    account.balance = -100; // This will throw an error
} catch (error) {
    console.log(`❌ Setter validation: ${error.message}`);
}

console.log('Transaction history:', account.transactionHistory);

/**
 * Class Inheritance with 'extends'
 */

console.log('\n🧬 Class Inheritance with "extends":');

// Parent class
class Vehicle {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.isRunning = false;
        this.speed = 0;
    }
    
    start() {
        this.isRunning = true;
        console.log(`🚗 ${this.make} ${this.model} started`);
    }
    
    stop() {
        this.isRunning = false;
        this.speed = 0;
        console.log(`🛑 ${this.make} ${this.model} stopped`);
    }
    
    accelerate(amount) {
        if (!this.isRunning) {
            console.log('Cannot accelerate - vehicle not running');
            return;
        }
        
        this.speed += amount;
        console.log(`🚀 ${this.make} ${this.model} accelerated to ${this.speed} mph`);
    }
    
    getInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
}

// Child class extending Vehicle
class Car extends Vehicle {
    constructor(make, model, year, doors, fuelType) {
        // Call parent constructor with 'super'
        super(make, model, year);
        
        // Add car-specific properties
        this.doors = doors;
        this.fuelType = fuelType;
        this.trunkOpen = false;
    }
    
    // Car-specific methods
    openTrunk() {
        this.trunkOpen = true;
        console.log(`🚗 ${this.make} ${this.model} trunk opened`);
    }
    
    closeTrunk() {
        this.trunkOpen = false;
        console.log(`🚗 ${this.make} ${this.model} trunk closed`);
    }
    
    // Override parent method
    accelerate(amount) {
        if (!this.isRunning) {
            console.log('Cannot accelerate - car not running');
            return;
        }
        
        // Cars have speed limits
        const maxSpeed = 120;
        this.speed = Math.min(this.speed + amount, maxSpeed);
        console.log(`🚗 Car accelerated to ${this.speed} mph (max: ${maxSpeed})`);
    }
    
    // Override getInfo to include car-specific details
    getInfo() {
        return `${super.getInfo()} - ${this.doors} doors, ${this.fuelType}`;
    }
}

// Electric car extending Car
class ElectricCar extends Car {
    constructor(make, model, year, doors, batteryCapacity) {
        super(make, model, year, doors, 'Electric');
        this.batteryCapacity = batteryCapacity;
        this.currentCharge = batteryCapacity; // Start fully charged
    }
    
    // Electric car specific methods
    charge(amount) {
        const oldCharge = this.currentCharge;
        this.currentCharge = Math.min(this.currentCharge + amount, this.batteryCapacity);
        const actualCharge = this.currentCharge - oldCharge;
        
        console.log(`🔋 Charged ${actualCharge} kWh. Battery: ${this.currentCharge}/${this.batteryCapacity} kWh`);
    }
    
    get batteryPercentage() {
        return Math.round((this.currentCharge / this.batteryCapacity) * 100);
    }
    
    // Override accelerate to account for battery usage
    accelerate(amount) {
        if (!this.isRunning) {
            console.log('Cannot accelerate - car not running');
            return;
        }
        
        if (this.currentCharge <= 0) {
            console.log('Cannot accelerate - battery depleted');
            return;
        }
        
        // Electric cars accelerate faster but use battery
        const maxSpeed = 150;
        this.speed = Math.min(this.speed + amount * 1.2, maxSpeed);
        this.currentCharge = Math.max(this.currentCharge - 0.5, 0);
        
        console.log(`⚡ Electric car accelerated to ${this.speed} mph. Battery: ${this.batteryPercentage}%`);
    }
    
    getInfo() {
        return `${super.getInfo()} - Battery: ${this.batteryPercentage}%`;
    }
}

// Demonstrate inheritance
console.log('\n🚗 Vehicle Inheritance Demo:');

const regularCar = new Car('Toyota', 'Camry', 2023, 4, 'Gasoline');
const electricCar = new ElectricCar('Tesla', 'Model 3', 2023, 4, 75);

console.log('\n🔧 Regular Car:');
console.log(regularCar.getInfo());
regularCar.start();
regularCar.accelerate(30);
regularCar.openTrunk();

console.log('\n⚡ Electric Car:');
console.log(electricCar.getInfo());
electricCar.start();
electricCar.accelerate(30);
electricCar.accelerate(40);
electricCar.charge(10);

/**
 * Class vs Constructor Function Comparison
 */

console.log('\n📊 Class vs Constructor Function:');

// Constructor function approach
function PersonConstructor(name, age) {
    this.name = name;
    this.age = age;
}

PersonConstructor.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

// ES6 class approach
class PersonClass {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }
}

const person1 = new PersonConstructor('John', 30);
const person2 = new PersonClass('Jane', 25);

console.log('Both create similar objects:');
console.log('Constructor function person:', person1);
console.log('Class person:', person2);

// They work the same way under the hood
console.log('Same prototype mechanism:', person1.__proto__.constructor === PersonConstructor);
console.log('Same prototype mechanism:', person2.__proto__.constructor === PersonClass);

console.log('\n💡 ES6 Classes Key Points:');
console.log('✅ Cleaner, more readable syntax');
console.log('✅ Built-in inheritance with extends/super');
console.log('✅ Static methods and getters/setters');
console.log('✅ Better tooling and IDE support');
console.log('⚠️ Still uses prototypes under the hood');
console.log('⚠️ Hoisting behavior different from functions');
console.log('⚠️ Always executed in strict mode');
```---


## 🔒 Encapsulation: Private Fields and Methods

Modern JavaScript provides true privacy through private fields and methods, moving beyond the convention-based approach of prefixing with underscores.

### Modern Encapsulation with Private Fields

```javascript
/**
 * MODERN ENCAPSULATION: TRUE PRIVACY IN JAVASCRIPT
 * 
 * Private fields and methods (ES2022):
 * - Truly private (not accessible from outside)
 * - Declared with # prefix
 * - Compile-time enforcement
 * - Better encapsulation than convention-based approaches
 */

console.log('=== Modern Encapsulation with Private Fields ===');

/**
 * Complete Banking System with True Privacy
 */

class SecureBankAccount {
    // Private fields - truly inaccessible from outside
    #balance;
    #accountNumber;
    #pin;
    #transactionHistory = [];
    #isLocked = false;
    #failedAttempts = 0;
    
    // Public field
    accountHolder;
    
    constructor(accountHolder, initialBalance, pin) {
        // Validate inputs
        if (!accountHolder || typeof initialBalance !== 'number' || !pin) {
            throw new Error('Invalid account parameters');
        }
        
        if (initialBalance < 0) {
            throw new Error('Initial balance cannot be negative');
        }
        
        if (pin.toString().length !== 4) {
            throw new Error('PIN must be 4 digits');
        }
        
        // Set public property
        this.accountHolder = accountHolder;
        
        // Set private fields
        this.#balance = initialBalance;
        this.#pin = pin;
        this.#accountNumber = this.#generateAccountNumber();
        
        // Log account creation
        this.#logTransaction('ACCOUNT_CREATED', initialBalance, 'Account opened');
        
        console.log(`🏦 Secure account created for ${accountHolder}`);
        console.log(`📊 Account number: ${this.getAccountNumber()}`);
    }
    
    // Public methods (API)
    
    /**
     * Authenticate user with PIN
     */
    authenticate(pin) {
        if (this.#isLocked) {
            console.log('❌ Account is locked due to multiple failed attempts');
            return false;
        }
        
        if (pin === this.#pin) {
            this.#failedAttempts = 0;
            console.log('✅ Authentication successful');
            return true;
        } else {
            this.#failedAttempts++;
            console.log(`❌ Invalid PIN. Attempts: ${this.#failedAttempts}/3`);
            
            if (this.#failedAttempts >= 3) {
                this.#isLocked = true;
                console.log('🔒 Account locked due to multiple failed attempts');
            }
            
            return false;
        }
    }
    
    /**
     * Get account balance (requires authentication)
     */
    getBalance(pin) {
        if (!this.authenticate(pin)) {
            return null;
        }
        
        console.log(`💰 Current balance: $${this.#balance.toFixed(2)}`);
        return this.#balance;
    }
    
    /**
     * Deposit money
     */
    deposit(amount, pin) {
        if (!this.authenticate(pin)) {
            return false;
        }
        
        if (!this.#validateAmount(amount)) {
            return false;
        }
        
        this.#balance += amount;
        this.#logTransaction('DEPOSIT', amount, `Deposit of $${amount}`);
        
        console.log(`✅ Deposited $${amount}. New balance: $${this.#balance.toFixed(2)}`);
        return true;
    }
    
    /**
     * Withdraw money
     */
    withdraw(amount, pin) {
        if (!this.authenticate(pin)) {
            return false;
        }
        
        if (!this.#validateAmount(amount)) {
            return false;
        }
        
        if (amount > this.#balance) {
            console.log('❌ Insufficient funds');
            return false;
        }
        
        this.#balance -= amount;
        this.#logTransaction('WITHDRAWAL', -amount, `Withdrawal of $${amount}`);
        
        console.log(`✅ Withdrew $${amount}. New balance: $${this.#balance.toFixed(2)}`);
        return true;
    }
    
    /**
     * Transfer money to another account
     */
    transfer(amount, targetAccount, pin) {
        if (!this.authenticate(pin)) {
            return false;
        }
        
        if (this.withdraw(amount, pin)) {
            // In a real system, this would be more complex with transaction rollback
            console.log(`💸 Transferring $${amount} to ${targetAccount.accountHolder}`);
            return targetAccount.deposit(amount, targetAccount.#pin); // Direct deposit for demo
        }
        
        return false;
    }
    
    /**
     * Get transaction history (requires authentication)
     */
    getTransactionHistory(pin) {
        if (!this.authenticate(pin)) {
            return null;
        }
        
        console.log('📋 Transaction History:');
        this.#transactionHistory.forEach((transaction, index) => {
            console.log(`${index + 1}. ${transaction.date.toLocaleString()} - ${transaction.type}: $${Math.abs(transaction.amount).toFixed(2)} - ${transaction.description}`);
        });
        
        return [...this.#transactionHistory]; // Return copy
    }
    
    /**
     * Get account number (masked for security)
     */
    getAccountNumber() {
        const masked = this.#accountNumber.slice(0, 4) + '****' + this.#accountNumber.slice(-4);
        return masked;
    }
    
    /**
     * Change PIN (requires old PIN)
     */
    changePin(oldPin, newPin) {
        if (!this.authenticate(oldPin)) {
            return false;
        }
        
        if (newPin.toString().length !== 4) {
            console.log('❌ New PIN must be 4 digits');
            return false;
        }
        
        this.#pin = newPin;
        this.#logTransaction('PIN_CHANGE', 0, 'PIN changed successfully');
        console.log('✅ PIN changed successfully');
        return true;
    }
    
    // Private methods - truly inaccessible from outside
    
    #generateAccountNumber() {
        // Generate a random 12-digit account number
        return Math.random().toString().slice(2, 14);
    }
    
    #validateAmount(amount) {
        if (typeof amount !== 'number' || amount <= 0) {
            console.log('❌ Invalid amount. Must be a positive number');
            return false;
        }
        
        if (amount > 10000) {
            console.log('❌ Amount exceeds daily limit of $10,000');
            return false;
        }
        
        return true;
    }
    
    #logTransaction(type, amount, description) {
        this.#transactionHistory.push({
            date: new Date(),
            type,
            amount,
            description,
            balance: this.#balance
        });
    }
    
    // Static method for creating accounts
    static createAccount(accountHolder, initialBalance, pin) {
        try {
            return new SecureBankAccount(accountHolder, initialBalance, pin);
        } catch (error) {
            console.error('❌ Failed to create account:', error.message);
            return null;
        }
    }
}

/**
 * Demonstration of Secure Banking System
 */

console.log('\n🏦 Secure Banking System Demo:');

// Create accounts
const aliceAccount = SecureBankAccount.createAccount('Alice Johnson', 5000, 1234);
const bobAccount = SecureBankAccount.createAccount('Bob Smith', 3000, 5678);

if (aliceAccount && bobAccount) {
    console.log('\n💳 Testing Account Operations:');
    
    // Test authentication
    console.log('\n🔐 Authentication Tests:');
    aliceAccount.getBalance(1111); // Wrong PIN
    aliceAccount.getBalance(1234); // Correct PIN
    
    // Test transactions
    console.log('\n💰 Transaction Tests:');
    aliceAccount.deposit(500, 1234);
    aliceAccount.withdraw(200, 1234);
    
    // Test transfer
    console.log('\n💸 Transfer Test:');
    aliceAccount.transfer(1000, bobAccount, 1234);
    
    // Check balances
    console.log('\n📊 Final Balances:');
    aliceAccount.getBalance(1234);
    bobAccount.getBalance(5678);
    
    // Test transaction history
    console.log('\n📋 Alice\'s Transaction History:');
    aliceAccount.getTransactionHistory(1234);
    
    // Test PIN change
    console.log('\n🔑 PIN Change Test:');
    aliceAccount.changePin(1234, 9999);
    aliceAccount.getBalance(9999); // Test new PIN
}

/**
 * Privacy Demonstration - Try to access private fields
 */

console.log('\n🔒 Privacy Demonstration:');

if (aliceAccount) {
    console.log('Trying to access private fields from outside...');
    
    try {
        console.log('aliceAccount.#balance:', aliceAccount.#balance);
    } catch (error) {
        console.log('❌ Cannot access #balance:', error.message);
    }
    
    try {
        console.log('aliceAccount.#pin:', aliceAccount.#pin);
    } catch (error) {
        console.log('❌ Cannot access #pin:', error.message);
    }
    
    try {
        aliceAccount.#logTransaction('HACK', 1000000, 'Hacking attempt');
    } catch (error) {
        console.log('❌ Cannot call private method #logTransaction:', error.message);
    }
    
    // Public properties are still accessible
    console.log('✅ Can access public property accountHolder:', aliceAccount.accountHolder);
}

/**
 * Advanced Encapsulation Patterns
 */

console.log('\n🎯 Advanced Encapsulation Patterns:');

class SmartDevice {
    // Private fields for device state
    #deviceId;
    #isOnline = false;
    #batteryLevel = 100;
    #settings = {};
    #eventListeners = new Map();
    
    // Public fields
    name;
    model;
    
    constructor(name, model) {
        this.name = name;
        this.model = model;
        this.#deviceId = this.#generateDeviceId();
        
        // Start device monitoring
        this.#startMonitoring();
        
        console.log(`📱 Smart device created: ${name} (${model})`);
    }
    
    // Public API
    
    turnOn() {
        if (this.#isOnline) {
            console.log(`${this.name} is already on`);
            return;
        }
        
        this.#isOnline = true;
        this.#emit('deviceOn', { deviceId: this.#deviceId });
        console.log(`✅ ${this.name} turned on`);
    }
    
    turnOff() {
        if (!this.#isOnline) {
            console.log(`${this.name} is already off`);
            return;
        }
        
        this.#isOnline = false;
        this.#emit('deviceOff', { deviceId: this.#deviceId });
        console.log(`❌ ${this.name} turned off`);
    }
    
    getBatteryLevel() {
        return this.#batteryLevel;
    }
    
    getStatus() {
        return {
            name: this.name,
            model: this.model,
            isOnline: this.#isOnline,
            batteryLevel: this.#batteryLevel,
            deviceId: this.#deviceId.slice(0, 8) + '...' // Masked ID
        };
    }
    
    updateSetting(key, value) {
        this.#settings[key] = value;
        this.#emit('settingChanged', { key, value });
        console.log(`⚙️ Setting updated: ${key} = ${value}`);
    }
    
    getSetting(key) {
        return this.#settings[key];
    }
    
    // Event system
    addEventListener(event, callback) {
        if (!this.#eventListeners.has(event)) {
            this.#eventListeners.set(event, []);
        }
        this.#eventListeners.get(event).push(callback);
    }
    
    removeEventListener(event, callback) {
        const listeners = this.#eventListeners.get(event);
        if (listeners) {
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }
    
    // Private methods
    
    #generateDeviceId() {
        return 'device_' + Math.random().toString(36).substr(2, 16);
    }
    
    #emit(event, data) {
        const listeners = this.#eventListeners.get(event) || [];
        listeners.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error('Event listener error:', error);
            }
        });
    }
    
    #startMonitoring() {
        // Simulate battery drain
        setInterval(() => {
            if (this.#isOnline && this.#batteryLevel > 0) {
                this.#batteryLevel = Math.max(0, this.#batteryLevel - 1);
                
                if (this.#batteryLevel === 0) {
                    this.#isOnline = false;
                    this.#emit('batteryDepleted', { deviceId: this.#deviceId });
                    console.log(`🔋 ${this.name} battery depleted - device turned off`);
                }
            }
        }, 2000); // Drain 1% every 2 seconds for demo
    }
    
    // Static factory method
    static createSmartPhone(name) {
        return new SmartDevice(name, 'SmartPhone Pro');
    }
    
    static createSmartWatch(name) {
        return new SmartDevice(name, 'SmartWatch Elite');
    }
}

// Demonstrate advanced encapsulation
console.log('\n📱 Smart Device Demo:');

const phone = SmartDevice.createSmartPhone('My iPhone');
const watch = SmartDevice.createSmartWatch('My Apple Watch');

// Set up event listeners
phone.addEventListener('deviceOn', (data) => {
    console.log('📱 Phone turned on event received');
});

phone.addEventListener('batteryDepleted', (data) => {
    console.log('🔋 Phone battery depleted event received');
});

// Test device operations
phone.turnOn();
phone.updateSetting('brightness', 80);
phone.updateSetting('volume', 50);

console.log('Phone status:', phone.getStatus());
console.log('Phone brightness setting:', phone.getSetting('brightness'));

// Watch the battery drain (will turn off automatically when depleted)
console.log('🔋 Monitoring battery drain...');

console.log('\n💡 Modern Encapsulation Benefits:');
console.log('✅ True privacy - fields/methods are genuinely inaccessible');
console.log('✅ Compile-time enforcement - errors caught early');
console.log('✅ Better IDE support - autocomplete knows what\'s private');
console.log('✅ Cleaner API - only public interface is visible');
console.log('✅ Security - sensitive data cannot be accessed externally');
console.log('✅ Maintainability - internal changes don\'t affect external code');
```

---

## 🔗 Method Chaining and Fluent Interfaces

Method chaining allows you to call multiple methods on the same object in a single statement, creating more readable and expressive code.

### Implementing Method Chaining

```javascript
/**
 * METHOD CHAINING: CREATING FLUENT INTERFACES
 * 
 * Method chaining enables:
 * - More readable and expressive code
 * - Fluent interfaces that read like natural language
 * - Reduced intermediate variables
 * - Better developer experience
 * 
 * Key principle: Return 'this' from methods to enable chaining
 */

console.log('=== Method Chaining and Fluent Interfaces ===');

/**
 * Example 1: Chainable Calculator
 */

class Calculator {
    constructor(initialValue = 0) {
        this.value = initialValue;
        this.history = [];
        console.log(`🧮 Calculator initialized with value: ${initialValue}`);
    }
    
    // Arithmetic operations (return this for chaining)
    add(number) {
        this.#logOperation('add', number, this.value);
        this.value += number;
        return this; // Enable chaining
    }
    
    subtract(number) {
        this.#logOperation('subtract', number, this.value);
        this.value -= number;
        return this;
    }
    
    multiply(number) {
        this.#logOperation('multiply', number, this.value);
        this.value *= number;
        return this;
    }
    
    divide(number) {
        if (number === 0) {
            throw new Error('Cannot divide by zero');
        }
        this.#logOperation('divide', number, this.value);
        this.value /= number;
        return this;
    }
    
    power(exponent) {
        this.#logOperation('power', exponent, this.value);
        this.value = Math.pow(this.value, exponent);
        return this;
    }
    
    sqrt() {
        if (this.value < 0) {
            throw new Error('Cannot take square root of negative number');
        }
        this.#logOperation('sqrt', null, this.value);
        this.value = Math.sqrt(this.value);
        return this;
    }
    
    // Utility methods
    round(decimals = 0) {
        this.value = Number(this.value.toFixed(decimals));
        return this;
    }
    
    abs() {
        this.value = Math.abs(this.value);
        return this;
    }
    
    // Terminal methods (end the chain)
    getValue() {
        return this.value;
    }
    
    getResult() {
        console.log(`📊 Final result: ${this.value}`);
        return this.value;
    }
    
    getHistory() {
        console.log('📋 Calculation History:');
        this.history.forEach((entry, index) => {
            console.log(`  ${index + 1}. ${entry}`);
        });
        return this.history;
    }
    
    reset() {
        this.value = 0;
        this.history = [];
        console.log('🔄 Calculator reset');
        return this;
    }
    
    // Private method for logging
    #logOperation(operation, operand, previousValue) {
        let description;
        if (operand !== null) {
            description = `${operation}(${operand}): ${previousValue} → ${this.value}`;
        } else {
            description = `${operation}(): ${previousValue} → ${this.value}`;
        }
        this.history.push(description);
    }
}

// Demonstrate method chaining
console.log('\n🧮 Calculator Method Chaining Demo:');

const calc = new Calculator(10);

// Chain multiple operations
const result = calc
    .add(5)           // 10 + 5 = 15
    .multiply(2)      // 15 * 2 = 30
    .subtract(10)     // 30 - 10 = 20
    .divide(4)        // 20 / 4 = 5
    .power(2)         // 5^2 = 25
    .sqrt()           // √25 = 5
    .round(2)         // Round to 2 decimals
    .getResult();     // Terminal method

calc.getHistory();

/**
 * Example 2: Fluent Query Builder
 */

console.log('\n🔍 Fluent Query Builder:');

class QueryBuilder {
    constructor() {
        this.query = {
            select: [],
            from: '',
            where: [],
            orderBy: [],
            limit: null,
            offset: null
        };
    }
    
    // SELECT clause
    select(...fields) {
        this.query.select.push(...fields);
        return this;
    }
    
    // FROM clause
    from(table) {
        this.query.from = table;
        return this;
    }
    
    // WHERE clause
    where(condition) {
        this.query.where.push(condition);
        return this;
    }
    
    // AND condition (alias for where)
    and(condition) {
        return this.where(condition);
    }
    
    // OR condition
    or(condition) {
        if (this.query.where.length > 0) {
            const lastCondition = this.query.where.pop();
            this.query.where.push(`(${lastCondition} OR ${condition})`);
        } else {
            this.query.where.push(condition);
        }
        return this;
    }
    
    // ORDER BY clause
    orderBy(field, direction = 'ASC') {
        this.query.orderBy.push(`${field} ${direction}`);
        return this;
    }
    
    // LIMIT clause
    limit(count) {
        this.query.limit = count;
        return this;
    }
    
    // OFFSET clause
    offset(count) {
        this.query.offset = count;
        return this;
    }
    
    // Terminal method - build the SQL
    build() {
        let sql = '';
        
        // SELECT
        if (this.query.select.length > 0) {
            sql += `SELECT ${this.query.select.join(', ')}`;
        } else {
            sql += 'SELECT *';
        }
        
        // FROM
        if (this.query.from) {
            sql += ` FROM ${this.query.from}`;
        }
        
        // WHERE
        if (this.query.where.length > 0) {
            sql += ` WHERE ${this.query.where.join(' AND ')}`;
        }
        
        // ORDER BY
        if (this.query.orderBy.length > 0) {
            sql += ` ORDER BY ${this.query.orderBy.join(', ')}`;
        }
        
        // LIMIT
        if (this.query.limit !== null) {
            sql += ` LIMIT ${this.query.limit}`;
        }
        
        // OFFSET
        if (this.query.offset !== null) {
            sql += ` OFFSET ${this.query.offset}`;
        }
        
        return sql;
    }
    
    // Terminal method - execute (simulated)
    execute() {
        const sql = this.build();
        console.log(`🗄️ Executing SQL: ${sql}`);
        
        // Simulate execution result
        return {
            sql: sql,
            rows: Math.floor(Math.random() * 100),
            executionTime: Math.random() * 100
        };
    }
    
    // Reset for reuse
    reset() {
        this.query = {
            select: [],
            from: '',
            where: [],
            orderBy: [],
            limit: null,
            offset: null
        };
        return this;
    }
}

// Demonstrate fluent query building
const query = new QueryBuilder();

const result1 = query
    .select('id', 'name', 'email')
    .from('users')
    .where('age > 18')
    .and('status = "active"')
    .orderBy('name', 'ASC')
    .limit(10)
    .execute();

console.log('Query result:', result1);

// Build another query with the same builder
const result2 = query
    .reset()
    .select('product_name', 'price')
    .from('products')
    .where('category = "electronics"')
    .or('category = "computers"')
    .orderBy('price', 'DESC')
    .limit(5)
    .execute();

console.log('Second query result:', result2);

/**
 * Example 3: Fluent Animation Builder
 */

console.log('\n🎬 Fluent Animation Builder:');

class AnimationBuilder {
    constructor(element) {
        this.element = element;
        this.animations = [];
        this.duration = 1000; // Default duration
        this.easing = 'ease'; // Default easing
    }
    
    // Transform methods
    translateX(value) {
        this.animations.push(`translateX(${value}px)`);
        return this;
    }
    
    translateY(value) {
        this.animations.push(`translateY(${value}px)`);
        return this;
    }
    
    rotate(degrees) {
        this.animations.push(`rotate(${degrees}deg)`);
        return this;
    }
    
    scale(factor) {
        this.animations.push(`scale(${factor})`);
        return this;
    }
    
    // Style methods
    opacity(value) {
        this.animations.push({ opacity: value });
        return this;
    }
    
    backgroundColor(color) {
        this.animations.push({ backgroundColor: color });
        return this;
    }
    
    // Animation configuration
    duration(ms) {
        this.duration = ms;
        return this;
    }
    
    easing(easingFunction) {
        this.easing = easingFunction;
        return this;
    }
    
    // Terminal method - execute animation
    animate() {
        console.log(`🎬 Animating element with ${this.animations.length} properties`);
        
        // Separate transforms from other styles
        const transforms = this.animations.filter(anim => typeof anim === 'string');
        const styles = this.animations.filter(anim => typeof anim === 'object');
        
        // Apply transform
        if (transforms.length > 0) {
            console.log(`   Transform: ${transforms.join(' ')}`);
        }
        
        // Apply styles
        styles.forEach(style => {
            Object.entries(style).forEach(([prop, value]) => {
                console.log(`   ${prop}: ${value}`);
            });
        });
        
        console.log(`   Duration: ${this.duration}ms, Easing: ${this.easing}`);
        
        // In a real implementation, this would apply CSS transitions/animations
        return new Promise(resolve => {
            setTimeout(() => {
                console.log('✅ Animation completed');
                resolve(this);
            }, 100); // Simulate animation time
        });
    }
    
    // Reset for reuse
    reset() {
        this.animations = [];
        this.duration = 1000;
        this.easing = 'ease';
        return this;
    }
}

// Demonstrate fluent animation
const animationBuilder = new AnimationBuilder('myElement');

animationBuilder
    .translateX(100)
    .translateY(50)
    .rotate(45)
    .scale(1.2)
    .opacity(0.8)
    .backgroundColor('blue')
    .duration(2000)
    .easing('ease-in-out')
    .animate()
    .then(() => {
        console.log('🎉 Animation chain completed!');
        
        // Chain another animation
        return animationBuilder
            .reset()
            .translateX(0)
            .translateY(0)
            .rotate(0)
            .scale(1)
            .opacity(1)
            .duration(1000)
            .animate();
    })
    .then(() => {
        console.log('🏁 Return animation completed!');
    });

/**
 * Best Practices for Method Chaining
 */

console.log('\n📋 Method Chaining Best Practices:');

class BestPracticesExample {
    constructor() {
        this.data = [];
        this.config = {};
    }
    
    // ✅ Good: Always return this for chainable methods
    addItem(item) {
        this.data.push(item);
        return this; // Enables chaining
    }
    
    // ✅ Good: Provide both chainable and non-chainable versions
    setConfig(key, value) {
        this.config[key] = value;
        return this; // Chainable version
    }
    
    getConfig(key) {
        return this.config[key]; // Non-chainable (returns value)
    }
    
    // ✅ Good: Validate parameters and provide meaningful errors
    setLimit(limit) {
        if (typeof limit !== 'number' || limit < 0) {
            throw new Error('Limit must be a non-negative number');
        }
        this.config.limit = limit;
        return this;
    }
    
    // ✅ Good: Provide terminal methods that end the chain
    execute() {
        console.log('Executing with data:', this.data);
        console.log('Config:', this.config);
        return { success: true, processedItems: this.data.length };
    }
    
    // ✅ Good: Allow method chaining to be optional
    process(callback) {
        if (callback) {
            callback(this.data);
        }
        return this; // Still chainable even with callback
    }
}

console.log('\n✅ Best Practices Demo:');

const example = new BestPracticesExample();

// Fluent interface usage
const result = example
    .addItem('item1')
    .addItem('item2')
    .setConfig('debug', true)
    .setLimit(10)
    .process(data => console.log('Processing:', data.length, 'items'))
    .execute();

console.log('Final result:', result);

console.log('\n💡 Method Chaining Guidelines:');
console.log('✅ Return "this" from methods that modify the object');
console.log('✅ Return actual values from getter methods');
console.log('✅ Provide terminal methods that end the chain meaningfully');
console.log('✅ Validate parameters and provide clear error messages');
console.log('✅ Consider providing both chainable and non-chainable APIs');
console.log('✅ Document which methods are chainable');
console.log('⚠️ Don\'t force chaining where it doesn\'t make sense');
console.log('⚠️ Avoid overly long chains that hurt readability');
```

---

## 🎯 Real-World OOP: Complete Project Example

Let's build a comprehensive task management system that demonstrates all OOP principles in a practical, real-world context.

### Task Management System

```javascript
/**
 * REAL-WORLD OOP PROJECT: TASK MANAGEMENT SYSTEM
 * 
 * This comprehensive example demonstrates:
 * - All four OOP principles (Abstraction, Encapsulation, Inheritance, Polymorphism)
 * - Modern JavaScript features (private fields, static methods, getters/setters)
 * - Design patterns (Observer, Factory, Strategy)
 * - Method chaining and fluent interfaces
 * - Error handling and validation
 * - Event-driven architecture
 */

console.log('=== Task Management System: Complete OOP Project ===');

/**
 * Base Task Class - Demonstrates Abstraction and Encapsulation
 */

class Task {
    // Private fields for true encapsulation
    #id;
    #createdAt;
    #updatedAt;
    #status = 'pending';
    #priority = 'medium';
    
    // Public fields
    title;
    description;
    
    // Static field for ID generation
    static #nextId = 1;
    
    constructor(title, description = '') {
        if (!title || title.trim().length === 0) {
            throw new Error('Task title is required');
        }
        
        this.title = title.trim();
        this.description = description.trim();
        this.#id = Task.#nextId++;
        this.#createdAt = new Date();
        this.#updatedAt = new Date();
        
        console.log(`📝 Task created: "${this.title}" (ID: ${this.#id})`);
    }
    
    // Getters for read-only access to private fields
    get id() {
        return this.#id;
    }
    
    get createdAt() {
        return new Date(this.#createdAt);
    }
    
    get updatedAt() {
        return new Date(this.#updatedAt);
    }
    
    get status() {
        return this.#status;
    }
    
    get priority() {
        return this.#priority;
    }
    
    // Setter with validation
    set priority(value) {
        const validPriorities = ['low', 'medium', 'high', 'urgent'];
        if (!validPriorities.includes(value)) {
            throw new Error(`Invalid priority. Must be one of: ${validPriorities.join(', ')}`);
        }
        this.#priority = value;
        this.#touch();
    }
    
    // Public methods
    
    /**
     * Update task status with validation
     */
    updateStatus(newStatus) {
        const validStatuses = ['pending', 'in-progress', 'completed', 'cancelled'];
        if (!validStatuses.includes(newStatus)) {
            throw new Error(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);
        }
        
        const oldStatus = this.#status;
        this.#status = newStatus;
        this.#touch();
        
        console.log(`📊 Task ${this.#id} status: ${oldStatus} → ${newStatus}`);
        return this;
    }
    
    /**
     * Update task details
     */
    update(updates) {
        if (updates.title !== undefined) {
            if (!updates.title || updates.title.trim().length === 0) {
                throw new Error('Task title cannot be empty');
            }
            this.title = updates.title.trim();
        }
        
        if (updates.description !== undefined) {
            this.description = updates.description.trim();
        }
        
        if (updates.priority !== undefined) {
            this.priority = updates.priority;
        }
        
        this.#touch();
        console.log(`✏️ Task ${this.#id} updated`);
        return this;
    }
    
    /**
     * Get task summary
     */
    getSummary() {
        return {
            id: this.#id,
            title: this.title,
            description: this.description,
            status: this.#status,
            priority: this.#priority,
            createdAt: this.#createdAt,
            updatedAt: this.#updatedAt
        };
    }
    
    /**
     * Check if task is overdue (to be overridden by subclasses)
     */
    isOverdue() {
        return false; // Base implementation
    }
    
    /**
     * Get time until due (to be overridden by subclasses)
     */
    getTimeUntilDue() {
        return null; // Base implementation
    }
    
    /**
     * Clone task
     */
    clone() {
        const cloned = new this.constructor(this.title, this.description);
        cloned.priority = this.#priority;
        return cloned;
    }
    
    // Private methods
    
    #touch() {
        this.#updatedAt = new Date();
    }
    
    // Static methods
    
    static createFromObject(obj) {
        const task = new Task(obj.title, obj.description);
        if (obj.priority) task.priority = obj.priority;
        if (obj.status) task.updateStatus(obj.status);
        return task;
    }
    
    static getValidStatuses() {
        return ['pending', 'in-progress', 'completed', 'cancelled'];
    }
    
    static getValidPriorities() {
        return ['low', 'medium', 'high', 'urgent'];
    }
}

/**
 * Scheduled Task - Demonstrates Inheritance
 */

class ScheduledTask extends Task {
    #dueDate;
    #reminderTime;
    
    constructor(title, description, dueDate) {
        super(title, description);
        
        if (!(dueDate instanceof Date)) {
            throw new Error('Due date must be a Date object');
        }
        
        if (dueDate <= new Date()) {
            throw new Error('Due date must be in the future');
        }
        
        this.#dueDate = new Date(dueDate);
        console.log(`⏰ Scheduled task created, due: ${this.#dueDate.toLocaleString()}`);
    }
    
    get dueDate() {
        return new Date(this.#dueDate);
    }
    
    set dueDate(date) {
        if (!(date instanceof Date)) {
            throw new Error('Due date must be a Date object');
        }
        
        if (date <= new Date()) {
            throw new Error('Due date must be in the future');
        }
        
        this.#dueDate = new Date(date);
        console.log(`📅 Due date updated to: ${this.#dueDate.toLocaleString()}`);
    }
    
    // Override parent method - Polymorphism
    isOverdue() {
        return new Date() > this.#dueDate && this.status !== 'completed';
    }
    
    // Override parent method - Polymorphism
    getTimeUntilDue() {
        const now = new Date();
        const timeDiff = this.#dueDate - now;
        
        if (timeDiff <= 0) {
            return { overdue: true, message: 'Task is overdue' };
        }
        
        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
        
        return {
            overdue: false,
            days,
            hours,
            minutes,
            message: `${days}d ${hours}h ${minutes}m remaining`
        };
    }
    
    setReminder(minutesBefore) {
        if (minutesBefore < 0) {
            throw new Error('Reminder time must be positive');
        }
        
        this.#reminderTime = minutesBefore;
        console.log(`⏰ Reminder set for ${minutesBefore} minutes before due date`);
        return this;
    }
    
    getReminder() {
        return this.#reminderTime;
    }
    
    // Override getSummary to include due date
    getSummary() {
        const baseSummary = super.getSummary();
        return {
            ...baseSummary,
            dueDate: this.#dueDate,
            isOverdue: this.isOverdue(),
            timeUntilDue: this.getTimeUntilDue()
        };
    }
}

/**
 * Recurring Task - Demonstrates Advanced Inheritance
 */

class RecurringTask extends ScheduledTask {
    #recurrencePattern;
    #nextDueDate;
    
    constructor(title, description, firstDueDate, recurrencePattern) {
        super(title, description, firstDueDate);
        
        const validPatterns = ['daily', 'weekly', 'monthly', 'yearly'];
        if (!validPatterns.includes(recurrencePattern)) {
            throw new Error(`Invalid recurrence pattern. Must be one of: ${validPatterns.join(', ')}`);
        }
        
        this.#recurrencePattern = recurrencePattern;
        this.#calculateNextDueDate();
        
        console.log(`🔄 Recurring task created with ${recurrencePattern} recurrence`);
    }
    
    get recurrencePattern() {
        return this.#recurrencePattern;
    }
    
    get nextDueDate() {
        return new Date(this.#nextDueDate);
    }
    
    // Complete and schedule next occurrence
    complete() {
        this.updateStatus('completed');
        this.#calculateNextDueDate();
        
        console.log(`✅ Recurring task completed. Next due: ${this.#nextDueDate.toLocaleString()}`);
        return this;
    }
    
    #calculateNextDueDate() {
        const current = this.dueDate;
        const next = new Date(current);
        
        switch (this.#recurrencePattern) {
            case 'daily':
                next.setDate(next.getDate() + 1);
                break;
            case 'weekly':
                next.setDate(next.getDate() + 7);
                break;
            case 'monthly':
                next.setMonth(next.getMonth() + 1);
                break;
            case 'yearly':
                next.setFullYear(next.getFullYear() + 1);
                break;
        }
        
        this.#nextDueDate = next;
    }
    
    getSummary() {
        const baseSummary = super.getSummary();
        return {
            ...baseSummary,
            recurrencePattern: this.#recurrencePattern,
            nextDueDate: this.#nextDueDate
        };
    }
}

/**
 * Task Manager - Demonstrates Composition and Observer Pattern
 */

class TaskManager {
    #tasks = new Map();
    #observers = [];
    #filters = {
        status: null,
        priority: null,
        overdue: null
    };
    
    constructor() {
        console.log('📋 Task Manager initialized');
    }
    
    // Task management methods
    
    addTask(task) {
        if (!(task instanceof Task)) {
            throw new Error('Only Task instances can be added');
        }
        
        this.#tasks.set(task.id, task);
        this.#notifyObservers('taskAdded', task);
        
        console.log(`➕ Task added to manager: ${task.title}`);
        return this;
    }
    
    removeTask(taskId) {
        const task = this.#tasks.get(taskId);
        if (!task) {
            throw new Error(`Task with ID ${taskId} not found`);
        }
        
        this.#tasks.delete(taskId);
        this.#notifyObservers('taskRemoved', task);
        
        console.log(`➖ Task removed: ${task.title}`);
        return this;
    }
    
    getTask(taskId) {
        return this.#tasks.get(taskId);
    }
    
    getAllTasks() {
        return Array.from(this.#tasks.values());
    }
    
    // Filtering methods (Method Chaining)
    
    filterByStatus(status) {
        this.#filters.status = status;
        return this;
    }
    
    filterByPriority(priority) {
        this.#filters.priority = priority;
        return this;
    }
    
    filterOverdue(overdue = true) {
        this.#filters.overdue = overdue;
        return this;
    }
    
    clearFilters() {
        this.#filters = { status: null, priority: null, overdue: null };
        return this;
    }
    
    // Terminal method for filtering
    getFilteredTasks() {
        let tasks = this.getAllTasks();
        
        if (this.#filters.status) {
            tasks = tasks.filter(task => task.status === this.#filters.status);
        }
        
        if (this.#filters.priority) {
            tasks = tasks.filter(task => task.priority === this.#filters.priority);
        }
        
        if (this.#filters.overdue !== null) {
            tasks = tasks.filter(task => task.isOverdue() === this.#filters.overdue);
        }
        
        return tasks;
    }
    
    // Bulk operations
    
    updateMultipleTasks(taskIds, updates) {
        const updatedTasks = [];
        
        taskIds.forEach(id => {
            const task = this.#tasks.get(id);
            if (task) {
                task.update(updates);
                updatedTasks.push(task);
            }
        });
        
        this.#notifyObservers('tasksUpdated', updatedTasks);
        console.log(`📝 Updated ${updatedTasks.length} tasks`);
        
        return this;
    }
    
    completeMultipleTasks(taskIds) {
        const completedTasks = [];
        
        taskIds.forEach(id => {
            const task = this.#tasks.get(id);
            if (task && task.status !== 'completed') {
                task.updateStatus('completed');
                completedTasks.push(task);
            }
        });
        
        this.#notifyObservers('tasksCompleted', completedTasks);
        console.log(`✅ Completed ${completedTasks.length} tasks`);
        
        return this;
    }
    
    // Statistics
    
    getStatistics() {
        const tasks = this.getAllTasks();
        const stats = {
            total: tasks.length,
            byStatus: {},
            byPriority: {},
            overdue: 0,
            completed: 0
        };
        
        tasks.forEach(task => {
            // Count by status
            stats.byStatus[task.status] = (stats.byStatus[task.status] || 0) + 1;
            
            // Count by priority
            stats.byPriority[task.priority] = (stats.byPriority[task.priority] || 0) + 1;
            
            // Count overdue
            if (task.isOverdue()) {
                stats.overdue++;
            }
            
            // Count completed
            if (task.status === 'completed') {
                stats.completed++;
            }
        });
        
        return stats;
    }
    
    // Observer pattern implementation
    
    addObserver(observer) {
        if (typeof observer !== 'function') {
            throw new Error('Observer must be a function');
        }
        this.#observers.push(observer);
        return this;
    }
    
    removeObserver(observer) {
        const index = this.#observers.indexOf(observer);
        if (index > -1) {
            this.#observers.splice(index, 1);
        }
        return this;
    }
    
    #notifyObservers(event, data) {
        this.#observers.forEach(observer => {
            try {
                observer(event, data);
            } catch (error) {
                console.error('Observer error:', error);
            }
        });
    }
    
    // Factory methods
    
    createTask(title, description) {
        const task = new Task(title, description);
        return this.addTask(task);
    }
    
    createScheduledTask(title, description, dueDate) {
        const task = new ScheduledTask(title, description, dueDate);
        return this.addTask(task);
    }
    
    createRecurringTask(title, description, firstDueDate, recurrencePattern) {
        const task = new RecurringTask(title, description, firstDueDate, recurrencePattern);
        return this.addTask(task);
    }
}

/**
 * Demonstration of the Complete System
 */

console.log('\n🚀 Task Management System Demo:');

// Create task manager
const taskManager = new TaskManager();

// Add observer for logging
taskManager.addObserver((event, data) => {
    console.log(`🔔 Event: ${event}`, data instanceof Array ? `(${data.length} items)` : `- ${data.title || data.id}`);
});

// Create various types of tasks
console.log('\n📝 Creating Tasks:');

// Regular tasks
taskManager.createTask('Review code', 'Review pull request #123');
taskManager.createTask('Write documentation', 'Update API documentation');

// Scheduled tasks
const tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);
tomorrow.setHours(14, 0, 0, 0);

const nextWeek = new Date();
nextWeek.setDate(nextWeek.getDate() + 7);
nextWeek.setHours(10, 0, 0, 0);

taskManager.createScheduledTask('Team meeting', 'Weekly team standup', tomorrow);
taskManager.createScheduledTask('Project deadline', 'Complete project deliverables', nextWeek);

// Recurring task
const dailyStandup = new Date();
dailyStandup.setDate(dailyStandup.getDate() + 1);
dailyStandup.setHours(9, 0, 0, 0);

taskManager.createRecurringTask('Daily standup', 'Daily team check-in', dailyStandup, 'daily');

// Demonstrate method chaining and filtering
console.log('\n🔍 Filtering and Operations:');

// Get all pending tasks
const pendingTasks = taskManager
    .clearFilters()
    .filterByStatus('pending')
    .getFilteredTasks();

console.log(`Found ${pendingTasks.length} pending tasks`);

// Update multiple tasks
const taskIds = pendingTasks.slice(0, 2).map(task => task.id);
taskManager.updateMultipleTasks(taskIds, { priority: 'high' });

// Get high priority tasks
const highPriorityTasks = taskManager
    .clearFilters()
    .filterByPriority('high')
    .getFilteredTasks();

console.log(`Found ${highPriorityTasks.length} high priority tasks`);

// Complete some tasks
taskManager.completeMultipleTasks([taskIds[0]]);

// Show statistics
console.log('\n📊 Task Statistics:');
const stats = taskManager.getStatistics();
console.log('Total tasks:', stats.total);
console.log('By status:', stats.byStatus);
console.log('By priority:', stats.byPriority);
console.log('Overdue tasks:', stats.overdue);
console.log('Completed tasks:', stats.completed);

// Demonstrate polymorphism
console.log('\n🎭 Polymorphism Demo:');
const allTasks = taskManager.getAllTasks();

allTasks.forEach(task => {
    console.log(`\nTask: ${task.title}`);
    console.log(`  Type: ${task.constructor.name}`);
    console.log(`  Status: ${task.status}`);
    console.log(`  Is overdue: ${task.isOverdue()}`);
    
    const timeInfo = task.getTimeUntilDue();
    if (timeInfo) {
        console.log(`  Time info: ${timeInfo.message}`);
    }
});

console.log('\n🎉 Task Management System Demo Complete!');

console.log('\n💡 OOP Principles Demonstrated:');
console.log('✅ Abstraction - Complex task management hidden behind simple API');
console.log('✅ Encapsulation - Private fields protect internal state');
console.log('✅ Inheritance - ScheduledTask and RecurringTask extend Task');
console.log('✅ Polymorphism - Same methods behave differently for different task types');
console.log('✅ Method Chaining - Fluent interface for filtering');
console.log('✅ Observer Pattern - Event-driven architecture');
console.log('✅ Factory Pattern - TaskManager creates different task types');
console.log('✅ Composition - TaskManager contains and manages tasks');
```

---

## 🎓 Summary and Best Practices

### Key Takeaways

```
🏆 OOP Mastery Checklist:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Understand the four pillars of OOP                      │
│ ✅ Master JavaScript's prototypal inheritance              │
│ ✅ Use ES6 classes for modern, clean syntax                │
│ ✅ Implement true encapsulation with private fields        │
│ ✅ Apply inheritance and polymorphism appropriately        │
│ ✅ Create fluent interfaces with method chaining           │
│ ✅ Follow OOP best practices and design patterns           │
│ ✅ Build real-world applications with OOP principles       │
└─────────────────────────────────────────────────────────────┘
```

### When to Use OOP in JavaScript

**✅ Use OOP when:**
- Building complex applications with multiple related entities
- Need to model real-world relationships and behaviors
- Working in teams where clear structure is important
- Creating reusable components or libraries
- Managing state and behavior together
- Need inheritance and polymorphism

**❌ Consider alternatives when:**
- Building simple, functional applications
- Working with data transformations (functional programming might be better)
- Performance is critical (functional approaches can be faster)
- The problem domain doesn't map well to objects

### Best Practices Summary

1. **Design Principles**
   - Favor composition over inheritance
   - Program to interfaces, not implementations
   - Keep classes focused and cohesive
   - Use dependency injection for flexibility

2. **Code Organization**
   - Use meaningful class and method names
   - Keep methods small and focused
   - Group related functionality together
   - Separate concerns appropriately

3. **Modern JavaScript**
   - Use ES6 classes for cleaner syntax
   - Implement true privacy with private fields
   - Leverage static methods for utilities
   - Use getters/setters for controlled access

4. **Performance Considerations**
   - Add methods to prototypes, not constructors
   - Be mindful of prototype chain depth
   - Use object pooling for frequently created objects
   - Consider memory usage with large object hierarchies

You've now mastered Object-Oriented Programming in JavaScript! These concepts will help you build scalable, maintainable applications with clean, organized code. 🚀