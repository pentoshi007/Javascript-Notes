# ğŸ—ï¸ 13. Object-Oriented Programming (OOP) With JavaScript

> **Master Object-Oriented Programming in JavaScript** - From fundamental concepts to advanced patterns, learn how to build scalable, maintainable applications using OOP principles.

---

## ğŸ¯ Learning Objectives

By the end of this comprehensive guide, you will master:

```
ğŸš€ OOP Mastery Roadmap:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Core OOP Principles (Abstraction, Encapsulation, etc.)   â”‚
â”‚ â€¢ JavaScript's Prototypal Inheritance System               â”‚
â”‚ â€¢ Constructor Functions vs ES6 Classes                     â”‚
â”‚ â€¢ Advanced Inheritance Patterns                            â”‚
â”‚ â€¢ Private Fields and Methods                               â”‚
â”‚ â€¢ Design Patterns and Best Practices                       â”‚
â”‚ â€¢ Real-World Application Architecture                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“š Prerequisites
- Solid understanding of JavaScript fundamentals
- Knowledge of functions, objects, and arrays
- Familiarity with `this` keyword and scope
- Basic understanding of prototypes

---

## ğŸ¤” What is Object-Oriented Programming?

**Object-Oriented Programming (OOP)** is a programming paradigm that organizes code around **objects** rather than functions and logic. It's based on the concept of "objects" which contain data (properties) and code (methods).

### Why Use OOP?

```
ğŸ¯ Benefits of Object-Oriented Programming:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Code Reusability - Write once, use many times           â”‚
â”‚ âœ… Modularity - Break complex problems into smaller parts   â”‚
â”‚ âœ… Maintainability - Easier to update and debug            â”‚
â”‚ âœ… Scalability - Better structure for large applications    â”‚
â”‚ âœ… Real-world Modeling - Mirror real-world relationships   â”‚
â”‚ âœ… Team Collaboration - Clear structure for multiple devs  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Classes and Instances: The Foundation

In traditional OOP, a **class** is like a blueprint or template, while an **instance** is an actual object created from that blueprint.

```javascript
/**
 * UNDERSTANDING CLASSES AND INSTANCES
 * 
 * Think of a class as a cookie cutter and instances as the actual cookies.
 * The cookie cutter (class) defines the shape and properties,
 * but each cookie (instance) is a separate, individual object.
 */

// Example: Real-world analogy
console.log('=== Classes vs Instances Analogy ===');

/**
 * CLASS: Car Blueprint
 * - Defines what properties a car should have (make, model, year)
 * - Defines what actions a car can perform (start, stop, accelerate)
 * - This is NOT an actual car, just the blueprint
 */

/**
 * INSTANCES: Actual Cars
 * - myCar = new Car('Toyota', 'Camry', 2023)
 * - yourCar = new Car('Honda', 'Civic', 2022)
 * - Each instance has its own unique property values
 * - Each can perform the same actions but with different results
 */

// Let's demonstrate this concept with a simple example
function demonstrateClassVsInstance() {
    console.log('\nğŸ—ï¸ Class vs Instance Demonstration:');
    
    // This is like our "blueprint" or "class" (we'll learn proper syntax later)
    function CarBlueprint(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.isRunning = false;
    }
    
    // Add methods to the blueprint
    CarBlueprint.prototype.start = function() {
        this.isRunning = true;
        console.log(`${this.make} ${this.model} is now running! ğŸš—`);
    };
    
    CarBlueprint.prototype.getInfo = function() {
        return `${this.year} ${this.make} ${this.model}`;
    };
    
    // Create instances (actual cars) from the blueprint
    const car1 = new CarBlueprint('Toyota', 'Camry', 2023);
    const car2 = new CarBlueprint('Honda', 'Civic', 2022);
    const car3 = new CarBlueprint('Ford', 'Mustang', 2024);
    
    console.log('ğŸ“‹ Created three car instances:');
    console.log(`Car 1: ${car1.getInfo()}`);
    console.log(`Car 2: ${car2.getInfo()}`);
    console.log(`Car 3: ${car3.getInfo()}`);
    
    // Each instance is independent
    car1.start(); // Only car1 starts
    console.log(`Car 1 running: ${car1.isRunning}`); // true
    console.log(`Car 2 running: ${car2.isRunning}`); // false
    
    // They share the same methods but have different data
    console.log('\nğŸ” Instance Independence:');
    console.log(`Same blueprint? ${car1.constructor === car2.constructor}`); // true
    console.log(`Same instance? ${car1 === car2}`); // false
    console.log(`Same methods? ${car1.start === car2.start}`); // true (shared via prototype)
}

demonstrateClassVsInstance();
```

---

## ğŸ›ï¸ The Four Pillars of OOP

Object-Oriented Programming is built on four fundamental principles. Let's explore each one with practical examples and understand **why** they matter.

### 1. ğŸ­ Abstraction

**Abstraction** means hiding complex implementation details and showing only the essential features of an object. It's like using a car - you don't need to understand how the engine works internally, you just need to know how to use the steering wheel, pedals, and gear shift.

```javascript
/**
 * ABSTRACTION: HIDING COMPLEXITY
 * 
 * Abstraction allows us to:
 * - Hide complex internal workings
 * - Provide simple interfaces for complex operations
 * - Focus on WHAT an object does, not HOW it does it
 * - Reduce cognitive load for developers using our code
 */

console.log('=== Abstraction Demonstration ===');

/**
 * Example: Email Service
 * Users don't need to know about SMTP protocols, server connections, etc.
 * They just want to send an email with a simple interface.
 */

class EmailService {
    constructor() {
        // These are internal implementation details (abstracted away)
        this._smtpServer = 'smtp.gmail.com';
        this._port = 587;
        this._connectionPool = [];
        this._authToken = null;
    }
    
    /**
     * PUBLIC INTERFACE (What users interact with)
     * Simple, clean methods that hide the complexity
     */
    
    sendEmail(to, subject, body) {
        console.log(`ğŸ“§ Sending email to: ${to}`);
        console.log(`ğŸ“‹ Subject: ${subject}`);
        
        // Behind the scenes (abstracted complexity):
        this._authenticate();
        this._establishConnection();
        this._formatMessage(to, subject, body);
        this._transmitMessage();
        this._closeConnection();
        
        console.log('âœ… Email sent successfully!');
    }
    
    /**
     * PRIVATE METHODS (Hidden implementation details)
     * Users don't need to know these exist or how they work
     */
    
    _authenticate() {
        // Complex authentication logic hidden from user
        console.log('  ğŸ” Authenticating with email server...');
        this._authToken = 'auth_token_12345';
    }
    
    _establishConnection() {
        // Complex network connection logic
        console.log('  ğŸŒ Establishing SMTP connection...');
    }
    
    _formatMessage(to, subject, body) {
        // Complex message formatting according to email standards
        console.log('  ğŸ“ Formatting message according to RFC standards...');
    }
    
    _transmitMessage() {
        // Complex transmission protocol
        console.log('  ğŸ“¤ Transmitting message via SMTP...');
    }
    
    _closeConnection() {
        // Cleanup and connection management
        console.log('  ğŸ”Œ Closing connection and cleaning up...');
    }
}

// Usage: Simple and clean interface
const emailService = new EmailService();

// Users only need to know this simple interface:
emailService.sendEmail(
    'user@example.com', 
    'Welcome!', 
    'Thank you for joining our service!'
);

console.log('\nğŸ’¡ Abstraction Benefits:');
console.log('- Users have a simple interface: sendEmail()');
console.log('- Complex SMTP details are hidden');
console.log('- Implementation can change without affecting users');
console.log('- Reduces cognitive load and potential for errors');

/**
 * Real-world Abstraction Examples:
 * - Array.sort() - You don't need to know the sorting algorithm
 * - fetch() - You don't need to understand HTTP protocol details
 * - document.querySelector() - You don't need to know DOM traversal internals
 */
```

### 2. ğŸ”’ Encapsulation

**Encapsulation** is about bundling data and methods together and controlling access to them. It's like having a capsule that protects the internal components and only allows controlled access through specific interfaces.

```javascript
/**
 * ENCAPSULATION: BUNDLING DATA AND CONTROLLING ACCESS
 * 
 * Encapsulation provides:
 * - Data protection from external interference
 * - Controlled access through public methods
 * - Internal state management
 * - Prevention of invalid state changes
 */

console.log('\n=== Encapsulation Demonstration ===');

/**
 * Example: Bank Account
 * We want to protect the balance from direct manipulation
 * and ensure all transactions go through proper validation.
 */

class BankAccount {
    constructor(accountHolder, initialBalance = 0) {
        this.accountHolder = accountHolder;
        
        // Private properties (encapsulated data)
        this._balance = initialBalance;
        this._transactionHistory = [];
        this._accountNumber = this._generateAccountNumber();
        
        console.log(`ğŸ¦ Account created for ${accountHolder}`);
        console.log(`ğŸ“Š Initial balance: $${initialBalance}`);
    }
    
    /**
     * PUBLIC INTERFACE - Controlled access to account operations
     */
    
    // Getter for balance (read-only access)
    getBalance() {
        console.log(`ğŸ’° Current balance: $${this._balance}`);
        return this._balance;
    }
    
    // Controlled deposit method
    deposit(amount) {
        // Input validation (part of encapsulation)
        if (amount <= 0) {
            console.log('âŒ Invalid deposit amount. Must be positive.');
            return false;
        }
        
        if (amount > 10000) {
            console.log('âŒ Deposit amount exceeds daily limit ($10,000)');
            return false;
        }
        
        // Update internal state safely
        this._balance += amount;
        this._recordTransaction('deposit', amount);
        
        console.log(`âœ… Deposited $${amount}. New balance: $${this._balance}`);
        return true;
    }
    
    // Controlled withdrawal method
    withdraw(amount) {
        // Validation and business logic
        if (amount <= 0) {
            console.log('âŒ Invalid withdrawal amount. Must be positive.');
            return false;
        }
        
        if (amount > this._balance) {
            console.log('âŒ Insufficient funds for withdrawal.');
            return false;
        }
        
        if (amount > 5000) {
            console.log('âŒ Withdrawal amount exceeds daily limit ($5,000)');
            return false;
        }
        
        // Safe state update
        this._balance -= amount;
        this._recordTransaction('withdrawal', amount);
        
        console.log(`âœ… Withdrew $${amount}. New balance: $${this._balance}`);
        return true;
    }
    
    // Controlled access to transaction history
    getTransactionHistory() {
        console.log('ğŸ“‹ Transaction History:');
        this._transactionHistory.forEach((transaction, index) => {
            console.log(`  ${index + 1}. ${transaction.type}: $${transaction.amount} on ${transaction.date}`);
        });
        return [...this._transactionHistory]; // Return copy, not original
    }
    
    /**
     * PRIVATE METHODS - Internal implementation (encapsulated)
     */
    
    _generateAccountNumber() {
        // Private method for internal use only
        return Math.random().toString(36).substr(2, 9).toUpperCase();
    }
    
    _recordTransaction(type, amount) {
        // Private method to maintain transaction history
        this._transactionHistory.push({
            type,
            amount,
            date: new Date().toLocaleString(),
            balance: this._balance
        });
    }
}

// Demonstration of encapsulation
console.log('\nğŸ”’ Encapsulation in Action:');

const account = new BankAccount('Alice Johnson', 1000);

// âœ… Proper way to interact with the account (through public interface)
account.deposit(500);
account.withdraw(200);
account.getBalance();

// âŒ Direct access to private properties (should be avoided)
console.log('\nâš ï¸ What happens if we try to bypass encapsulation:');
console.log(`Direct balance access: $${account._balance}`); // Works but breaks encapsulation
account._balance = 1000000; // Dangerous! Bypasses all validation
console.log(`After direct manipulation: $${account._balance}`);

// This is why we need proper encapsulation!
console.log('\nğŸ’¡ Encapsulation Benefits:');
console.log('- Prevents invalid state changes');
console.log('- Ensures business rules are followed');
console.log('- Provides controlled access to data');
console.log('- Makes debugging easier (controlled entry points)');

/**
 * Modern JavaScript Encapsulation with Private Fields
 * (We'll cover this in detail later)
 */

class ModernBankAccount {
    // Private fields (truly private in modern JavaScript)
    #balance;
    #transactionHistory = [];
    
    constructor(accountHolder, initialBalance = 0) {
        this.accountHolder = accountHolder;
        this.#balance = initialBalance;
    }
    
    getBalance() {
        return this.#balance;
    }
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            return true;
        }
        return false;
    }
}

const modernAccount = new ModernBankAccount('Bob Smith', 500);
console.log('\nğŸ” Modern Encapsulation:');
console.log(`Balance: $${modernAccount.getBalance()}`);

// This will throw an error - truly private!
try {
    console.log(modernAccount.#balance);
} catch (error) {
    console.log('âŒ Cannot access private field: #balance');
}
```

### 3. ğŸ§¬ Inheritance

**Inheritance** allows a class to inherit properties and methods from another class, creating a hierarchical relationship. It's like how children inherit traits from their parents, but can also have their own unique characteristics.

```javascript
/**
 * INHERITANCE: BUILDING HIERARCHICAL RELATIONSHIPS
 * 
 * Inheritance enables:
 * - Code reuse through shared functionality
 * - Hierarchical organization of related classes
 * - Specialization of general concepts
 * - Polymorphic behavior (we'll see this next)
 */

console.log('\n=== Inheritance Demonstration ===');

/**
 * Example: Vehicle Hierarchy
 * We'll create a general Vehicle class and then specialize it
 * for different types of vehicles.
 */

// Base class (Parent/Superclass)
class Vehicle {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.isRunning = false;
        this.speed = 0;
        
        console.log(`ğŸš— Created ${year} ${make} ${model}`);
    }
    
    // Methods that all vehicles share
    start() {
        this.isRunning = true;
        console.log(`${this.make} ${this.model} is now running!`);
    }
    
    stop() {
        this.isRunning = false;
        this.speed = 0;
        console.log(`${this.make} ${this.model} has stopped.`);
    }
    
    accelerate(amount) {
        if (this.isRunning) {
            this.speed += amount;
            console.log(`${this.make} ${this.model} accelerated to ${this.speed} mph`);
        } else {
            console.log('Cannot accelerate - vehicle is not running!');
        }
    }
    
    getInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
}

/**
 * Specialized classes (Children/Subclasses)
 * Each inherits from Vehicle but adds its own specific features
 */

// Car class - inherits from Vehicle
class Car extends Vehicle {
    constructor(make, model, year, doors, fuelType) {
        // Call parent constructor
        super(make, model, year);
        
        // Add car-specific properties
        this.doors = doors;
        this.fuelType = fuelType;
        this.trunkOpen = false;
    }
    
    // Car-specific methods
    openTrunk() {
        this.trunkOpen = true;
        console.log(`ğŸš— ${this.make} ${this.model} trunk opened`);
    }
    
    closeTrunk() {
        this.trunkOpen = false;
        console.log(`ğŸš— ${this.make} ${this.model} trunk closed`);
    }
    
    // Override parent method with car-specific behavior
    accelerate(amount) {
        if (this.isRunning) {
            // Cars have speed limits and different acceleration
            const maxSpeed = 120;
            this.speed = Math.min(this.speed + amount, maxSpeed);
            console.log(`ğŸš— Car accelerated to ${this.speed} mph (max: ${maxSpeed})`);
        } else {
            console.log('Cannot accelerate - car is not running!');
        }
    }
}

// Motorcycle class - inherits from Vehicle
class Motorcycle extends Vehicle {
    constructor(make, model, year, engineSize) {
        super(make, model, year);
        this.engineSize = engineSize;
        this.hasHelmet = false;
    }
    
    // Motorcycle-specific methods
    putOnHelmet() {
        this.hasHelmet = true;
        console.log(`ğŸï¸ Helmet is now on - safety first!`);
    }
    
    // Override with motorcycle-specific behavior
    start() {
        if (!this.hasHelmet) {
            console.log('âš ï¸ Please put on helmet before starting motorcycle!');
            return;
        }
        super.start(); // Call parent method
        console.log('ğŸï¸ Motorcycle engine roaring!');
    }
    
    accelerate(amount) {
        if (this.isRunning) {
            // Motorcycles can go faster but are more dangerous
            const maxSpeed = 180;
            this.speed = Math.min(this.speed + amount * 1.5, maxSpeed);
            console.log(`ğŸï¸ Motorcycle accelerated to ${this.speed} mph (max: ${maxSpeed})`);
        } else {
            console.log('Cannot accelerate - motorcycle is not running!');
        }
    }
}

// Truck class - inherits from Vehicle
class Truck extends Vehicle {
    constructor(make, model, year, cargoCapacity) {
        super(make, model, year);
        this.cargoCapacity = cargoCapacity;
        this.currentCargo = 0;
    }
    
    loadCargo(weight) {
        if (this.currentCargo + weight <= this.cargoCapacity) {
            this.currentCargo += weight;
            console.log(`ğŸš› Loaded ${weight} lbs. Total cargo: ${this.currentCargo}/${this.cargoCapacity} lbs`);
        } else {
            console.log(`âŒ Cannot load ${weight} lbs - exceeds capacity!`);
        }
    }
    
    // Trucks accelerate slower when loaded
    accelerate(amount) {
        if (this.isRunning) {
            const maxSpeed = 80;
            // Reduce acceleration based on cargo load
            const loadFactor = 1 - (this.currentCargo / this.cargoCapacity) * 0.5;
            const actualAcceleration = amount * loadFactor;
            
            this.speed = Math.min(this.speed + actualAcceleration, maxSpeed);
            console.log(`ğŸš› Truck accelerated to ${this.speed.toFixed(1)} mph (load factor: ${loadFactor.toFixed(2)})`);
        } else {
            console.log('Cannot accelerate - truck is not running!');
        }
    }
}

// Demonstration of inheritance
console.log('\nğŸ§¬ Inheritance in Action:');

// Create instances of different vehicle types
const car = new Car('Toyota', 'Camry', 2023, 4, 'Gasoline');
const motorcycle = new Motorcycle('Harley-Davidson', 'Street 750', 2023, 750);
const truck = new Truck('Ford', 'F-150', 2023, 2000);

console.log('\nğŸ“‹ All vehicles share common behavior:');
// All can use inherited methods
car.start();
motorcycle.putOnHelmet(); // Motorcycle-specific requirement
motorcycle.start();
truck.start();

console.log('\nğŸš€ Each vehicle type has specialized behavior:');
// Each has specialized acceleration
car.accelerate(30);
motorcycle.accelerate(30);
truck.loadCargo(1500); // Load the truck
truck.accelerate(30);

console.log('\nğŸ” Inheritance Verification:');
console.log(`Car is instance of Vehicle: ${car instanceof Vehicle}`); // true
console.log(`Car is instance of Car: ${car instanceof Car}`); // true
console.log(`Motorcycle is instance of Vehicle: ${motorcycle instanceof Vehicle}`); // true
console.log(`Truck is instance of Vehicle: ${truck instanceof Vehicle}`); // true

/**
 * Inheritance Benefits Demonstrated:
 * 1. Code Reuse - All vehicles share start(), stop(), getInfo() methods
 * 2. Specialization - Each vehicle type adds its own specific features
 * 3. Polymorphism - Same method (accelerate) behaves differently for each type
 * 4. Maintainability - Changes to Vehicle class affect all subclasses
 */

console.log('\nğŸ’¡ Inheritance Benefits:');
console.log('- Eliminates code duplication');
console.log('- Creates logical hierarchies');
console.log('- Enables polymorphic behavior');
console.log('- Makes maintenance easier');
console.log('- Models real-world relationships');
```

### 4. ğŸ­ Polymorphism

**Polymorphism** means "many forms" - it allows objects of different types to be treated as instances of the same type through a common interface. The same method call can produce different behaviors depending on the object type.

```javascript
/**
 * POLYMORPHISM: ONE INTERFACE, MANY IMPLEMENTATIONS
 * 
 * Polymorphism enables:
 * - Same method name, different behaviors
 * - Flexible and extensible code
 * - Runtime method resolution
 * - Simplified client code
 */

console.log('\n=== Polymorphism Demonstration ===');

/**
 * Example: Shape Drawing System
 * Different shapes implement the same interface but behave differently
 */

// Base class defining the common interface
class Shape {
    constructor(color) {
        this.color = color;
    }
    
    // Abstract methods - to be implemented by subclasses
    draw() {
        throw new Error('draw() method must be implemented by subclass');
    }
    
    calculateArea() {
        throw new Error('calculateArea() method must be implemented by subclass');
    }
    
    // Common method for all shapes
    getInfo() {
        return `${this.constructor.name} (${this.color})`;
    }
}

// Different shape implementations
class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    draw() {
        console.log(`ğŸ”µ Drawing a ${this.color} circle with radius ${this.radius}`);
        // In a real app, this might render to canvas or SVG
        return `<circle r="${this.radius}" fill="${this.color}" />`;
    }
    
    calculateArea() {
        const area = Math.PI * this.radius * this.radius;
        console.log(`ğŸ“ Circle area: ${area.toFixed(2)} square units`);
        return area;
    }
}

class Rectangle extends Shape {
    constructor(color, width, height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    draw() {
        console.log(`ğŸŸ¦ Drawing a ${this.color} rectangle ${this.width}x${this.height}`);
        return `<rect width="${this.width}" height="${this.height}" fill="${this.color}" />`;
    }
    
    calculateArea() {
        const area = this.width * this.height;
        console.log(`ğŸ“ Rectangle area: ${area} square units`);
        return area;
    }
}

class Triangle extends Shape {
    constructor(color, base, height) {
        super(color);
        this.base = base;
        this.height = height;
    }
    
    draw() {
        console.log(`ğŸ”º Drawing a ${this.color} triangle with base ${this.base} and height ${this.height}`);
        return `<polygon points="0,${this.height} ${this.base/2},0 ${this.base},${this.height}" fill="${this.color}" />`;
    }
    
    calculateArea() {
        const area = (this.base * this.height) / 2;
        console.log(`ğŸ“ Triangle area: ${area} square units`);
        return area;
    }
}

/**
 * Drawing Application - Demonstrates Polymorphism
 * The same code works with different shape types!
 */

class DrawingApplication {
    constructor() {
        this.shapes = [];
    }
    
    addShape(shape) {
        // We don't need to know what type of shape this is!
        // Polymorphism allows us to treat all shapes the same way
        this.shapes.push(shape);
        console.log(`â• Added ${shape.getInfo()} to drawing`);
    }
    
    drawAllShapes() {
        console.log('\nğŸ¨ Drawing all shapes:');
        
        // This is polymorphism in action!
        // Same method call (draw()) works differently for each shape type
        this.shapes.forEach((shape, index) => {
            console.log(`${index + 1}. ${shape.getInfo()}`);
            shape.draw(); // Polymorphic method call
        });
    }
    
    calculateTotalArea() {
        console.log('\nğŸ“Š Calculating total area:');
        
        let totalArea = 0;
        this.shapes.forEach(shape => {
            // Another polymorphic method call!
            const area = shape.calculateArea();
            totalArea += area;
        });
        
        console.log(`ğŸ“ˆ Total area of all shapes: ${totalArea.toFixed(2)} square units`);
        return totalArea;
    }
    
    // This method works with ANY shape that implements the Shape interface
    processShape(shape) {
        console.log(`\nğŸ”„ Processing ${shape.getInfo()}:`);
        shape.draw();
        shape.calculateArea();
        
        // We can add new shape types without changing this method!
        // This is the power of polymorphism
    }
}

// Demonstration of polymorphism
console.log('\nğŸ­ Polymorphism in Action:');

const app = new DrawingApplication();

// Create different types of shapes
const circle = new Circle('red', 5);
const rectangle = new Rectangle('blue', 10, 6);
const triangle = new Triangle('green', 8, 4);

// Add shapes to the application
app.addShape(circle);
app.addShape(rectangle);
app.addShape(triangle);

// Polymorphic behavior - same method calls, different implementations
app.drawAllShapes();
app.calculateTotalArea();

// Process each shape individually (polymorphic method)
console.log('\nğŸ”„ Individual Shape Processing:');
app.shapes.forEach(shape => app.processShape(shape));

/**
 * Advanced Polymorphism Example: Plugin System
 * Shows how polymorphism enables extensible architectures
 */

console.log('\nğŸ”Œ Advanced Polymorphism: Plugin System');

// Base plugin interface
class Plugin {
    constructor(name) {
        this.name = name;
    }
    
    execute() {
        throw new Error('execute() method must be implemented');
    }
    
    getDescription() {
        return `Plugin: ${this.name}`;
    }
}

// Different plugin implementations
class EmailPlugin extends Plugin {
    constructor() {
        super('Email Sender');
    }
    
    execute(data) {
        console.log(`ğŸ“§ Sending email to ${data.recipient}: ${data.message}`);
        return { status: 'sent', timestamp: new Date() };
    }
}

class DatabasePlugin extends Plugin {
    constructor() {
        super('Database Logger');
    }
    
    execute(data) {
        console.log(`ğŸ’¾ Logging to database: ${JSON.stringify(data)}`);
        return { status: 'logged', id: Math.random().toString(36) };
    }
}

class NotificationPlugin extends Plugin {
    constructor() {
        super('Push Notification');
    }
    
    execute(data) {
        console.log(`ğŸ”” Sending push notification: ${data.message}`);
        return { status: 'pushed', deviceCount: 42 };
    }
}

// Plugin manager - uses polymorphism
class PluginManager {
    constructor() {
        this.plugins = [];
    }
    
    registerPlugin(plugin) {
        this.plugins.push(plugin);
        console.log(`ğŸ”Œ Registered ${plugin.getDescription()}`);
    }
    
    executeAll(data) {
        console.log('\nâš¡ Executing all plugins:');
        
        // Polymorphic execution - same interface, different behaviors
        const results = this.plugins.map(plugin => {
            console.log(`  Running ${plugin.name}...`);
            return plugin.execute(data);
        });
        
        return results;
    }
}

// Demonstrate plugin system polymorphism
const pluginManager = new PluginManager();

// Register different types of plugins
pluginManager.registerPlugin(new EmailPlugin());
pluginManager.registerPlugin(new DatabasePlugin());
pluginManager.registerPlugin(new NotificationPlugin());

// Execute all plugins with the same interface
const testData = {
    recipient: 'user@example.com',
    message: 'Welcome to our service!',
    userId: 12345
};

const results = pluginManager.executeAll(testData);
console.log('\nğŸ“Š Plugin execution results:', results);

console.log('\nğŸ’¡ Polymorphism Benefits:');
console.log('- Same interface, different implementations');
console.log('- Easy to add new types without changing existing code');
console.log('- Enables flexible and extensible architectures');
console.log('- Simplifies client code (no need to know specific types)');
console.log('- Runtime method resolution based on object type');
```

---

## ğŸ”§ OOP in JavaScript: The Prototypal Way

JavaScript implements OOP differently from traditional class-based languages. Instead of classes, JavaScript uses **prototypes** - a more flexible and powerful system once you understand it.

### Understanding JavaScript's Prototypal Inheritance

```javascript
/**
 * JAVASCRIPT'S PROTOTYPAL INHERITANCE SYSTEM
 * 
 * Unlike class-based languages, JavaScript uses prototypes:
 * - Every object has a prototype (except Object.prototype)
 * - Objects inherit directly from other objects
 * - More flexible than traditional class inheritance
 * - Enables dynamic behavior modification
 */

console.log('=== JavaScript Prototypal Inheritance ===');

/**
 * The Prototype Chain Explained
 * 
 * When you access a property on an object:
 * 1. JavaScript first looks on the object itself
 * 2. If not found, it looks on the object's prototype
 * 3. If not found, it looks on the prototype's prototype
 * 4. This continues until it reaches Object.prototype
 * 5. If still not found, returns undefined
 */

function demonstratePrototypeChain() {
    console.log('\nğŸ”— Prototype Chain Demonstration:');
    
    // Create a simple object
    const person = {
        name: 'Alice',
        greet() {
            console.log(`Hello, I'm ${this.name}`);
        }
    };
    
    // Create another object that inherits from person
    const student = Object.create(person);
    student.studentId = 12345;
    student.study = function() {
        console.log(`${this.name} is studying`);
    };
    
    // Create a graduate student that inherits from student
    const gradStudent = Object.create(student);
    gradStudent.researchTopic = 'Machine Learning';
    gradStudent.research = function() {
        console.log(`${this.name} is researching ${this.researchTopic}`);
    };
    
    // Set properties
    gradStudent.name = 'Bob';
    
    console.log('ğŸ” Property Lookup Demonstration:');
    
    // When we access gradStudent.name:
    console.log(`gradStudent.name: ${gradStudent.name}`); // Found on gradStudent itself
    
    // When we access gradStudent.studentId:
    console.log(`gradStudent.studentId: ${gradStudent.studentId}`); // Found on student prototype
    
    // When we access gradStudent.greet:
    gradStudent.greet(); // Found on person prototype
    
    // Method calls work through the prototype chain
    gradStudent.study(); // From student prototype
    gradStudent.research(); // From gradStudent itself
    
    console.log('\nğŸ” Prototype Chain Inspection:');
    console.log('gradStudent.__proto__ === student:', gradStudent.__proto__ === student);
    console.log('student.__proto__ === person:', student.__proto__ === person);
    console.log('person.__proto__ === Object.prototype:', person.__proto__ === Object.prototype);
    
    // Visualize the prototype chain
    console.log('\nğŸ“Š Prototype Chain Visualization:');
    let current = gradStudent;
    let level = 0;
    
    while (current) {
        const indent = '  '.repeat(level);
        const objName = current.constructor?.name || 'Object';
        const ownProps = Object.getOwnPropertyNames(current).filter(prop => prop !== '__proto__');
        
        console.log(`${indent}Level ${level}: ${objName}`);
        console.log(`${indent}  Own properties: [${ownProps.join(', ')}]`);
        
        current = Object.getPrototypeOf(current);
        level++;
        
        if (level > 5) break; // Prevent infinite loop
    }
}

demonstratePrototypeChain();

/**
 * Three Ways to Implement Prototypal Inheritance in JavaScript
 */

console.log('\nğŸ› ï¸ Three Ways to Implement Prototypal Inheritance:');

// 1. Constructor Functions (ES5 and earlier)
console.log('\n1ï¸âƒ£ Constructor Functions:');

function Animal(name, species) {
    this.name = name;
    this.species = species;
}

Animal.prototype.makeSound = function() {
    console.log(`${this.name} makes a sound`);
};

Animal.prototype.getInfo = function() {
    return `${this.name} is a ${this.species}`;
};

const dog = new Animal('Buddy', 'Dog');
dog.makeSound();
console.log(dog.getInfo());

// 2. ES6 Classes (syntactic sugar over constructor functions)
console.log('\n2ï¸âƒ£ ES6 Classes:');

class Plant {
    constructor(name, type) {
        this.name = name;
        this.type = type;
    }
    
    photosynthesize() {
        console.log(`${this.name} is photosynthesizing`);
    }
    
    getInfo() {
        return `${this.name} is a ${this.type}`;
    }
}

const rose = new Plant('Rose', 'Flower');
rose.photosynthesize();
console.log(rose.getInfo());

// 3. Object.create() (direct prototype linking)
console.log('\n3ï¸âƒ£ Object.create():');

const vehiclePrototype = {
    start() {
        console.log(`${this.name} is starting`);
    },
    
    getInfo() {
        return `${this.name} - ${this.type}`;
    }
};

const car = Object.create(vehiclePrototype);
car.name = 'Tesla Model 3';
car.type = 'Electric Car';
car.start();
console.log(car.getInfo());

/**
 * Comparison of the Three Approaches
 */

console.log('\nğŸ“Š Comparison of Approaches:');

console.log('\nğŸ—ï¸ Constructor Functions:');
console.log('  âœ… Widely supported (all browsers)');
console.log('  âœ… Clear instantiation with "new"');
console.log('  âŒ Verbose syntax');
console.log('  âŒ Easy to forget "new" keyword');

console.log('\nğŸ“ ES6 Classes:');
console.log('  âœ… Clean, familiar syntax');
console.log('  âœ… Built-in inheritance with "extends"');
console.log('  âœ… Static methods support');
console.log('  âŒ Just syntactic sugar (same prototype system underneath)');
console.log('  âŒ Not supported in older browsers without transpilation');

console.log('\nğŸ”— Object.create():');
console.log('  âœ… Direct prototype manipulation');
console.log('  âœ… Most flexible approach');
console.log('  âœ… No constructor function needed');
console.log('  âŒ Less intuitive for developers from class-based languages');
console.log('  âŒ Manual property initialization');

/**
 * When to Use Each Approach
 */

console.log('\nğŸ¯ When to Use Each Approach:');
console.log('\nğŸ—ï¸ Use Constructor Functions when:');
console.log('  - Supporting older browsers');
console.log('  - Working with legacy codebases');
console.log('  - Need maximum compatibility');

console.log('\nğŸ“ Use ES6 Classes when:');
console.log('  - Building modern applications');
console.log('  - Team familiar with class-based OOP');
console.log('  - Want clean, readable syntax');
console.log('  - Using inheritance extensively');

console.log('\nğŸ”— Use Object.create() when:');
console.log('  - Need maximum flexibility');
console.log('  - Creating simple object hierarchies');
console.log('  - Implementing mixins or composition');
console.log('  - Performance is critical (no constructor overhead)');
```---

#
# ğŸ—ï¸ Constructor Functions and the `new` Operator

Constructor functions are the traditional way to create objects in JavaScript. They're regular functions that are called with the `new` operator to create instances.

### Understanding Constructor Functions

```javascript
/**
 * CONSTRUCTOR FUNCTIONS: THE TRADITIONAL APPROACH
 * 
 * Constructor functions are:
 * - Regular functions called with the 'new' operator
 * - Used to create multiple instances of similar objects
 * - The foundation of JavaScript's object creation before ES6 classes
 * - Still widely used and important to understand
 */

console.log('=== Constructor Functions Deep Dive ===');

/**
 * What happens when you use the 'new' operator:
 * 
 * 1. A new empty object {} is created
 * 2. The function is called with 'this' pointing to the new object
 * 3. The new object is linked to the function's prototype
 * 4. The function automatically returns the new object (unless explicitly returning another object)
 */

function Person(firstName, birthYear) {
    console.log('ğŸ—ï¸ Constructor function called with:', { firstName, birthYear });
    console.log('ğŸ” this before assignment:', this);
    
    // Step 2: Set properties on the new object (this)
    this.firstName = firstName;
    this.birthYear = birthYear;
    
    // âŒ NEVER do this in a constructor function!
    // Creating methods inside constructor means each instance gets its own copy
    // This wastes memory and defeats the purpose of prototypes
    // this.calcAge = function() {
    //     return 2024 - this.birthYear;
    // };
    
    console.log('ğŸ” this after assignment:', this);
    
    // Step 4: The new object is automatically returned
    // (unless we explicitly return a different object)
}

/**
 * Demonstration of the 'new' operator process
 */

console.log('\nğŸ” Step-by-step "new" operator demonstration:');

console.log('\n1ï¸âƒ£ Creating first person...');
const alice = new Person('Alice', 1990);

console.log('\n2ï¸âƒ£ Creating second person...');
const bob = new Person('Bob', 1985);

console.log('\nâœ… Final objects:');
console.log('Alice:', alice);
console.log('Bob:', bob);

// Verify they are instances of Person
console.log('\nğŸ” Instance verification:');
console.log('alice instanceof Person:', alice instanceof Person); // true
console.log('bob instanceof Person:', bob instanceof Person); // true
console.log('alice instanceof Object:', alice instanceof Object); // true

/**
 * What happens if you forget the 'new' operator?
 */

console.log('\nâš ï¸ What happens without "new"?');

// âŒ Calling constructor function without 'new'
const charlie = Person('Charlie', 1995);

console.log('charlie:', charlie); // undefined (function doesn't explicitly return anything)
console.log('window.firstName:', globalThis.firstName); // 'Charlie' (in browser, this would be window.firstName)

// The properties were set on the global object instead of a new object!
// This is a common source of bugs

/**
 * Best Practices for Constructor Functions
 */

console.log('\nğŸ“‹ Constructor Function Best Practices:');

// âœ… Good constructor function
function Vehicle(make, model, year) {
    // 1. Validate input parameters
    if (!make || !model || !year) {
        throw new Error('Make, model, and year are required');
    }
    
    // 2. Use clear, descriptive property names
    this.make = make;
    this.model = model;
    this.year = year;
    
    // 3. Set default values for optional properties
    this.isRunning = false;
    this.mileage = 0;
    
    // 4. Initialize arrays and objects as new instances
    this.maintenanceHistory = []; // Each instance gets its own array
    
    // 5. Call initialization methods if needed
    this._initialize();
}

// âœ… Add methods to prototype (shared by all instances)
Vehicle.prototype.start = function() {
    if (this.isRunning) {
        console.log(`${this.make} ${this.model} is already running`);
        return;
    }
    
    this.isRunning = true;
    console.log(`ğŸš— ${this.make} ${this.model} started`);
};

Vehicle.prototype.stop = function() {
    if (!this.isRunning) {
        console.log(`${this.make} ${this.model} is already stopped`);
        return;
    }
    
    this.isRunning = false;
    console.log(`ğŸ›‘ ${this.make} ${this.model} stopped`);
};

Vehicle.prototype.drive = function(miles) {
    if (!this.isRunning) {
        console.log('Cannot drive - vehicle is not running!');
        return;
    }
    
    this.mileage += miles;
    console.log(`ğŸ›£ï¸ Drove ${miles} miles. Total mileage: ${this.mileage}`);
};

Vehicle.prototype.addMaintenance = function(description) {
    const maintenanceRecord = {
        date: new Date().toLocaleDateString(),
        description: description,
        mileage: this.mileage
    };
    
    this.maintenanceHistory.push(maintenanceRecord);
    console.log(`ğŸ”§ Maintenance added: ${description}`);
};

Vehicle.prototype.getInfo = function() {
    return `${this.year} ${this.make} ${this.model} (${this.mileage} miles)`;
};

// Private method (convention: prefix with underscore)
Vehicle.prototype._initialize = function() {
    console.log(`ğŸ—ï¸ Initializing ${this.make} ${this.model}`);
};

/**
 * Demonstration of well-designed constructor function
 */

console.log('\nğŸš— Vehicle Constructor Demonstration:');

try {
    const car1 = new Vehicle('Toyota', 'Camry', 2022);
    const car2 = new Vehicle('Honda', 'Civic', 2023);
    
    console.log('\nğŸ”§ Testing vehicle operations:');
    
    // Test car1
    console.log(`\n${car1.getInfo()}:`);
    car1.start();
    car1.drive(150);
    car1.addMaintenance('Oil change');
    car1.stop();
    
    // Test car2
    console.log(`\n${car2.getInfo()}:`);
    car2.start();
    car2.drive(75);
    car2.addMaintenance('Tire rotation');
    
    // Verify shared methods but separate data
    console.log('\nğŸ” Shared methods, separate data:');
    console.log('Same start method?', car1.start === car2.start); // true
    console.log('Same maintenance history?', car1.maintenanceHistory === car2.maintenanceHistory); // false
    console.log('Car1 maintenance:', car1.maintenanceHistory);
    console.log('Car2 maintenance:', car2.maintenanceHistory);
    
} catch (error) {
    console.error('âŒ Error creating vehicle:', error.message);
}

/**
 * Advanced Constructor Function Patterns
 */

console.log('\nğŸ¯ Advanced Constructor Patterns:');

// Pattern 1: Factory Constructor (returns different types based on input)
function AnimalFactory(type, name) {
    // Return different constructor based on type
    switch (type.toLowerCase()) {
        case 'dog':
            return new Dog(name);
        case 'cat':
            return new Cat(name);
        case 'bird':
            return new Bird(name);
        default:
            throw new Error(`Unknown animal type: ${type}`);
    }
}

// Base animal constructor
function Animal(name, species) {
    this.name = name;
    this.species = species;
    this.energy = 100;
}

Animal.prototype.eat = function() {
    this.energy = Math.min(this.energy + 20, 100);
    console.log(`${this.name} ate food. Energy: ${this.energy}`);
};

Animal.prototype.sleep = function() {
    this.energy = 100;
    console.log(`${this.name} slept and restored energy to ${this.energy}`);
};

// Specific animal constructors
function Dog(name) {
    Animal.call(this, name, 'Dog'); // Call parent constructor
    this.loyalty = 100;
}

// Set up inheritance
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    this.energy -= 5;
    console.log(`${this.name} barks! Woof! Energy: ${this.energy}`);
};

Dog.prototype.fetch = function() {
    this.energy -= 15;
    this.loyalty += 5;
    console.log(`${this.name} fetched the ball! Loyalty: ${this.loyalty}, Energy: ${this.energy}`);
};

function Cat(name) {
    Animal.call(this, name, 'Cat');
    this.independence = 80;
}

Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Cat;

Cat.prototype.meow = function() {
    this.energy -= 3;
    console.log(`${this.name} meows! Meow! Energy: ${this.energy}`);
};

Cat.prototype.purr = function() {
    console.log(`${this.name} purrs contentedly`);
};

function Bird(name) {
    Animal.call(this, name, 'Bird');
    this.canFly = true;
}

Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;

Bird.prototype.chirp = function() {
    this.energy -= 2;
    console.log(`${this.name} chirps! Tweet! Energy: ${this.energy}`);
};

Bird.prototype.fly = function() {
    if (this.canFly && this.energy >= 20) {
        this.energy -= 20;
        console.log(`${this.name} flies gracefully! Energy: ${this.energy}`);
    } else {
        console.log(`${this.name} is too tired to fly or cannot fly`);
    }
};

// Demonstrate factory pattern
console.log('\nğŸ­ Factory Constructor Pattern:');

const pets = [
    AnimalFactory('dog', 'Buddy'),
    AnimalFactory('cat', 'Whiskers'),
    AnimalFactory('bird', 'Tweety')
];

pets.forEach(pet => {
    console.log(`\n${pet.name} the ${pet.species}:`);
    pet.eat();
    
    // Call species-specific methods
    if (pet instanceof Dog) {
        pet.bark();
        pet.fetch();
    } else if (pet instanceof Cat) {
        pet.meow();
        pet.purr();
    } else if (pet instanceof Bird) {
        pet.chirp();
        pet.fly();
    }
});

/**
 * Constructor Function vs Regular Function
 */

console.log('\nğŸ” Constructor vs Regular Function:');

// Same function can be used both ways
function FlexibleFunction(value) {
    // Detect if called with 'new'
    if (new.target) {
        // Called as constructor
        console.log('ğŸ“¦ Called as constructor');
        this.value = value;
        this.type = 'instance';
    } else {
        // Called as regular function
        console.log('ğŸ”§ Called as regular function');
        return {
            value: value,
            type: 'object literal'
        };
    }
}

FlexibleFunction.prototype.getValue = function() {
    return this.value;
};

const instance = new FlexibleFunction('constructor call');
const object = FlexibleFunction('function call');

console.log('Instance:', instance);
console.log('Object:', object);
console.log('Instance has getValue method:', typeof instance.getValue); // function
console.log('Object has getValue method:', typeof object.getValue); // undefined

console.log('\nğŸ’¡ Constructor Function Key Points:');
console.log('- Use PascalCase naming convention');
console.log('- Always call with "new" operator');
console.log('- Add methods to prototype, not inside constructor');
console.log('- Use "this" to set instance properties');
console.log('- Validate input parameters');
console.log('- Handle the case where "new" is forgotten');
```

---

## ğŸ”— Prototypes and the Prototype Chain

Prototypes are the mechanism by which JavaScript objects inherit features from one another. Understanding prototypes is crucial for mastering JavaScript OOP.

### Deep Dive into Prototypes

```javascript
/**
 * PROTOTYPES: THE HEART OF JAVASCRIPT OOP
 * 
 * Key concepts:
 * - Every function has a 'prototype' property
 * - Every object has a '__proto__' property (link to its prototype)
 * - Prototype chain enables inheritance
 * - Methods are shared via prototypes (memory efficient)
 */

console.log('=== Prototypes Deep Dive ===');

/**
 * Understanding the Prototype Property
 */

function Person(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
}

console.log('\nğŸ” Exploring Function Prototypes:');
console.log('Person.prototype:', Person.prototype);
console.log('Person.prototype is an object:', typeof Person.prototype); // object
console.log('Person.prototype.constructor:', Person.prototype.constructor === Person); // true

// Add methods to the prototype
Person.prototype.calcAge = function() {
    const age = 2024 - this.birthYear;
    console.log(`${this.firstName} is ${age} years old`);
    return age;
};

Person.prototype.greet = function() {
    console.log(`Hello, I'm ${this.firstName}!`);
};

// Add properties to the prototype (shared by all instances)
Person.prototype.species = 'Homo Sapiens';

/**
 * Creating Instances and Exploring Prototype Links
 */

console.log('\nğŸ‘¥ Creating Person Instances:');

const alice = new Person('Alice', 1990);
const bob = new Person('Bob', 1985);

console.log('Alice:', alice);
console.log('Bob:', bob);

// Instances can use prototype methods
console.log('\nğŸ”§ Using Prototype Methods:');
alice.calcAge();
bob.greet();

// Accessing prototype properties
console.log('\nğŸ§¬ Accessing Prototype Properties:');
console.log(`Alice species: ${alice.species}`);
console.log(`Bob species: ${bob.species}`);

/**
 * Understanding __proto__ vs prototype
 */

console.log('\nğŸ” __proto__ vs prototype:');

console.log('alice.__proto__ === Person.prototype:', alice.__proto__ === Person.prototype); // true
console.log('bob.__proto__ === Person.prototype:', bob.__proto__ === Person.prototype); // true

// Common misconception clarification
console.log('Person.prototype is NOT the prototype OF Person');
console.log('Person.prototype is the prototype FOR objects created by Person');
console.log('Person.prototype.isPrototypeOf(alice):', Person.prototype.isPrototypeOf(alice)); // true
console.log('Person.prototype.isPrototypeOf(Person):', Person.prototype.isPrototypeOf(Person)); // false

/**
 * Property Lookup in the Prototype Chain
 */

console.log('\nğŸ” Property Lookup Demonstration:');

// Own properties vs inherited properties
console.log('alice.hasOwnProperty("firstName"):', alice.hasOwnProperty('firstName')); // true
console.log('alice.hasOwnProperty("species"):', alice.hasOwnProperty('species')); // false
console.log('alice.hasOwnProperty("calcAge"):', alice.hasOwnProperty('calcAge')); // false

// Where properties are found
console.log('\nğŸ“ Property Location:');
console.log('alice.firstName (own property):', alice.firstName);
console.log('alice.species (prototype property):', alice.species);

// Overriding prototype properties
alice.species = 'Homo Sapiens Sapiens'; // Creates own property
console.log('After override - alice.species:', alice.species);
console.log('Bob still has original - bob.species:', bob.species);
console.log('alice.hasOwnProperty("species"):', alice.hasOwnProperty('species')); // now true

/**
 * The Complete Prototype Chain
 */

console.log('\nğŸ”— Complete Prototype Chain Exploration:');

function explorePrototypeChain(obj, objName) {
    console.log(`\nğŸ“Š Prototype chain for ${objName}:`);
    
    let current = obj;
    let level = 0;
    
    while (current) {
        const indent = '  '.repeat(level);
        
        if (level === 0) {
            console.log(`${indent}${objName} (the object itself)`);
            console.log(`${indent}  Own properties: [${Object.getOwnPropertyNames(current).join(', ')}]`);
        } else {
            const constructorName = current.constructor?.name || 'Unknown';
            console.log(`${indent}Level ${level}: ${constructorName}.prototype`);
            
            const ownProps = Object.getOwnPropertyNames(current)
                .filter(prop => prop !== 'constructor' && typeof current[prop] === 'function');
            console.log(`${indent}  Methods: [${ownProps.join(', ')}]`);
        }
        
        current = Object.getPrototypeOf(current);
        level++;
        
        if (level > 5) break; // Safety check
    }
}

explorePrototypeChain(alice, 'alice');

/**
 * Prototype Chain in Built-in Objects
 */

console.log('\nğŸ—ï¸ Built-in Object Prototype Chains:');

// Array prototype chain
const arr = [1, 2, 3];
console.log('\nğŸ“Š Array prototype chain:');
console.log('arr.__proto__ === Array.prototype:', arr.__proto__ === Array.prototype);
console.log('Array.prototype.__proto__ === Object.prototype:', Array.prototype.__proto__ === Object.prototype);
console.log('Object.prototype.__proto__:', Object.prototype.__proto__); // null (end of chain)

// Function prototype chain
function myFunction() {}
console.log('\nğŸ“Š Function prototype chain:');
console.log('myFunction.__proto__ === Function.prototype:', myFunction.__proto__ === Function.prototype);
console.log('Function.prototype.__proto__ === Object.prototype:', Function.prototype.__proto__ === Object.prototype);

/**
 * Dynamic Prototype Modification
 */

console.log('\nğŸ”„ Dynamic Prototype Modification:');

// Add method to existing prototype
Person.prototype.getFullInfo = function() {
    return `${this.firstName}, born in ${this.birthYear}, age ${2024 - this.birthYear}`;
};

// All existing instances immediately get the new method!
console.log('Alice full info:', alice.getFullInfo());
console.log('Bob full info:', bob.getFullInfo());

// Add method to built-in prototype (generally not recommended)
Array.prototype.unique = function() {
    return [...new Set(this)];
};

const numbers = [1, 2, 2, 3, 3, 3, 4];
console.log('Original array:', numbers);
console.log('Unique values:', numbers.unique());

// âš ï¸ Warning about modifying built-in prototypes
console.log('\nâš ï¸ Modifying built-in prototypes:');
console.log('âœ… Pros: Adds functionality to all instances');
console.log('âŒ Cons: Can break other code, pollutes global namespace');
console.log('âŒ Cons: Future JS versions might add conflicting methods');
console.log('ğŸ¯ Recommendation: Avoid in production code');

/**
 * Prototype-based Inheritance Example
 */

console.log('\nğŸ§¬ Prototype-based Inheritance:');

// Parent constructor
function Animal(name, species) {
    this.name = name;
    this.species = species;
}

Animal.prototype.makeSound = function() {
    console.log(`${this.name} makes a generic animal sound`);
};

Animal.prototype.getInfo = function() {
    return `${this.name} is a ${this.species}`;
};

// Child constructor
function Dog(name, breed) {
    Animal.call(this, name, 'Dog'); // Call parent constructor
    this.breed = breed;
}

// Set up inheritance - IMPORTANT: Do this before adding methods to Dog.prototype
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // Fix constructor reference

// Add Dog-specific methods
Dog.prototype.makeSound = function() {
    console.log(`${this.name} barks: Woof! Woof!`);
};

Dog.prototype.wagTail = function() {
    console.log(`${this.name} wags tail happily!`);
};

// Create instances
const genericAnimal = new Animal('Generic', 'Unknown');
const buddy = new Dog('Buddy', 'Golden Retriever');

console.log('\nğŸ• Testing inheritance:');
console.log(genericAnimal.getInfo());
genericAnimal.makeSound();

console.log(buddy.getInfo()); // Inherited from Animal
buddy.makeSound(); // Overridden in Dog
buddy.wagTail(); // Dog-specific method

// Verify inheritance
console.log('\nğŸ” Inheritance verification:');
console.log('buddy instanceof Dog:', buddy instanceof Dog); // true
console.log('buddy instanceof Animal:', buddy instanceof Animal); // true
console.log('buddy instanceof Object:', buddy instanceof Object); // true

/**
 * Prototype Performance Considerations
 */

console.log('\nâš¡ Prototype Performance Benefits:');

// Memory usage comparison
function MemoryHeavyPerson(name) {
    this.name = name;
    
    // âŒ Bad: Each instance gets its own copy of the method
    this.greet = function() {
        console.log(`Hello, I'm ${this.name}`);
    };
}

function MemoryEfficientPerson(name) {
    this.name = name;
}

// âœ… Good: All instances share the same method
MemoryEfficientPerson.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

// Create multiple instances
const heavyPeople = [];
const efficientPeople = [];

for (let i = 0; i < 1000; i++) {
    heavyPeople.push(new MemoryHeavyPerson(`Person${i}`));
    efficientPeople.push(new MemoryEfficientPerson(`Person${i}`));
}

console.log('Created 1000 instances of each type');
console.log('Heavy approach: Each instance has its own greet method');
console.log('Efficient approach: All instances share one greet method via prototype');
console.log('Memory savings: Significant when creating many instances');

// Verify method sharing
console.log('\nMethod sharing verification:');
console.log('Heavy - same method?', heavyPeople[0].greet === heavyPeople[1].greet); // false
console.log('Efficient - same method?', efficientPeople[0].greet === efficientPeople[1].greet); // true

console.log('\nğŸ’¡ Prototype Key Takeaways:');
console.log('- Prototypes enable efficient method sharing');
console.log('- __proto__ links objects to their prototype');
console.log('- Prototype chain enables inheritance');
console.log('- Methods should be on prototype, not in constructor');
console.log('- Prototype chain lookup has performance cost');
console.log('- Understanding prototypes is key to mastering JavaScript');
```

---

## ğŸ“ ES6 Classes: Modern JavaScript OOP

ES6 introduced class syntax to JavaScript, providing a more familiar and cleaner way to create objects and implement inheritance. However, it's important to understand that classes are syntactic sugar over the existing prototype system.

### ES6 Classes Fundamentals

```javascript
/**
 * ES6 CLASSES: MODERN JAVASCRIPT OOP SYNTAX
 * 
 * ES6 Classes provide:
 * - Cleaner, more familiar syntax
 * - Built-in inheritance with 'extends'
 * - Static methods and properties
 * - Private fields and methods (modern browsers)
 * - Better tooling support
 * 
 * Important: Classes are syntactic sugar over prototypes!
 */

console.log('=== ES6 Classes Comprehensive Guide ===');

/**
 * Basic Class Declaration
 */

class Person {
    // Constructor method - called when creating new instances
    constructor(firstName, lastName, birthYear) {
        // Validate input (good practice)
        if (!firstName || !lastName || !birthYear) {
            throw new Error('firstName, lastName, and birthYear are required');
        }
        
        // Instance properties
        this.firstName = firstName;
        this.lastName = lastName;
        this.birthYear = birthYear;
        
        // Private properties (convention: prefix with _)
        this._id = Math.random().toString(36).substr(2, 9);
        
        console.log(`ğŸ‘¤ Created person: ${this.firstName} ${this.lastName}`);
    }
    
    // Instance methods (added to prototype automatically)
    calcAge() {
        const age = 2024 - this.birthYear;
        console.log(`${this.firstName} is ${age} years old`);
        return age;
    }
    
    greet() {
        console.log(`Hello! I'm ${this.firstName} ${this.lastName}`);
    }
    
    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    
    // Method with parameters
    introduce(context = 'everyone') {
        console.log(`Hi ${context}, I'm ${this.getFullName()} and I'm ${this.calcAge()} years old`);
    }
    
    // Static method (belongs to class, not instances)
    static createFromString(personString) {
        const [firstName, lastName, birthYear] = personString.split(',');
        return new Person(firstName.trim(), lastName.trim(), parseInt(birthYear.trim()));
    }
    
    static compareAges(person1, person2) {
        const age1 = 2024 - person1.birthYear;
        const age2 = 2024 - person2.birthYear;
        
        if (age1 > age2) {
            return `${person1.getFullName()} is older than ${person2.getFullName()}`;
        } else if (age2 > age1) {
            return `${person2.getFullName()} is older than ${person1.getFullName()}`;
        } else {
            return `${person1.getFullName()} and ${person2.getFullName()} are the same age`;
        }
    }
}

/**
 * Using ES6 Classes
 */

console.log('\nğŸ‘¥ Creating Person Instances:');

const alice = new Person('Alice', 'Johnson', 1990);
const bob = new Person('Bob', 'Smith', 1985);

// Using instance methods
alice.greet();
bob.introduce('Alice');

// Using static methods
console.log('\nğŸ”§ Using Static Methods:');
const charlie = Person.createFromString('Charlie, Brown, 1992');
charlie.greet();

console.log(Person.compareAges(alice, bob));

/**
 * Getters and Setters
 */

console.log('\nğŸ”§ Getters and Setters:');

class BankAccount {
    constructor(owner, initialBalance = 0) {
        this.owner = owner;
        this._balance = initialBalance; // Private by convention
        this._transactions = [];
    }
    
    // Getter - access like a property
    get balance() {
        return this._balance;
    }
    
    // Getter for computed property
    get formattedBalance() {
        return `$${this._balance.toFixed(2)}`;
    }
    
    // Setter - set like a property but with validation
    set balance(amount) {
        if (amount < 0) {
            throw new Error('Balance cannot be negative');
        }
        this._balance = amount;
    }
    
    // Getter for transaction history
    get transactionHistory() {
        return [...this._transactions]; // Return copy, not original
    }
    
    // Methods for account operations
    deposit(amount) {
        if (amount <= 0) {
            throw new Error('Deposit amount must be positive');
        }
        
        this._balance += amount;
        this._transactions.push({
            type: 'deposit',
            amount,
            date: new Date(),
            balance: this._balance
        });
        
        console.log(`ğŸ’° Deposited ${this.formattedBalance.replace('$', '$')}${amount}. New balance: ${this.formattedBalance}`);
    }
    
    withdraw(amount) {
        if (amount <= 0) {
            throw new Error('Withdrawal amount must be positive');
        }
        
        if (amount > this._balance) {
            throw new Error('Insufficient funds');
        }
        
        this._balance -= amount;
        this._transactions.push({
            type: 'withdrawal',
            amount,
            date: new Date(),
            balance: this._balance
        });
        
        console.log(`ğŸ’¸ Withdrew $${amount}. New balance: ${this.formattedBalance}`);
    }
}

// Demonstrate getters and setters
const account = new BankAccount('Alice Johnson', 1000);

console.log(`Initial balance: ${account.formattedBalance}`); // Using getter
console.log(`Raw balance: ${account.balance}`); // Using getter

account.deposit(500);
account.withdraw(200);

// Using setter (with validation)
try {
    account.balance = -100; // This will throw an error
} catch (error) {
    console.log(`âŒ Setter validation: ${error.message}`);
}

console.log('Transaction history:', account.transactionHistory);

/**
 * Class Inheritance with 'extends'
 */

console.log('\nğŸ§¬ Class Inheritance with "extends":');

// Parent class
class Vehicle {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.isRunning = false;
        this.speed = 0;
    }
    
    start() {
        this.isRunning = true;
        console.log(`ğŸš— ${this.make} ${this.model} started`);
    }
    
    stop() {
        this.isRunning = false;
        this.speed = 0;
        console.log(`ğŸ›‘ ${this.make} ${this.model} stopped`);
    }
    
    accelerate(amount) {
        if (!this.isRunning) {
            console.log('Cannot accelerate - vehicle not running');
            return;
        }
        
        this.speed += amount;
        console.log(`ğŸš€ ${this.make} ${this.model} accelerated to ${this.speed} mph`);
    }
    
    getInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
}

// Child class extending Vehicle
class Car extends Vehicle {
    constructor(make, model, year, doors, fuelType) {
        // Call parent constructor with 'super'
        super(make, model, year);
        
        // Add car-specific properties
        this.doors = doors;
        this.fuelType = fuelType;
        this.trunkOpen = false;
    }
    
    // Car-specific methods
    openTrunk() {
        this.trunkOpen = true;
        console.log(`ğŸš— ${this.make} ${this.model} trunk opened`);
    }
    
    closeTrunk() {
        this.trunkOpen = false;
        console.log(`ğŸš— ${this.make} ${this.model} trunk closed`);
    }
    
    // Override parent method
    accelerate(amount) {
        if (!this.isRunning) {
            console.log('Cannot accelerate - car not running');
            return;
        }
        
        // Cars have speed limits
        const maxSpeed = 120;
        this.speed = Math.min(this.speed + amount, maxSpeed);
        console.log(`ğŸš— Car accelerated to ${this.speed} mph (max: ${maxSpeed})`);
    }
    
    // Override getInfo to include car-specific details
    getInfo() {
        return `${super.getInfo()} - ${this.doors} doors, ${this.fuelType}`;
    }
}

// Electric car extending Car
class ElectricCar extends Car {
    constructor(make, model, year, doors, batteryCapacity) {
        super(make, model, year, doors, 'Electric');
        this.batteryCapacity = batteryCapacity;
        this.currentCharge = batteryCapacity; // Start fully charged
    }
    
    // Electric car specific methods
    charge(amount) {
        const oldCharge = this.currentCharge;
        this.currentCharge = Math.min(this.currentCharge + amount, this.batteryCapacity);
        const actualCharge = this.currentCharge - oldCharge;
        
        console.log(`ğŸ”‹ Charged ${actualCharge} kWh. Battery: ${this.currentCharge}/${this.batteryCapacity} kWh`);
    }
    
    get batteryPercentage() {
        return Math.round((this.currentCharge / this.batteryCapacity) * 100);
    }
    
    // Override accelerate to account for battery usage
    accelerate(amount) {
        if (!this.isRunning) {
            console.log('Cannot accelerate - car not running');
            return;
        }
        
        if (this.currentCharge <= 0) {
            console.log('Cannot accelerate - battery depleted');
            return;
        }
        
        // Electric cars accelerate faster but use battery
        const maxSpeed = 150;
        this.speed = Math.min(this.speed + amount * 1.2, maxSpeed);
        this.currentCharge = Math.max(this.currentCharge - 0.5, 0);
        
        console.log(`âš¡ Electric car accelerated to ${this.speed} mph. Battery: ${this.batteryPercentage}%`);
    }
    
    getInfo() {
        return `${super.getInfo()} - Battery: ${this.batteryPercentage}%`;
    }
}

// Demonstrate inheritance
console.log('\nğŸš— Vehicle Inheritance Demo:');

const regularCar = new Car('Toyota', 'Camry', 2023, 4, 'Gasoline');
const electricCar = new ElectricCar('Tesla', 'Model 3', 2023, 4, 75);

console.log('\nğŸ”§ Regular Car:');
console.log(regularCar.getInfo());
regularCar.start();
regularCar.accelerate(30);
regularCar.openTrunk();

console.log('\nâš¡ Electric Car:');
console.log(electricCar.getInfo());
electricCar.start();
electricCar.accelerate(30);
electricCar.accelerate(40);
electricCar.charge(10);

/**
 * Class vs Constructor Function Comparison
 */

console.log('\nğŸ“Š Class vs Constructor Function:');

// Constructor function approach
function PersonConstructor(name, age) {
    this.name = name;
    this.age = age;
}

PersonConstructor.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

// ES6 class approach
class PersonClass {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }
}

const person1 = new PersonConstructor('John', 30);
const person2 = new PersonClass('Jane', 25);

console.log('Both create similar objects:');
console.log('Constructor function person:', person1);
console.log('Class person:', person2);

// They work the same way under the hood
console.log('Same prototype mechanism:', person1.__proto__.constructor === PersonConstructor);
console.log('Same prototype mechanism:', person2.__proto__.constructor === PersonClass);

console.log('\nğŸ’¡ ES6 Classes Key Points:');
console.log('âœ… Cleaner, more readable syntax');
console.log('âœ… Built-in inheritance with extends/super');
console.log('âœ… Static methods and getters/setters');
console.log('âœ… Better tooling and IDE support');
console.log('âš ï¸ Still uses prototypes under the hood');
console.log('âš ï¸ Hoisting behavior different from functions');
console.log('âš ï¸ Always executed in strict mode');
```---


## ğŸ”’ Encapsulation: Private Fields and Methods

Modern JavaScript provides true privacy through private fields and methods, moving beyond the convention-based approach of prefixing with underscores.

### Modern Encapsulation with Private Fields

```javascript
/**
 * MODERN ENCAPSULATION: TRUE PRIVACY IN JAVASCRIPT
 * 
 * Private fields and methods (ES2022):
 * - Truly private (not accessible from outside)
 * - Declared with # prefix
 * - Compile-time enforcement
 * - Better encapsulation than convention-based approaches
 */

console.log('=== Modern Encapsulation with Private Fields ===');

/**
 * Complete Banking System with True Privacy
 */

class SecureBankAccount {
    // Private fields - truly inaccessible from outside
    #balance;
    #accountNumber;
    #pin;
    #transactionHistory = [];
    #isLocked = false;
    #failedAttempts = 0;
    
    // Public field
    accountHolder;
    
    constructor(accountHolder, initialBalance, pin) {
        // Validate inputs
        if (!accountHolder || typeof initialBalance !== 'number' || !pin) {
            throw new Error('Invalid account parameters');
        }
        
        if (initialBalance < 0) {
            throw new Error('Initial balance cannot be negative');
        }
        
        if (pin.toString().length !== 4) {
            throw new Error('PIN must be 4 digits');
        }
        
        // Set public property
        this.accountHolder = accountHolder;
        
        // Set private fields
        this.#balance = initialBalance;
        this.#pin = pin;
        this.#accountNumber = this.#generateAccountNumber();
        
        // Log account creation
        this.#logTransaction('ACCOUNT_CREATED', initialBalance, 'Account opened');
        
        console.log(`ğŸ¦ Secure account created for ${accountHolder}`);
        console.log(`ğŸ“Š Account number: ${this.getAccountNumber()}`);
    }
    
    // Public methods (API)
    
    /**
     * Authenticate user with PIN
     */
    authenticate(pin) {
        if (this.#isLocked) {
            console.log('âŒ Account is locked due to multiple failed attempts');
            return false;
        }
        
        if (pin === this.#pin) {
            this.#failedAttempts = 0;
            console.log('âœ… Authentication successful');
            return true;
        } else {
            this.#failedAttempts++;
            console.log(`âŒ Invalid PIN. Attempts: ${this.#failedAttempts}/3`);
            
            if (this.#failedAttempts >= 3) {
                this.#isLocked = true;
                console.log('ğŸ”’ Account locked due to multiple failed attempts');
            }
            
            return false;
        }
    }
    
    /**
     * Get account balance (requires authentication)
     */
    getBalance(pin) {
        if (!this.authenticate(pin)) {
            return null;
        }
        
        console.log(`ğŸ’° Current balance: $${this.#balance.toFixed(2)}`);
        return this.#balance;
    }
    
    /**
     * Deposit money
     */
    deposit(amount, pin) {
        if (!this.authenticate(pin)) {
            return false;
        }
        
        if (!this.#validateAmount(amount)) {
            return false;
        }
        
        this.#balance += amount;
        this.#logTransaction('DEPOSIT', amount, `Deposit of $${amount}`);
        
        console.log(`âœ… Deposited $${amount}. New balance: $${this.#balance.toFixed(2)}`);
        return true;
    }
    
    /**
     * Withdraw money
     */
    withdraw(amount, pin) {
        if (!this.authenticate(pin)) {
            return false;
        }
        
        if (!this.#validateAmount(amount)) {
            return false;
        }
        
        if (amount > this.#balance) {
            console.log('âŒ Insufficient funds');
            return false;
        }
        
        this.#balance -= amount;
        this.#logTransaction('WITHDRAWAL', -amount, `Withdrawal of $${amount}`);
        
        console.log(`âœ… Withdrew $${amount}. New balance: $${this.#balance.toFixed(2)}`);
        return true;
    }
    
    /**
     * Transfer money to another account
     */
    transfer(amount, targetAccount, pin) {
        if (!this.authenticate(pin)) {
            return false;
        }
        
        if (this.withdraw(amount, pin)) {
            // In a real system, this would be more complex with transaction rollback
            console.log(`ğŸ’¸ Transferring $${amount} to ${targetAccount.accountHolder}`);
            return targetAccount.deposit(amount, targetAccount.#pin); // Direct deposit for demo
        }
        
        return false;
    }
    
    /**
     * Get transaction history (requires authentication)
     */
    getTransactionHistory(pin) {
        if (!this.authenticate(pin)) {
            return null;
        }
        
        console.log('ğŸ“‹ Transaction History:');
        this.#transactionHistory.forEach((transaction, index) => {
            console.log(`${index + 1}. ${transaction.date.toLocaleString()} - ${transaction.type}: $${Math.abs(transaction.amount).toFixed(2)} - ${transaction.description}`);
        });
        
        return [...this.#transactionHistory]; // Return copy
    }
    
    /**
     * Get account number (masked for security)
     */
    getAccountNumber() {
        const masked = this.#accountNumber.slice(0, 4) + '****' + this.#accountNumber.slice(-4);
        return masked;
    }
    
    /**
     * Change PIN (requires old PIN)
     */
    changePin(oldPin, newPin) {
        if (!this.authenticate(oldPin)) {
            return false;
        }
        
        if (newPin.toString().length !== 4) {
            console.log('âŒ New PIN must be 4 digits');
            return false;
        }
        
        this.#pin = newPin;
        this.#logTransaction('PIN_CHANGE', 0, 'PIN changed successfully');
        console.log('âœ… PIN changed successfully');
        return true;
    }
    
    // Private methods - truly inaccessible from outside
    
    #generateAccountNumber() {
        // Generate a random 12-digit account number
        return Math.random().toString().slice(2, 14);
    }
    
    #validateAmount(amount) {
        if (typeof amount !== 'number' || amount <= 0) {
            console.log('âŒ Invalid amount. Must be a positive number');
            return false;
        }
        
        if (amount > 10000) {
            console.log('âŒ Amount exceeds daily limit of $10,000');
            return false;
        }
        
        return true;
    }
    
    #logTransaction(type, amount, description) {
        this.#transactionHistory.push({
            date: new Date(),
            type,
            amount,
            description,
            balance: this.#balance
        });
    }
    
    // Static method for creating accounts
    static createAccount(accountHolder, initialBalance, pin) {
        try {
            return new SecureBankAccount(accountHolder, initialBalance, pin);
        } catch (error) {
            console.error('âŒ Failed to create account:', error.message);
            return null;
        }
    }
}

/**
 * Demonstration of Secure Banking System
 */

console.log('\nğŸ¦ Secure Banking System Demo:');

// Create accounts
const aliceAccount = SecureBankAccount.createAccount('Alice Johnson', 5000, 1234);
const bobAccount = SecureBankAccount.createAccount('Bob Smith', 3000, 5678);

if (aliceAccount && bobAccount) {
    console.log('\nğŸ’³ Testing Account Operations:');
    
    // Test authentication
    console.log('\nğŸ” Authentication Tests:');
    aliceAccount.getBalance(1111); // Wrong PIN
    aliceAccount.getBalance(1234); // Correct PIN
    
    // Test transactions
    console.log('\nğŸ’° Transaction Tests:');
    aliceAccount.deposit(500, 1234);
    aliceAccount.withdraw(200, 1234);
    
    // Test transfer
    console.log('\nğŸ’¸ Transfer Test:');
    aliceAccount.transfer(1000, bobAccount, 1234);
    
    // Check balances
    console.log('\nğŸ“Š Final Balances:');
    aliceAccount.getBalance(1234);
    bobAccount.getBalance(5678);
    
    // Test transaction history
    console.log('\nğŸ“‹ Alice\'s Transaction History:');
    aliceAccount.getTransactionHistory(1234);
    
    // Test PIN change
    console.log('\nğŸ”‘ PIN Change Test:');
    aliceAccount.changePin(1234, 9999);
    aliceAccount.getBalance(9999); // Test new PIN
}

/**
 * Privacy Demonstration - Try to access private fields
 */

console.log('\nğŸ”’ Privacy Demonstration:');

if (aliceAccount) {
    console.log('Trying to access private fields from outside...');
    
    try {
        console.log('aliceAccount.#balance:', aliceAccount.#balance);
    } catch (error) {
        console.log('âŒ Cannot access #balance:', error.message);
    }
    
    try {
        console.log('aliceAccount.#pin:', aliceAccount.#pin);
    } catch (error) {
        console.log('âŒ Cannot access #pin:', error.message);
    }
    
    try {
        aliceAccount.#logTransaction('HACK', 1000000, 'Hacking attempt');
    } catch (error) {
        console.log('âŒ Cannot call private method #logTransaction:', error.message);
    }
    
    // Public properties are still accessible
    console.log('âœ… Can access public property accountHolder:', aliceAccount.accountHolder);
}

/**
 * Advanced Encapsulation Patterns
 */

console.log('\nğŸ¯ Advanced Encapsulation Patterns:');

class SmartDevice {
    // Private fields for device state
    #deviceId;
    #isOnline = false;
    #batteryLevel = 100;
    #settings = {};
    #eventListeners = new Map();
    
    // Public fields
    name;
    model;
    
    constructor(name, model) {
        this.name = name;
        this.model = model;
        this.#deviceId = this.#generateDeviceId();
        
        // Start device monitoring
        this.#startMonitoring();
        
        console.log(`ğŸ“± Smart device created: ${name} (${model})`);
    }
    
    // Public API
    
    turnOn() {
        if (this.#isOnline) {
            console.log(`${this.name} is already on`);
            return;
        }
        
        this.#isOnline = true;
        this.#emit('deviceOn', { deviceId: this.#deviceId });
        console.log(`âœ… ${this.name} turned on`);
    }
    
    turnOff() {
        if (!this.#isOnline) {
            console.log(`${this.name} is already off`);
            return;
        }
        
        this.#isOnline = false;
        this.#emit('deviceOff', { deviceId: this.#deviceId });
        console.log(`âŒ ${this.name} turned off`);
    }
    
    getBatteryLevel() {
        return this.#batteryLevel;
    }
    
    getStatus() {
        return {
            name: this.name,
            model: this.model,
            isOnline: this.#isOnline,
            batteryLevel: this.#batteryLevel,
            deviceId: this.#deviceId.slice(0, 8) + '...' // Masked ID
        };
    }
    
    updateSetting(key, value) {
        this.#settings[key] = value;
        this.#emit('settingChanged', { key, value });
        console.log(`âš™ï¸ Setting updated: ${key} = ${value}`);
    }
    
    getSetting(key) {
        return this.#settings[key];
    }
    
    // Event system
    addEventListener(event, callback) {
        if (!this.#eventListeners.has(event)) {
            this.#eventListeners.set(event, []);
        }
        this.#eventListeners.get(event).push(callback);
    }
    
    removeEventListener(event, callback) {
        const listeners = this.#eventListeners.get(event);
        if (listeners) {
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }
    
    // Private methods
    
    #generateDeviceId() {
        return 'device_' + Math.random().toString(36).substr(2, 16);
    }
    
    #emit(event, data) {
        const listeners = this.#eventListeners.get(event) || [];
        listeners.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error('Event listener error:', error);
            }
        });
    }
    
    #startMonitoring() {
        // Simulate battery drain
        setInterval(() => {
            if (this.#isOnline && this.#batteryLevel > 0) {
                this.#batteryLevel = Math.max(0, this.#batteryLevel - 1);
                
                if (this.#batteryLevel === 0) {
                    this.#isOnline = false;
                    this.#emit('batteryDepleted', { deviceId: this.#deviceId });
                    console.log(`ğŸ”‹ ${this.name} battery depleted - device turned off`);
                }
            }
        }, 2000); // Drain 1% every 2 seconds for demo
    }
    
    // Static factory method
    static createSmartPhone(name) {
        return new SmartDevice(name, 'SmartPhone Pro');
    }
    
    static createSmartWatch(name) {
        return new SmartDevice(name, 'SmartWatch Elite');
    }
}

// Demonstrate advanced encapsulation
console.log('\nğŸ“± Smart Device Demo:');

const phone = SmartDevice.createSmartPhone('My iPhone');
const watch = SmartDevice.createSmartWatch('My Apple Watch');

// Set up event listeners
phone.addEventListener('deviceOn', (data) => {
    console.log('ğŸ“± Phone turned on event received');
});

phone.addEventListener('batteryDepleted', (data) => {
    console.log('ğŸ”‹ Phone battery depleted event received');
});

// Test device operations
phone.turnOn();
phone.updateSetting('brightness', 80);
phone.updateSetting('volume', 50);

console.log('Phone status:', phone.getStatus());
console.log('Phone brightness setting:', phone.getSetting('brightness'));

// Watch the battery drain (will turn off automatically when depleted)
console.log('ğŸ”‹ Monitoring battery drain...');

console.log('\nğŸ’¡ Modern Encapsulation Benefits:');
console.log('âœ… True privacy - fields/methods are genuinely inaccessible');
console.log('âœ… Compile-time enforcement - errors caught early');
console.log('âœ… Better IDE support - autocomplete knows what\'s private');
console.log('âœ… Cleaner API - only public interface is visible');
console.log('âœ… Security - sensitive data cannot be accessed externally');
console.log('âœ… Maintainability - internal changes don\'t affect external code');
```

---

## ğŸ”— Method Chaining and Fluent Interfaces

Method chaining allows you to call multiple methods on the same object in a single statement, creating more readable and expressive code.

### Implementing Method Chaining

```javascript
/**
 * METHOD CHAINING: CREATING FLUENT INTERFACES
 * 
 * Method chaining enables:
 * - More readable and expressive code
 * - Fluent interfaces that read like natural language
 * - Reduced intermediate variables
 * - Better developer experience
 * 
 * Key principle: Return 'this' from methods to enable chaining
 */

console.log('=== Method Chaining and Fluent Interfaces ===');

/**
 * Example 1: Chainable Calculator
 */

class Calculator {
    constructor(initialValue = 0) {
        this.value = initialValue;
        this.history = [];
        console.log(`ğŸ§® Calculator initialized with value: ${initialValue}`);
    }
    
    // Arithmetic operations (return this for chaining)
    add(number) {
        this.#logOperation('add', number, this.value);
        this.value += number;
        return this; // Enable chaining
    }
    
    subtract(number) {
        this.#logOperation('subtract', number, this.value);
        this.value -= number;
        return this;
    }
    
    multiply(number) {
        this.#logOperation('multiply', number, this.value);
        this.value *= number;
        return this;
    }
    
    divide(number) {
        if (number === 0) {
            throw new Error('Cannot divide by zero');
        }
        this.#logOperation('divide', number, this.value);
        this.value /= number;
        return this;
    }
    
    power(exponent) {
        this.#logOperation('power', exponent, this.value);
        this.value = Math.pow(this.value, exponent);
        return this;
    }
    
    sqrt() {
        if (this.value < 0) {
            throw new Error('Cannot take square root of negative number');
        }
        this.#logOperation('sqrt', null, this.value);
        this.value = Math.sqrt(this.value);
        return this;
    }
    
    // Utility methods
    round(decimals = 0) {
        this.value = Number(this.value.toFixed(decimals));
        return this;
    }
    
    abs() {
        this.value = Math.abs(this.value);
        return this;
    }
    
    // Terminal methods (end the chain)
    getValue() {
        return this.value;
    }
    
    getResult() {
        console.log(`ğŸ“Š Final result: ${this.value}`);
        return this.value;
    }
    
    getHistory() {
        console.log('ğŸ“‹ Calculation History:');
        this.history.forEach((entry, index) => {
            console.log(`  ${index + 1}. ${entry}`);
        });
        return this.history;
    }
    
    reset() {
        this.value = 0;
        this.history = [];
        console.log('ğŸ”„ Calculator reset');
        return this;
    }
    
    // Private method for logging
    #logOperation(operation, operand, previousValue) {
        let description;
        if (operand !== null) {
            description = `${operation}(${operand}): ${previousValue} â†’ ${this.value}`;
        } else {
            description = `${operation}(): ${previousValue} â†’ ${this.value}`;
        }
        this.history.push(description);
    }
}

// Demonstrate method chaining
console.log('\nğŸ§® Calculator Method Chaining Demo:');

const calc = new Calculator(10);

// Chain multiple operations
const result = calc
    .add(5)           // 10 + 5 = 15
    .multiply(2)      // 15 * 2 = 30
    .subtract(10)     // 30 - 10 = 20
    .divide(4)        // 20 / 4 = 5
    .power(2)         // 5^2 = 25
    .sqrt()           // âˆš25 = 5
    .round(2)         // Round to 2 decimals
    .getResult();     // Terminal method

calc.getHistory();

/**
 * Example 2: Fluent Query Builder
 */

console.log('\nğŸ” Fluent Query Builder:');

class QueryBuilder {
    constructor() {
        this.query = {
            select: [],
            from: '',
            where: [],
            orderBy: [],
            limit: null,
            offset: null
        };
    }
    
    // SELECT clause
    select(...fields) {
        this.query.select.push(...fields);
        return this;
    }
    
    // FROM clause
    from(table) {
        this.query.from = table;
        return this;
    }
    
    // WHERE clause
    where(condition) {
        this.query.where.push(condition);
        return this;
    }
    
    // AND condition (alias for where)
    and(condition) {
        return this.where(condition);
    }
    
    // OR condition
    or(condition) {
        if (this.query.where.length > 0) {
            const lastCondition = this.query.where.pop();
            this.query.where.push(`(${lastCondition} OR ${condition})`);
        } else {
            this.query.where.push(condition);
        }
        return this;
    }
    
    // ORDER BY clause
    orderBy(field, direction = 'ASC') {
        this.query.orderBy.push(`${field} ${direction}`);
        return this;
    }
    
    // LIMIT clause
    limit(count) {
        this.query.limit = count;
        return this;
    }
    
    // OFFSET clause
    offset(count) {
        this.query.offset = count;
        return this;
    }
    
    // Terminal method - build the SQL
    build() {
        let sql = '';
        
        // SELECT
        if (this.query.select.length > 0) {
            sql += `SELECT ${this.query.select.join(', ')}`;
        } else {
            sql += 'SELECT *';
        }
        
        // FROM
        if (this.query.from) {
            sql += ` FROM ${this.query.from}`;
        }
        
        // WHERE
        if (this.query.where.length > 0) {
            sql += ` WHERE ${this.query.where.join(' AND ')}`;
        }
        
        // ORDER BY
        if (this.query.orderBy.length > 0) {
            sql += ` ORDER BY ${this.query.orderBy.join(', ')}`;
        }
        
        // LIMIT
        if (this.query.limit !== null) {
            sql += ` LIMIT ${this.query.limit}`;
        }
        
        // OFFSET
        if (this.query.offset !== null) {
            sql += ` OFFSET ${this.query.offset}`;
        }
        
        return sql;
    }
    
    // Terminal method - execute (simulated)
    execute() {
        const sql = this.build();
        console.log(`ğŸ—„ï¸ Executing SQL: ${sql}`);
        
        // Simulate execution result
        return {
            sql: sql,
            rows: Math.floor(Math.random() * 100),
            executionTime: Math.random() * 100
        };
    }
    
    // Reset for reuse
    reset() {
        this.query = {
            select: [],
            from: '',
            where: [],
            orderBy: [],
            limit: null,
            offset: null
        };
        return this;
    }
}

// Demonstrate fluent query building
const query = new QueryBuilder();

const result1 = query
    .select('id', 'name', 'email')
    .from('users')
    .where('age > 18')
    .and('status = "active"')
    .orderBy('name', 'ASC')
    .limit(10)
    .execute();

console.log('Query result:', result1);

// Build another query with the same builder
const result2 = query
    .reset()
    .select('product_name', 'price')
    .from('products')
    .where('category = "electronics"')
    .or('category = "computers"')
    .orderBy('price', 'DESC')
    .limit(5)
    .execute();

console.log('Second query result:', result2);

/**
 * Example 3: Fluent Animation Builder
 */

console.log('\nğŸ¬ Fluent Animation Builder:');

class AnimationBuilder {
    constructor(element) {
        this.element = element;
        this.animations = [];
        this.duration = 1000; // Default duration
        this.easing = 'ease'; // Default easing
    }
    
    // Transform methods
    translateX(value) {
        this.animations.push(`translateX(${value}px)`);
        return this;
    }
    
    translateY(value) {
        this.animations.push(`translateY(${value}px)`);
        return this;
    }
    
    rotate(degrees) {
        this.animations.push(`rotate(${degrees}deg)`);
        return this;
    }
    
    scale(factor) {
        this.animations.push(`scale(${factor})`);
        return this;
    }
    
    // Style methods
    opacity(value) {
        this.animations.push({ opacity: value });
        return this;
    }
    
    backgroundColor(color) {
        this.animations.push({ backgroundColor: color });
        return this;
    }
    
    // Animation configuration
    duration(ms) {
        this.duration = ms;
        return this;
    }
    
    easing(easingFunction) {
        this.easing = easingFunction;
        return this;
    }
    
    // Terminal method - execute animation
    animate() {
        console.log(`ğŸ¬ Animating element with ${this.animations.length} properties`);
        
        // Separate transforms from other styles
        const transforms = this.animations.filter(anim => typeof anim === 'string');
        const styles = this.animations.filter(anim => typeof anim === 'object');
        
        // Apply transform
        if (transforms.length > 0) {
            console.log(`   Transform: ${transforms.join(' ')}`);
        }
        
        // Apply styles
        styles.forEach(style => {
            Object.entries(style).forEach(([prop, value]) => {
                console.log(`   ${prop}: ${value}`);
            });
        });
        
        console.log(`   Duration: ${this.duration}ms, Easing: ${this.easing}`);
        
        // In a real implementation, this would apply CSS transitions/animations
        return new Promise(resolve => {
            setTimeout(() => {
                console.log('âœ… Animation completed');
                resolve(this);
            }, 100); // Simulate animation time
        });
    }
    
    // Reset for reuse
    reset() {
        this.animations = [];
        this.duration = 1000;
        this.easing = 'ease';
        return this;
    }
}

// Demonstrate fluent animation
const animationBuilder = new AnimationBuilder('myElement');

animationBuilder
    .translateX(100)
    .translateY(50)
    .rotate(45)
    .scale(1.2)
    .opacity(0.8)
    .backgroundColor('blue')
    .duration(2000)
    .easing('ease-in-out')
    .animate()
    .then(() => {
        console.log('ğŸ‰ Animation chain completed!');
        
        // Chain another animation
        return animationBuilder
            .reset()
            .translateX(0)
            .translateY(0)
            .rotate(0)
            .scale(1)
            .opacity(1)
            .duration(1000)
            .animate();
    })
    .then(() => {
        console.log('ğŸ Return animation completed!');
    });

/**
 * Best Practices for Method Chaining
 */

console.log('\nğŸ“‹ Method Chaining Best Practices:');

class BestPracticesExample {
    constructor() {
        this.data = [];
        this.config = {};
    }
    
    // âœ… Good: Always return this for chainable methods
    addItem(item) {
        this.data.push(item);
        return this; // Enables chaining
    }
    
    // âœ… Good: Provide both chainable and non-chainable versions
    setConfig(key, value) {
        this.config[key] = value;
        return this; // Chainable version
    }
    
    getConfig(key) {
        return this.config[key]; // Non-chainable (returns value)
    }
    
    // âœ… Good: Validate parameters and provide meaningful errors
    setLimit(limit) {
        if (typeof limit !== 'number' || limit < 0) {
            throw new Error('Limit must be a non-negative number');
        }
        this.config.limit = limit;
        return this;
    }
    
    // âœ… Good: Provide terminal methods that end the chain
    execute() {
        console.log('Executing with data:', this.data);
        console.log('Config:', this.config);
        return { success: true, processedItems: this.data.length };
    }
    
    // âœ… Good: Allow method chaining to be optional
    process(callback) {
        if (callback) {
            callback(this.data);
        }
        return this; // Still chainable even with callback
    }
}

console.log('\nâœ… Best Practices Demo:');

const example = new BestPracticesExample();

// Fluent interface usage
const result = example
    .addItem('item1')
    .addItem('item2')
    .setConfig('debug', true)
    .setLimit(10)
    .process(data => console.log('Processing:', data.length, 'items'))
    .execute();

console.log('Final result:', result);

console.log('\nğŸ’¡ Method Chaining Guidelines:');
console.log('âœ… Return "this" from methods that modify the object');
console.log('âœ… Return actual values from getter methods');
console.log('âœ… Provide terminal methods that end the chain meaningfully');
console.log('âœ… Validate parameters and provide clear error messages');
console.log('âœ… Consider providing both chainable and non-chainable APIs');
console.log('âœ… Document which methods are chainable');
console.log('âš ï¸ Don\'t force chaining where it doesn\'t make sense');
console.log('âš ï¸ Avoid overly long chains that hurt readability');
```

---

## ğŸ¯ Real-World OOP: Complete Project Example

Let's build a comprehensive task management system that demonstrates all OOP principles in a practical, real-world context.

### Task Management System

```javascript
/**
 * REAL-WORLD OOP PROJECT: TASK MANAGEMENT SYSTEM
 * 
 * This comprehensive example demonstrates:
 * - All four OOP principles (Abstraction, Encapsulation, Inheritance, Polymorphism)
 * - Modern JavaScript features (private fields, static methods, getters/setters)
 * - Design patterns (Observer, Factory, Strategy)
 * - Method chaining and fluent interfaces
 * - Error handling and validation
 * - Event-driven architecture
 */

console.log('=== Task Management System: Complete OOP Project ===');

/**
 * Base Task Class - Demonstrates Abstraction and Encapsulation
 */

class Task {
    // Private fields for true encapsulation
    #id;
    #createdAt;
    #updatedAt;
    #status = 'pending';
    #priority = 'medium';
    
    // Public fields
    title;
    description;
    
    // Static field for ID generation
    static #nextId = 1;
    
    constructor(title, description = '') {
        if (!title || title.trim().length === 0) {
            throw new Error('Task title is required');
        }
        
        this.title = title.trim();
        this.description = description.trim();
        this.#id = Task.#nextId++;
        this.#createdAt = new Date();
        this.#updatedAt = new Date();
        
        console.log(`ğŸ“ Task created: "${this.title}" (ID: ${this.#id})`);
    }
    
    // Getters for read-only access to private fields
    get id() {
        return this.#id;
    }
    
    get createdAt() {
        return new Date(this.#createdAt);
    }
    
    get updatedAt() {
        return new Date(this.#updatedAt);
    }
    
    get status() {
        return this.#status;
    }
    
    get priority() {
        return this.#priority;
    }
    
    // Setter with validation
    set priority(value) {
        const validPriorities = ['low', 'medium', 'high', 'urgent'];
        if (!validPriorities.includes(value)) {
            throw new Error(`Invalid priority. Must be one of: ${validPriorities.join(', ')}`);
        }
        this.#priority = value;
        this.#touch();
    }
    
    // Public methods
    
    /**
     * Update task status with validation
     */
    updateStatus(newStatus) {
        const validStatuses = ['pending', 'in-progress', 'completed', 'cancelled'];
        if (!validStatuses.includes(newStatus)) {
            throw new Error(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);
        }
        
        const oldStatus = this.#status;
        this.#status = newStatus;
        this.#touch();
        
        console.log(`ğŸ“Š Task ${this.#id} status: ${oldStatus} â†’ ${newStatus}`);
        return this;
    }
    
    /**
     * Update task details
     */
    update(updates) {
        if (updates.title !== undefined) {
            if (!updates.title || updates.title.trim().length === 0) {
                throw new Error('Task title cannot be empty');
            }
            this.title = updates.title.trim();
        }
        
        if (updates.description !== undefined) {
            this.description = updates.description.trim();
        }
        
        if (updates.priority !== undefined) {
            this.priority = updates.priority;
        }
        
        this.#touch();
        console.log(`âœï¸ Task ${this.#id} updated`);
        return this;
    }
    
    /**
     * Get task summary
     */
    getSummary() {
        return {
            id: this.#id,
            title: this.title,
            description: this.description,
            status: this.#status,
            priority: this.#priority,
            createdAt: this.#createdAt,
            updatedAt: this.#updatedAt
        };
    }
    
    /**
     * Check if task is overdue (to be overridden by subclasses)
     */
    isOverdue() {
        return false; // Base implementation
    }
    
    /**
     * Get time until due (to be overridden by subclasses)
     */
    getTimeUntilDue() {
        return null; // Base implementation
    }
    
    /**
     * Clone task
     */
    clone() {
        const cloned = new this.constructor(this.title, this.description);
        cloned.priority = this.#priority;
        return cloned;
    }
    
    // Private methods
    
    #touch() {
        this.#updatedAt = new Date();
    }
    
    // Static methods
    
    static createFromObject(obj) {
        const task = new Task(obj.title, obj.description);
        if (obj.priority) task.priority = obj.priority;
        if (obj.status) task.updateStatus(obj.status);
        return task;
    }
    
    static getValidStatuses() {
        return ['pending', 'in-progress', 'completed', 'cancelled'];
    }
    
    static getValidPriorities() {
        return ['low', 'medium', 'high', 'urgent'];
    }
}

/**
 * Scheduled Task - Demonstrates Inheritance
 */

class ScheduledTask extends Task {
    #dueDate;
    #reminderTime;
    
    constructor(title, description, dueDate) {
        super(title, description);
        
        if (!(dueDate instanceof Date)) {
            throw new Error('Due date must be a Date object');
        }
        
        if (dueDate <= new Date()) {
            throw new Error('Due date must be in the future');
        }
        
        this.#dueDate = new Date(dueDate);
        console.log(`â° Scheduled task created, due: ${this.#dueDate.toLocaleString()}`);
    }
    
    get dueDate() {
        return new Date(this.#dueDate);
    }
    
    set dueDate(date) {
        if (!(date instanceof Date)) {
            throw new Error('Due date must be a Date object');
        }
        
        if (date <= new Date()) {
            throw new Error('Due date must be in the future');
        }
        
        this.#dueDate = new Date(date);
        console.log(`ğŸ“… Due date updated to: ${this.#dueDate.toLocaleString()}`);
    }
    
    // Override parent method - Polymorphism
    isOverdue() {
        return new Date() > this.#dueDate && this.status !== 'completed';
    }
    
    // Override parent method - Polymorphism
    getTimeUntilDue() {
        const now = new Date();
        const timeDiff = this.#dueDate - now;
        
        if (timeDiff <= 0) {
            return { overdue: true, message: 'Task is overdue' };
        }
        
        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
        
        return {
            overdue: false,
            days,
            hours,
            minutes,
            message: `${days}d ${hours}h ${minutes}m remaining`
        };
    }
    
    setReminder(minutesBefore) {
        if (minutesBefore < 0) {
            throw new Error('Reminder time must be positive');
        }
        
        this.#reminderTime = minutesBefore;
        console.log(`â° Reminder set for ${minutesBefore} minutes before due date`);
        return this;
    }
    
    getReminder() {
        return this.#reminderTime;
    }
    
    // Override getSummary to include due date
    getSummary() {
        const baseSummary = super.getSummary();
        return {
            ...baseSummary,
            dueDate: this.#dueDate,
            isOverdue: this.isOverdue(),
            timeUntilDue: this.getTimeUntilDue()
        };
    }
}

/**
 * Recurring Task - Demonstrates Advanced Inheritance
 */

class RecurringTask extends ScheduledTask {
    #recurrencePattern;
    #nextDueDate;
    
    constructor(title, description, firstDueDate, recurrencePattern) {
        super(title, description, firstDueDate);
        
        const validPatterns = ['daily', 'weekly', 'monthly', 'yearly'];
        if (!validPatterns.includes(recurrencePattern)) {
            throw new Error(`Invalid recurrence pattern. Must be one of: ${validPatterns.join(', ')}`);
        }
        
        this.#recurrencePattern = recurrencePattern;
        this.#calculateNextDueDate();
        
        console.log(`ğŸ”„ Recurring task created with ${recurrencePattern} recurrence`);
    }
    
    get recurrencePattern() {
        return this.#recurrencePattern;
    }
    
    get nextDueDate() {
        return new Date(this.#nextDueDate);
    }
    
    // Complete and schedule next occurrence
    complete() {
        this.updateStatus('completed');
        this.#calculateNextDueDate();
        
        console.log(`âœ… Recurring task completed. Next due: ${this.#nextDueDate.toLocaleString()}`);
        return this;
    }
    
    #calculateNextDueDate() {
        const current = this.dueDate;
        const next = new Date(current);
        
        switch (this.#recurrencePattern) {
            case 'daily':
                next.setDate(next.getDate() + 1);
                break;
            case 'weekly':
                next.setDate(next.getDate() + 7);
                break;
            case 'monthly':
                next.setMonth(next.getMonth() + 1);
                break;
            case 'yearly':
                next.setFullYear(next.getFullYear() + 1);
                break;
        }
        
        this.#nextDueDate = next;
    }
    
    getSummary() {
        const baseSummary = super.getSummary();
        return {
            ...baseSummary,
            recurrencePattern: this.#recurrencePattern,
            nextDueDate: this.#nextDueDate
        };
    }
}

/**
 * Task Manager - Demonstrates Composition and Observer Pattern
 */

class TaskManager {
    #tasks = new Map();
    #observers = [];
    #filters = {
        status: null,
        priority: null,
        overdue: null
    };
    
    constructor() {
        console.log('ğŸ“‹ Task Manager initialized');
    }
    
    // Task management methods
    
    addTask(task) {
        if (!(task instanceof Task)) {
            throw new Error('Only Task instances can be added');
        }
        
        this.#tasks.set(task.id, task);
        this.#notifyObservers('taskAdded', task);
        
        console.log(`â• Task added to manager: ${task.title}`);
        return this;
    }
    
    removeTask(taskId) {
        const task = this.#tasks.get(taskId);
        if (!task) {
            throw new Error(`Task with ID ${taskId} not found`);
        }
        
        this.#tasks.delete(taskId);
        this.#notifyObservers('taskRemoved', task);
        
        console.log(`â– Task removed: ${task.title}`);
        return this;
    }
    
    getTask(taskId) {
        return this.#tasks.get(taskId);
    }
    
    getAllTasks() {
        return Array.from(this.#tasks.values());
    }
    
    // Filtering methods (Method Chaining)
    
    filterByStatus(status) {
        this.#filters.status = status;
        return this;
    }
    
    filterByPriority(priority) {
        this.#filters.priority = priority;
        return this;
    }
    
    filterOverdue(overdue = true) {
        this.#filters.overdue = overdue;
        return this;
    }
    
    clearFilters() {
        this.#filters = { status: null, priority: null, overdue: null };
        return this;
    }
    
    // Terminal method for filtering
    getFilteredTasks() {
        let tasks = this.getAllTasks();
        
        if (this.#filters.status) {
            tasks = tasks.filter(task => task.status === this.#filters.status);
        }
        
        if (this.#filters.priority) {
            tasks = tasks.filter(task => task.priority === this.#filters.priority);
        }
        
        if (this.#filters.overdue !== null) {
            tasks = tasks.filter(task => task.isOverdue() === this.#filters.overdue);
        }
        
        return tasks;
    }
    
    // Bulk operations
    
    updateMultipleTasks(taskIds, updates) {
        const updatedTasks = [];
        
        taskIds.forEach(id => {
            const task = this.#tasks.get(id);
            if (task) {
                task.update(updates);
                updatedTasks.push(task);
            }
        });
        
        this.#notifyObservers('tasksUpdated', updatedTasks);
        console.log(`ğŸ“ Updated ${updatedTasks.length} tasks`);
        
        return this;
    }
    
    completeMultipleTasks(taskIds) {
        const completedTasks = [];
        
        taskIds.forEach(id => {
            const task = this.#tasks.get(id);
            if (task && task.status !== 'completed') {
                task.updateStatus('completed');
                completedTasks.push(task);
            }
        });
        
        this.#notifyObservers('tasksCompleted', completedTasks);
        console.log(`âœ… Completed ${completedTasks.length} tasks`);
        
        return this;
    }
    
    // Statistics
    
    getStatistics() {
        const tasks = this.getAllTasks();
        const stats = {
            total: tasks.length,
            byStatus: {},
            byPriority: {},
            overdue: 0,
            completed: 0
        };
        
        tasks.forEach(task => {
            // Count by status
            stats.byStatus[task.status] = (stats.byStatus[task.status] || 0) + 1;
            
            // Count by priority
            stats.byPriority[task.priority] = (stats.byPriority[task.priority] || 0) + 1;
            
            // Count overdue
            if (task.isOverdue()) {
                stats.overdue++;
            }
            
            // Count completed
            if (task.status === 'completed') {
                stats.completed++;
            }
        });
        
        return stats;
    }
    
    // Observer pattern implementation
    
    addObserver(observer) {
        if (typeof observer !== 'function') {
            throw new Error('Observer must be a function');
        }
        this.#observers.push(observer);
        return this;
    }
    
    removeObserver(observer) {
        const index = this.#observers.indexOf(observer);
        if (index > -1) {
            this.#observers.splice(index, 1);
        }
        return this;
    }
    
    #notifyObservers(event, data) {
        this.#observers.forEach(observer => {
            try {
                observer(event, data);
            } catch (error) {
                console.error('Observer error:', error);
            }
        });
    }
    
    // Factory methods
    
    createTask(title, description) {
        const task = new Task(title, description);
        return this.addTask(task);
    }
    
    createScheduledTask(title, description, dueDate) {
        const task = new ScheduledTask(title, description, dueDate);
        return this.addTask(task);
    }
    
    createRecurringTask(title, description, firstDueDate, recurrencePattern) {
        const task = new RecurringTask(title, description, firstDueDate, recurrencePattern);
        return this.addTask(task);
    }
}

/**
 * Demonstration of the Complete System
 */

console.log('\nğŸš€ Task Management System Demo:');

// Create task manager
const taskManager = new TaskManager();

// Add observer for logging
taskManager.addObserver((event, data) => {
    console.log(`ğŸ”” Event: ${event}`, data instanceof Array ? `(${data.length} items)` : `- ${data.title || data.id}`);
});

// Create various types of tasks
console.log('\nğŸ“ Creating Tasks:');

// Regular tasks
taskManager.createTask('Review code', 'Review pull request #123');
taskManager.createTask('Write documentation', 'Update API documentation');

// Scheduled tasks
const tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);
tomorrow.setHours(14, 0, 0, 0);

const nextWeek = new Date();
nextWeek.setDate(nextWeek.getDate() + 7);
nextWeek.setHours(10, 0, 0, 0);

taskManager.createScheduledTask('Team meeting', 'Weekly team standup', tomorrow);
taskManager.createScheduledTask('Project deadline', 'Complete project deliverables', nextWeek);

// Recurring task
const dailyStandup = new Date();
dailyStandup.setDate(dailyStandup.getDate() + 1);
dailyStandup.setHours(9, 0, 0, 0);

taskManager.createRecurringTask('Daily standup', 'Daily team check-in', dailyStandup, 'daily');

// Demonstrate method chaining and filtering
console.log('\nğŸ” Filtering and Operations:');

// Get all pending tasks
const pendingTasks = taskManager
    .clearFilters()
    .filterByStatus('pending')
    .getFilteredTasks();

console.log(`Found ${pendingTasks.length} pending tasks`);

// Update multiple tasks
const taskIds = pendingTasks.slice(0, 2).map(task => task.id);
taskManager.updateMultipleTasks(taskIds, { priority: 'high' });

// Get high priority tasks
const highPriorityTasks = taskManager
    .clearFilters()
    .filterByPriority('high')
    .getFilteredTasks();

console.log(`Found ${highPriorityTasks.length} high priority tasks`);

// Complete some tasks
taskManager.completeMultipleTasks([taskIds[0]]);

// Show statistics
console.log('\nğŸ“Š Task Statistics:');
const stats = taskManager.getStatistics();
console.log('Total tasks:', stats.total);
console.log('By status:', stats.byStatus);
console.log('By priority:', stats.byPriority);
console.log('Overdue tasks:', stats.overdue);
console.log('Completed tasks:', stats.completed);

// Demonstrate polymorphism
console.log('\nğŸ­ Polymorphism Demo:');
const allTasks = taskManager.getAllTasks();

allTasks.forEach(task => {
    console.log(`\nTask: ${task.title}`);
    console.log(`  Type: ${task.constructor.name}`);
    console.log(`  Status: ${task.status}`);
    console.log(`  Is overdue: ${task.isOverdue()}`);
    
    const timeInfo = task.getTimeUntilDue();
    if (timeInfo) {
        console.log(`  Time info: ${timeInfo.message}`);
    }
});

console.log('\nğŸ‰ Task Management System Demo Complete!');

console.log('\nğŸ’¡ OOP Principles Demonstrated:');
console.log('âœ… Abstraction - Complex task management hidden behind simple API');
console.log('âœ… Encapsulation - Private fields protect internal state');
console.log('âœ… Inheritance - ScheduledTask and RecurringTask extend Task');
console.log('âœ… Polymorphism - Same methods behave differently for different task types');
console.log('âœ… Method Chaining - Fluent interface for filtering');
console.log('âœ… Observer Pattern - Event-driven architecture');
console.log('âœ… Factory Pattern - TaskManager creates different task types');
console.log('âœ… Composition - TaskManager contains and manages tasks');
```

---

## ğŸ“ Summary and Best Practices

### Key Takeaways

```
ğŸ† OOP Mastery Checklist:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Understand the four pillars of OOP                      â”‚
â”‚ âœ… Master JavaScript's prototypal inheritance              â”‚
â”‚ âœ… Use ES6 classes for modern, clean syntax                â”‚
â”‚ âœ… Implement true encapsulation with private fields        â”‚
â”‚ âœ… Apply inheritance and polymorphism appropriately        â”‚
â”‚ âœ… Create fluent interfaces with method chaining           â”‚
â”‚ âœ… Follow OOP best practices and design patterns           â”‚
â”‚ âœ… Build real-world applications with OOP principles       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### When to Use OOP in JavaScript

**âœ… Use OOP when:**
- Building complex applications with multiple related entities
- Need to model real-world relationships and behaviors
- Working in teams where clear structure is important
- Creating reusable components or libraries
- Managing state and behavior together
- Need inheritance and polymorphism

**âŒ Consider alternatives when:**
- Building simple, functional applications
- Working with data transformations (functional programming might be better)
- Performance is critical (functional approaches can be faster)
- The problem domain doesn't map well to objects

### Best Practices Summary

1. **Design Principles**
   - Favor composition over inheritance
   - Program to interfaces, not implementations
   - Keep classes focused and cohesive
   - Use dependency injection for flexibility

2. **Code Organization**
   - Use meaningful class and method names
   - Keep methods small and focused
   - Group related functionality together
   - Separate concerns appropriately

3. **Modern JavaScript**
   - Use ES6 classes for cleaner syntax
   - Implement true privacy with private fields
   - Leverage static methods for utilities
   - Use getters/setters for controlled access

4. **Performance Considerations**
   - Add methods to prototypes, not constructors
   - Be mindful of prototype chain depth
   - Use object pooling for frequently created objects
   - Consider memory usage with large object hierarchies

You've now mastered Object-Oriented Programming in JavaScript! These concepts will help you build scalable, maintainable applications with clean, organized code. ğŸš€