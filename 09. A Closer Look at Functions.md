# 🔧 9. A Closer Look at Functions

> **Ultimate JavaScript Functions Masterclass** - Master advanced function concepts, closures, and functional programming patterns

---

## 🎯 What You'll Master

```
🚀 Advanced Function Concepts:
┌─────────────────────────────────────────────────────────────┐
│ • Default Parameters & Function Signatures                  │
│ • Value vs Reference Parameter Passing                     │
│ • First-Class & Higher-Order Functions                     │
│ • Callback Functions & Function Composition                │
│ • call(), apply(), and bind() Methods                      │
│ • Closures & Lexical Scoping                              │
│ • IIFE (Immediately Invoked Function Expressions)         │
│ • Functional Programming Patterns                          │
└─────────────────────────────────────────────────────────────┘
```

---

## ⚙️ Default Parameters

### Basic Default Parameters

```javascript
// ❌ Old ES5 way
function createBookingOld(flightNum, numPassengers, price) {
    numPassengers = numPassengers || 1;
    price = price || 199;
    
    console.log(`Flight: ${flightNum}, Passengers: ${numPassengers}, Price: $${price}`);
}

// ✅ Modern ES6+ way with default parameters
function createBooking(flightNum, numPassengers = 1, price = 199 * numPassengers) {
    const booking = {
        flightNum,
        numPassengers,
        price
    };
    
    console.log(booking);
    return booking;
}

// Testing default parameters
createBooking('LH123');
// Output: { flightNum: 'LH123', numPassengers: 1, price: 199 }

createBooking('LH123', 2);
// Output: { flightNum: 'LH123', numPassengers: 2, price: 398 }

createBooking('LH123', 2, 800);
// Output: { flightNum: 'LH123', numPassengers: 2, price: 800 }

// Skipping parameters with undefined
createBooking('LH123', undefined, 1000);
// Output: { flightNum: 'LH123', numPassengers: 1, price: 1000 }
```

### Advanced Default Parameter Patterns

```javascript
// Using previous parameters in default values
function calculateShipping(weight, distance = 100, rate = weight * 0.1) {
    const cost = weight * distance * rate;
    console.log(`Shipping ${weight}kg for ${distance}km at rate ${rate}: $${cost.toFixed(2)}`);
    return cost;
}

calculateShipping(5);
// Output: Shipping 5kg for 100km at rate 0.5: $250.00

calculateShipping(5, 200);
// Output: Shipping 5kg for 200km at rate 0.5: $500.00

// Complex default values with functions
function getCurrentDate() {
    return new Date().toISOString().split('T')[0];
}

function createEvent(title, date = getCurrentDate(), attendees = []) {
    console.log(`Event: ${title} on ${date} with ${attendees.length} attendees`);
    return { title, date, attendees };
}

createEvent('Team Meeting');
// Output: Event: Team Meeting on 2024-01-15 with 0 attendees

createEvent('Conference', '2024-02-01', ['John', 'Jane']);
// Output: Event: Conference on 2024-02-01 with 2 attendees

// Default parameters with destructuring
function processUser({ 
    name, 
    age = 18, 
    role = 'user', 
    permissions = ['read'] 
} = {}) {
    console.log(`User: ${name}, Age: ${age}, Role: ${role}`);
    console.log(`Permissions: ${permissions.join(', ')}`);
    return { name, age, role, permissions };
}

processUser({ name: 'Alice' });
// Output: User: Alice, Age: 18, Role: user
//         Permissions: read

processUser({ name: 'Bob', age: 25, role: 'admin', permissions: ['read', 'write', 'delete'] });
// Output: User: Bob, Age: 25, Role: admin
//         Permissions: read, write, delete

processUser(); // Empty object as default
// Output: User: undefined, Age: 18, Role: user
//         Permissions: read
```

### Real-World Default Parameters

```javascript
// API configuration with defaults
function makeApiRequest(
    endpoint,
    method = 'GET',
    headers = { 'Content-Type': 'application/json' },
    timeout = 5000,
    retries = 3
) {
    console.log(`Making ${method} request to ${endpoint}`);
    console.log(`Headers:`, headers);
    console.log(`Timeout: ${timeout}ms, Retries: ${retries}`);
    
    // Simulate API call
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({ status: 200, data: 'Success' });
        }, 1000);
    });
}

// Usage examples
makeApiRequest('/users');
// Output: Making GET request to /users
//         Headers: { 'Content-Type': 'application/json' }
//         Timeout: 5000ms, Retries: 3

makeApiRequest('/users', 'POST', { 'Authorization': 'Bearer token' });
// Output: Making POST request to /users
//         Headers: { 'Authorization': 'Bearer token' }
//         Timeout: 5000ms, Retries: 3

// Database connection with defaults
function connectDatabase(
    host = 'localhost',
    port = 5432,
    database = 'myapp',
    options = { ssl: false, poolSize: 10 }
) {
    console.log(`Connecting to ${database} at ${host}:${port}`);
    console.log(`Options:`, options);
    
    return {
        host,
        port,
        database,
        connected: true,
        ...options
    };
}

const db1 = connectDatabase();
console.log(db1);
// Output: Connecting to myapp at localhost:5432
//         Options: { ssl: false, poolSize: 10 }
//         { host: 'localhost', port: 5432, database: 'myapp', connected: true, ssl: false, poolSize: 10 }

const db2 = connectDatabase('prod-server', 3306, 'production', { ssl: true, poolSize: 20 });
console.log(db2);
// Output: Connecting to production at prod-server:3306
//         Options: { ssl: true, poolSize: 20 }
//         { host: 'prod-server', port: 3306, database: 'production', connected: true, ssl: true, poolSize: 20 }
```

---

## 📦 How Passing Arguments Works: Value vs Reference

### Understanding the Difference

```
📊 Value vs Reference Passing:
┌─────────────────────────────────────────────────────────────┐
│                    PRIMITIVE TYPES                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │ Passed by VALUE (copy created)                          │ │
│  │ • Numbers, Strings, Booleans                           │ │
│  │ • Changes inside function don't affect original        │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                             │
│                   REFERENCE TYPES                           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │ Passed by REFERENCE (same object)                      │ │
│  │ • Objects, Arrays, Functions                           │ │
│  │ • Changes inside function affect original              │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Primitive Types - Pass by Value

```javascript
// Primitive types are copied when passed to functions
function modifyPrimitive(num, str, bool) {
    console.log('Inside function - before modification:');
    console.log(`num: ${num}, str: ${str}, bool: ${bool}`);
    
    // Modify the parameters
    num = 999;
    str = 'modified';
    bool = !bool;
    
    console.log('Inside function - after modification:');
    console.log(`num: ${num}, str: ${str}, bool: ${bool}`);
}

// Original values
let originalNum = 42;
let originalStr = 'hello';
let originalBool = true;

console.log('Before function call:');
console.log(`originalNum: ${originalNum}, originalStr: ${originalStr}, originalBool: ${originalBool}`);

modifyPrimitive(originalNum, originalStr, originalBool);

console.log('After function call:');
console.log(`originalNum: ${originalNum}, originalStr: ${originalStr}, originalBool: ${originalBool}`);

// Output:
// Before function call: originalNum: 42, originalStr: hello, originalBool: true
// Inside function - before modification: num: 42, str: hello, bool: true
// Inside function - after modification: num: 999, str: modified, bool: false
// After function call: originalNum: 42, originalStr: hello, originalBool: true
// (Original values unchanged!)
```

### Reference Types - Pass by Reference

```javascript
// Objects are passed by reference
function modifyObject(obj, arr) {
    console.log('Inside function - before modification:');
    console.log('obj:', obj);
    console.log('arr:', arr);
    
    // Modify object properties
    obj.name = 'Modified Name';
    obj.newProperty = 'Added Property';
    
    // Modify array
    arr.push('new item');
    arr[0] = 'modified first item';
    
    console.log('Inside function - after modification:');
    console.log('obj:', obj);
    console.log('arr:', arr);
}

// Original objects
const originalObj = { name: 'John', age: 30 };
const originalArr = ['item1', 'item2', 'item3'];

console.log('Before function call:');
console.log('originalObj:', originalObj);
console.log('originalArr:', originalArr);

modifyObject(originalObj, originalArr);

console.log('After function call:');
console.log('originalObj:', originalObj);
console.log('originalArr:', originalArr);

// Output:
// Before function call: originalObj: { name: 'John', age: 30 }
//                      originalArr: ['item1', 'item2', 'item3']
// Inside function - after modification: obj: { name: 'Modified Name', age: 30, newProperty: 'Added Property' }
//                                      arr: ['modified first item', 'item2', 'item3', 'new item']
// After function call: originalObj: { name: 'Modified Name', age: 30, newProperty: 'Added Property' }
//                     originalArr: ['modified first item', 'item2', 'item3', 'new item']
// (Original objects were modified!)
```

### Real-World Example: Flight Check-in System

```javascript
// Flight check-in system demonstrating value vs reference
const flight = 'LH234';
const passenger = {
    name: 'Jonas Schmedtmann',
    passport: 24739479284,
    checkedIn: false
};

function checkIn(flightNum, passengerObj) {
    // This won't affect the original flight variable (primitive)
    flightNum = 'LH999';
    
    // This WILL affect the original passenger object (reference)
    passengerObj.name = 'Mr. ' + passengerObj.name;
    passengerObj.checkedIn = true;
    
    console.log(`Passenger ${passengerObj.name} checked in for flight ${flightNum}`);
    
    if (passengerObj.passport === 24739479284) {
        console.log('✅ Passport verified - Check-in successful');
    } else {
        console.log('❌ Wrong passport number');
    }
}

console.log('Before check-in:');
console.log(`Flight: ${flight}`);
console.log('Passenger:', passenger);

checkIn(flight, passenger);

console.log('After check-in:');
console.log(`Flight: ${flight}`); // Unchanged
console.log('Passenger:', passenger); // Modified!

// Output:
// Before check-in: Flight: LH234, Passenger: { name: 'Jonas Schmedtmann', passport: 24739479284, checkedIn: false }
// Passenger Mr. Jonas Schmedtmann checked in for flight LH999
// ✅ Passport verified - Check-in successful
// After check-in: Flight: LH234, Passenger: { name: 'Mr. Jonas Schmedtmann', passport: 24739479284, checkedIn: true }

// Dangerous side effect example
function issueNewPassport(person) {
    person.passport = Math.trunc(Math.random() * 100000000000);
    console.log(`New passport issued: ${person.passport}`);
}

// This will modify the original passenger object
issueNewPassport(passenger);
console.log('Passenger after new passport:', passenger);

// Now check-in will fail because passport number changed
checkIn(flight, passenger);
// Output: ❌ Wrong passport number
```

### Best Practices for Parameter Passing

```javascript
// ✅ Good: Create copies to avoid side effects
function safeModifyObject(obj) {
    // Create a shallow copy
    const objCopy = { ...obj };
    objCopy.modified = true;
    return objCopy;
}

// ✅ Good: Create deep copies for nested objects
function deepCopyModify(obj) {
    const deepCopy = JSON.parse(JSON.stringify(obj));
    deepCopy.nested.value = 'modified';
    return deepCopy;
}

// ✅ Good: Use immutable operations
function addToArray(arr, item) {
    return [...arr, item]; // Returns new array
}

// ✅ Good: Explicit mutation with clear naming
function mutateUserProfile(user) {
    // Function name makes it clear this will modify the original
    user.lastModified = new Date();
    user.version++;
}

// Example usage
const originalUser = { name: 'Alice', version: 1 };
const modifiedUser = safeModifyObject(originalUser);

console.log('Original:', originalUser);   // Unchanged
console.log('Modified:', modifiedUser);   // Has new property

const originalArray = [1, 2, 3];
const newArray = addToArray(originalArray, 4);

console.log('Original array:', originalArray); // [1, 2, 3]
console.log('New array:', newArray);           // [1, 2, 3, 4]
```---

## 
🎭 First-Class and Higher-Order Functions

### Understanding First-Class Functions

```
🎯 First-Class Functions Concept:
┌─────────────────────────────────────────────────────────────┐
│ Functions are VALUES in JavaScript                          │
│                                                             │
│ ✅ Can be stored in variables                               │
│ ✅ Can be passed as arguments                               │
│ ✅ Can be returned from functions                           │
│ ✅ Can be stored in data structures                         │
│ ✅ Can have properties and methods                          │
└─────────────────────────────────────────────────────────────┘
```

```javascript
// Functions as values - stored in variables
const greet = function(name) {
    return `Hello, ${name}!`;
};

const sayHi = (name) => `Hi, ${name}!`;

console.log(typeof greet); // Output: function
console.log(greet('Alice')); // Output: Hello, Alice!

// Functions stored in arrays
const greetings = [
    function(name) { return `Hello, ${name}!`; },
    (name) => `Hi, ${name}!`,
    (name) => `Hey there, ${name}!`
];

greetings.forEach((greetFn, index) => {
    console.log(`Greeting ${index + 1}: ${greetFn('Bob')}`);
});
// Output: Greeting 1: Hello, Bob!
//         Greeting 2: Hi, Bob!
//         Greeting 3: Hey there, Bob!

// Functions stored in objects
const mathOperations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => b !== 0 ? a / b : 'Cannot divide by zero'
};

console.log(mathOperations.add(5, 3));      // Output: 8
console.log(mathOperations.divide(10, 2));  // Output: 5
console.log(mathOperations.divide(10, 0));  // Output: Cannot divide by zero

// Functions with properties (functions are objects!)
function counter() {
    counter.count = (counter.count || 0) + 1;
    return counter.count;
}

console.log(counter()); // Output: 1
console.log(counter()); // Output: 2
console.log(counter()); // Output: 3
console.log(counter.count); // Output: 3
```

### Higher-Order Functions

```javascript
// Higher-order function: takes functions as parameters
function processData(data, processor) {
    console.log('Processing data:', data);
    const result = processor(data);
    console.log('Result:', result);
    return result;
}

// Different processor functions
const double = x => x * 2;
const square = x => x * x;
const addTen = x => x + 10;

// Using the higher-order function
processData(5, double);  // Output: Processing data: 5, Result: 10
processData(5, square);  // Output: Processing data: 5, Result: 25
processData(5, addTen);  // Output: Processing data: 5, Result: 15

// Higher-order function: returns functions
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double2 = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double2(5));    // Output: 10
console.log(triple(5));     // Output: 15
console.log(quadruple(5));  // Output: 20

// Real-world example: Event system
class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    // Higher-order method: accepts callback functions
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }
}

const emitter = new EventEmitter();

// Register event handlers (functions as arguments)
emitter.on('user-login', (user) => {
    console.log(`User ${user.name} logged in`);
});

emitter.on('user-login', (user) => {
    console.log(`Welcome back, ${user.name}!`);
});

emitter.on('user-login', (user) => {
    console.log(`Last login: ${user.lastLogin}`);
});

// Emit event
emitter.emit('user-login', { name: 'Alice', lastLogin: '2024-01-14' });
// Output: User Alice logged in
//         Welcome back, Alice!
//         Last login: 2024-01-14
```

---

## 🔄 Functions Accepting Callback Functions

### Basic Callback Patterns

```javascript
// Utility functions for string transformation
const oneWord = function(str) {
    return str.replace(/ /g, '').toLowerCase();
};

const upperFirstWord = function(str) {
    const [first, ...others] = str.split(' ');
    return [first.toUpperCase(), ...others].join(' ');
};

const reverseWords = function(str) {
    return str.split(' ').reverse().join(' ');
};

// Higher-order function that accepts callbacks
const transformer = function(str, fn) {
    console.log(`Original string: "${str}"`);
    console.log(`Transformed string: "${fn(str)}"`);
    console.log(`Transformed by: ${fn.name}`);
    console.log('---');
};

// Using different callback functions
transformer('JavaScript is the best!', upperFirstWord);
// Output: Original string: "JavaScript is the best!"
//         Transformed string: "JAVASCRIPT is the best!"
//         Transformed by: upperFirstWord

transformer('JavaScript is the best!', oneWord);
// Output: Original string: "JavaScript is the best!"
//         Transformed string: "javascriptisthebest!"
//         Transformed by: oneWord

transformer('JavaScript is the best!', reverseWords);
// Output: Original string: "JavaScript is the best!"
//         Transformed string: "best! the is JavaScript"
//         Transformed by: reverseWords
```

### Real-World Callback Examples

```javascript
// Array processing with callbacks (built-in higher-order functions)
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// map() - transforms each element
const doubled = numbers.map(num => num * 2);
console.log('Doubled:', doubled);
// Output: Doubled: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

// filter() - selects elements based on condition
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log('Even numbers:', evenNumbers);
// Output: Even numbers: [2, 4, 6, 8, 10]

// reduce() - accumulates values
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log('Sum:', sum);
// Output: Sum: 55

// Custom async callback example
function fetchUserData(userId, onSuccess, onError) {
    console.log(`Fetching user data for ID: ${userId}`);
    
    // Simulate async operation
    setTimeout(() => {
        if (userId > 0) {
            const userData = {
                id: userId,
                name: `User ${userId}`,
                email: `user${userId}@example.com`
            };
            onSuccess(userData);
        } else {
            onError(new Error('Invalid user ID'));
        }
    }, 1000);
}

// Success callback
const handleSuccess = (user) => {
    console.log('✅ User data received:', user);
};

// Error callback
const handleError = (error) => {
    console.log('❌ Error:', error.message);
};

fetchUserData(123, handleSuccess, handleError);
// Output: Fetching user data for ID: 123
//         (after 1 second) ✅ User data received: { id: 123, name: 'User 123', email: 'user123@example.com' }

fetchUserData(-1, handleSuccess, handleError);
// Output: Fetching user data for ID: -1
//         (after 1 second) ❌ Error: Invalid user ID

// Event listeners (callbacks in action)
const button = document.createElement('button');
button.textContent = 'Click me!';
document.body.appendChild(button);

// Multiple event handlers (all are callbacks)
const handleClick = () => console.log('Button clicked!');
const logTimestamp = () => console.log('Clicked at:', new Date().toLocaleTimeString());
const changeColor = () => button.style.backgroundColor = 
    button.style.backgroundColor === 'red' ? 'blue' : 'red';

button.addEventListener('click', handleClick);
button.addEventListener('click', logTimestamp);
button.addEventListener('click', changeColor);

// forEach with callback
const users = ['Alice', 'Bob', 'Charlie'];
users.forEach((user, index) => {
    console.log(`${index + 1}. Hello, ${user}!`);
});
// Output: 1. Hello, Alice!
//         2. Hello, Bob!
//         3. Hello, Charlie!
```

### Advanced Callback Patterns

```javascript
// Function composition with callbacks
function compose(...functions) {
    return function(value) {
        return functions.reduceRight((acc, fn) => fn(acc), value);
    };
}

// Individual transformation functions
const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;
const square = x => x * x;

// Compose functions
const complexTransform = compose(square, multiplyByTwo, addOne);

console.log(complexTransform(3)); // ((3 + 1) * 2)² = (4 * 2)² = 8² = 64
// Output: 64

// Callback with configuration
function processArray(array, config) {
    let result = [...array];
    
    if (config.filter) {
        result = result.filter(config.filter);
    }
    
    if (config.transform) {
        result = result.map(config.transform);
    }
    
    if (config.sort) {
        result = result.sort(config.sort);
    }
    
    return result;
}

const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const processed = processArray(data, {
    filter: num => num % 2 === 0,        // Keep even numbers
    transform: num => num * num,          // Square them
    sort: (a, b) => b - a                // Sort descending
});

console.log('Processed data:', processed);
// Output: Processed data: [100, 64, 36, 16, 4]

// Middleware pattern (common in web frameworks)
function createMiddleware() {
    const middlewares = [];
    
    return {
        use(fn) {
            middlewares.push(fn);
        },
        
        execute(context) {
            let index = 0;
            
            function next() {
                if (index < middlewares.length) {
                    const middleware = middlewares[index++];
                    middleware(context, next);
                }
            }
            
            next();
        }
    };
}

const app = createMiddleware();

// Add middleware functions
app.use((context, next) => {
    console.log('Middleware 1: Authentication');
    context.user = { id: 1, name: 'Alice' };
    next();
});

app.use((context, next) => {
    console.log('Middleware 2: Logging');
    console.log(`User ${context.user.name} accessed the system`);
    next();
});

app.use((context, next) => {
    console.log('Middleware 3: Final processing');
    context.result = 'Success';
    next();
});

// Execute middleware chain
const context = {};
app.execute(context);
console.log('Final context:', context);
// Output: Middleware 1: Authentication
//         Middleware 2: Logging
//         User Alice accessed the system
//         Middleware 3: Final processing
//         Final context: { user: { id: 1, name: 'Alice' }, result: 'Success' }
```

---

## 🔄 Functions Returning Functions

### Basic Function Factories

```javascript
// Simple function that returns a function
function greet(greeting) {
    return function(name) {
        console.log(`${greeting} ${name}!`);
    };
}

// Create specialized greeting functions
const sayHello = greet('Hello');
const sayGoodbye = greet('Goodbye');
const sayWelcome = greet('Welcome');

// Use the returned functions
sayHello('Alice');    // Output: Hello Alice!
sayGoodbye('Bob');    // Output: Goodbye Bob!
sayWelcome('Charlie'); // Output: Welcome Charlie!

// Arrow function version (more concise)
const greetArrow = greeting => name => console.log(`${greeting} ${name}!`);

const sayHi = greetArrow('Hi');
sayHi('David'); // Output: Hi David!

// Chaining function calls
greetArrow('Hey')('Emma'); // Output: Hey Emma!
```

### Practical Function Factories

```javascript
// Configuration function factory
function createValidator(rules) {
    return function(data) {
        const errors = [];
        
        for (const [field, rule] of Object.entries(rules)) {
            const value = data[field];
            
            if (rule.required && (!value || value.trim() === '')) {
                errors.push(`${field} is required`);
            }
            
            if (value && rule.minLength && value.length < rule.minLength) {
                errors.push(`${field} must be at least ${rule.minLength} characters`);
            }
            
            if (value && rule.pattern && !rule.pattern.test(value)) {
                errors.push(`${field} format is invalid`);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    };
}

// Create specific validators
const userValidator = createValidator({
    username: { required: true, minLength: 3 },
    email: { required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ },
    password: { required: true, minLength: 8 }
});

const productValidator = createValidator({
    name: { required: true, minLength: 2 },
    price: { required: true },
    category: { required: true }
});

// Test validators
const userData = { username: 'jo', email: 'invalid-email', password: '123' };
const userResult = userValidator(userData);
console.log('User validation:', userResult);
// Output: User validation: {
//   isValid: false,
//   errors: [
//     'username must be at least 3 characters',
//     'email format is invalid',
//     'password must be at least 8 characters'
//   ]
// }

const productData = { name: 'Laptop', price: 999, category: 'Electronics' };
const productResult = productValidator(productData);
console.log('Product validation:', productResult);
// Output: Product validation: { isValid: true, errors: [] }

// Mathematical function factories
function createMathOperation(operation) {
    return function(a) {
        return function(b) {
            switch(operation) {
                case 'add': return a + b;
                case 'subtract': return a - b;
                case 'multiply': return a * b;
                case 'divide': return b !== 0 ? a / b : 'Cannot divide by zero';
                default: return 'Unknown operation';
            }
        };
    };
}

// Create specialized math functions
const add = createMathOperation('add');
const multiply = createMathOperation('multiply');

// Partial application
const add5 = add(5);
const multiplyBy3 = multiply(3);

console.log(add5(10));        // Output: 15
console.log(multiplyBy3(4));  // Output: 12

// Direct chaining
console.log(add(10)(20));     // Output: 30
console.log(multiply(6)(7));  // Output: 42
```

### Advanced Function Factories

```javascript
// Memoization factory
function createMemoizedFunction(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log(`Cache hit for ${key}`);
            return cache.get(key);
        }
        
        console.log(`Computing result for ${key}`);
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// Expensive function to memoize
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = createMemoizedFunction(fibonacci);

console.log(memoizedFibonacci(10)); // Computes and caches
console.log(memoizedFibonacci(10)); // Uses cache
console.log(memoizedFibonacci(11)); // Computes new value

// Rate limiting factory
function createRateLimiter(maxCalls, timeWindow) {
    const calls = [];
    
    return function(fn) {
        return function(...args) {
            const now = Date.now();
            
            // Remove old calls outside the time window
            while (calls.length > 0 && calls[0] < now - timeWindow) {
                calls.shift();
            }
            
            if (calls.length >= maxCalls) {
                console.log('Rate limit exceeded. Please try again later.');
                return null;
            }
            
            calls.push(now);
            return fn.apply(this, args);
        };
    };
}

// Create rate limiter (max 3 calls per 5 seconds)
const rateLimiter = createRateLimiter(3, 5000);

// Apply rate limiting to a function
const apiCall = rateLimiter(function(endpoint) {
    console.log(`Making API call to ${endpoint}`);
    return `Data from ${endpoint}`;
});

// Test rate limiting
console.log(apiCall('/users'));    // Works
console.log(apiCall('/products')); // Works
console.log(apiCall('/orders'));   // Works
console.log(apiCall('/analytics')); // Rate limited

// Retry mechanism factory
function createRetryFunction(maxRetries, delay) {
    return function(fn) {
        return async function(...args) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`Attempt ${attempt}/${maxRetries}`);
                    return await fn.apply(this, args);
                } catch (error) {
                    lastError = error;
                    console.log(`Attempt ${attempt} failed:`, error.message);
                    
                    if (attempt < maxRetries) {
                        console.log(`Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            throw new Error(`All ${maxRetries} attempts failed. Last error: ${lastError.message}`);
        };
    };
}

// Create retry wrapper (max 3 retries, 1 second delay)
const withRetry = createRetryFunction(3, 1000);

// Simulate unreliable function
const unreliableFunction = withRetry(async function(data) {
    if (Math.random() < 0.7) { // 70% chance of failure
        throw new Error('Random failure occurred');
    }
    return `Success with data: ${data}`;
});

// Test retry mechanism
// unreliableFunction('test data')
//     .then(result => console.log('Final result:', result))
//     .catch(error => console.log('Final error:', error.message));
```---


## 📞 The call(), apply(), and bind() Methods

### Understanding 'this' Context

```
🎯 Method Context Control:
┌─────────────────────────────────────────────────────────────┐
│ call()   │ Invokes function immediately with specified 'this' │
│ apply()  │ Like call() but takes arguments as array          │
│ bind()   │ Returns new function with bound 'this' context    │
└─────────────────────────────────────────────────────────────┘
```

### The call() Method

```javascript
// Airline booking system example
const lufthansa = {
    airline: 'Lufthansa',
    iataCode: 'LH',
    bookings: [],
    
    book(flightNum, name) {
        console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`);
        this.bookings.push({ 
            flight: `${this.iataCode}${flightNum}`, 
            name,
            airline: this.airline 
        });
    }
};

// Normal method call
lufthansa.book(239, 'Jonas Schmedtmann');
lufthansa.book(635, 'John Smith');
console.log('Lufthansa bookings:', lufthansa.bookings);
// Output: Jonas Schmedtmann booked a seat on Lufthansa flight LH239
//         John Smith booked a seat on Lufthansa flight LH635
//         Lufthansa bookings: [
//           { flight: 'LH239', name: 'Jonas Schmedtmann', airline: 'Lufthansa' },
//           { flight: 'LH635', name: 'John Smith', airline: 'Lufthansa' }
//         ]

// Other airlines
const eurowings = {
    airline: 'Eurowings',
    iataCode: 'EW',
    bookings: []
};

const swiss = {
    airline: 'Swiss Air Lines',
    iataCode: 'LX',
    bookings: []
};

// Extract the book method
const book = lufthansa.book;

// ❌ This won't work - 'this' is undefined
// book(23, 'Sarah Williams'); // TypeError!

// ✅ Use call() to set 'this' context
book.call(eurowings, 23, 'Sarah Williams');
book.call(lufthansa, 239, 'Mary Cooper');
book.call(swiss, 583, 'George Cooper');

console.log('Eurowings bookings:', eurowings.bookings);
console.log('Swiss bookings:', swiss.bookings);
// Output: Sarah Williams booked a seat on Eurowings flight EW23
//         Mary Cooper booked a seat on Lufthansa flight LH239
//         George Cooper booked a seat on Swiss Air Lines flight LX583
```

### The apply() Method

```javascript
// apply() takes arguments as an array
const flightData = [583, 'George Cooper'];

// Using apply()
book.apply(swiss, flightData);
console.log('Swiss bookings after apply:', swiss.bookings);
// Output: George Cooper booked a seat on Swiss Air Lines flight LX583

// Modern alternative: use call() with spread operator
book.call(swiss, ...flightData);

// Real-world example: Math operations
const numbers = [5, 6, 2, 3, 7];

// Find max/min using apply (before spread operator)
const max = Math.max.apply(null, numbers);
const min = Math.min.apply(null, numbers);

console.log(`Max: ${max}, Min: ${min}`);
// Output: Max: 7, Min: 2

// Modern way with spread
const maxModern = Math.max(...numbers);
const minModern = Math.min(...numbers);

console.log(`Max (modern): ${maxModern}, Min (modern): ${minModern}`);
// Output: Max (modern): 7, Min (modern): 2

// Array concatenation example
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Using apply to push all elements
arr1.push.apply(arr1, arr2);
console.log('Concatenated array:', arr1);
// Output: Concatenated array: [1, 2, 3, 4, 5, 6]

// Modern alternative
const arr3 = [1, 2, 3];
const arr4 = [4, 5, 6];
arr3.push(...arr4);
console.log('Modern concatenation:', arr3);
// Output: Modern concatenation: [1, 2, 3, 4, 5, 6]
```

### The bind() Method

```javascript
// bind() creates a new function with bound 'this'
const bookEW = book.bind(eurowings);
const bookLH = book.bind(lufthansa);
const bookLX = book.bind(swiss);

// Now we can call these functions normally
bookEW(23, 'Steven Williams');
bookLH(456, 'Alice Johnson');
bookLX(789, 'Bob Wilson');

// Partial application with bind()
const bookEW23 = book.bind(eurowings, 23); // Pre-set flight number

// Now we only need to provide the name
bookEW23('Jonas Schmedtmann');
bookEW23('Martha Cooper');
bookEW23('David Brown');

console.log('Eurowings bookings:', eurowings.bookings);
// Output: All passengers booked on Eurowings flight EW23

// Event listeners with bind()
lufthansa.planes = 300;
lufthansa.buyPlane = function() {
    console.log(this);
    this.planes++;
    console.log(`Lufthansa now has ${this.planes} planes`);
};

// ❌ Without bind, 'this' would point to the button
// document.querySelector('.buy').addEventListener('click', lufthansa.buyPlane);

// ✅ With bind, 'this' points to lufthansa object
const buyButton = document.createElement('button');
buyButton.textContent = 'Buy New Plane';
buyButton.className = 'buy';
document.body.appendChild(buyButton);

buyButton.addEventListener('click', lufthansa.buyPlane.bind(lufthansa));

// Simulate button click
buyButton.click();
// Output: { airline: 'Lufthansa', iataCode: 'LH', bookings: [...], planes: 300, buyPlane: [Function] }
//         Lufthansa now has 301 planes
```

### Advanced bind() Applications

```javascript
// Partial application for tax calculations
const addTax = (rate, value) => value + value * rate;

console.log(addTax(0.1, 200)); // 10% tax
// Output: 220

// Create specialized tax functions
const addVAT = addTax.bind(null, 0.23); // 23% VAT
const addSalesTax = addTax.bind(null, 0.08); // 8% sales tax
const addLuxuryTax = addTax.bind(null, 0.15); // 15% luxury tax

console.log('Price with VAT:', addVAT(100));        // Output: 123
console.log('Price with sales tax:', addSalesTax(100)); // Output: 108
console.log('Price with luxury tax:', addLuxuryTax(100)); // Output: 115

// Function factory alternative
const createTaxCalculator = (rate) => (value) => value + value * rate;

const addVAT2 = createTaxCalculator(0.23);
const addSalesTax2 = createTaxCalculator(0.08);

console.log('VAT (factory):', addVAT2(100));      // Output: 123
console.log('Sales tax (factory):', addSalesTax2(100)); // Output: 108

// Binding object methods for callbacks
class Logger {
    constructor(prefix) {
        this.prefix = prefix;
    }
    
    log(message) {
        console.log(`[${this.prefix}] ${message}`);
    }
    
    error(message) {
        console.log(`[${this.prefix}] ERROR: ${message}`);
    }
    
    warn(message) {
        console.log(`[${this.prefix}] WARNING: ${message}`);
    }
}

const appLogger = new Logger('APP');

// ❌ This would lose context
// setTimeout(appLogger.log, 1000, 'Delayed message');

// ✅ Bind to preserve context
setTimeout(appLogger.log.bind(appLogger), 1000, 'Delayed message');
// Output (after 1 second): [APP] Delayed message

// Array methods with bound functions
const users = [
    { name: 'Alice', active: true },
    { name: 'Bob', active: false },
    { name: 'Charlie', active: true }
];

const userManager = {
    activeCount: 0,
    
    processUser(user) {
        if (user.active) {
            this.activeCount++;
        }
        console.log(`Processed ${user.name}, active count: ${this.activeCount}`);
    }
};

// Use bind to maintain context in forEach
users.forEach(userManager.processUser.bind(userManager));
// Output: Processed Alice, active count: 1
//         Processed Bob, active count: 1
//         Processed Charlie, active count: 2

console.log('Final active count:', userManager.activeCount);
// Output: Final active count: 2
```

### Real-World Practical Examples

```javascript
// API client with bound methods
class ApiClient {
    constructor(baseUrl, apiKey) {
        this.baseUrl = baseUrl;
        this.apiKey = apiKey;
        
        // Bind methods to preserve context
        this.get = this.get.bind(this);
        this.post = this.post.bind(this);
        this.put = this.put.bind(this);
        this.delete = this.delete.bind(this);
    }
    
    async request(method, endpoint, data = null) {
        const url = `${this.baseUrl}${endpoint}`;
        const options = {
            method,
            headers: {
                'Authorization': `Bearer ${this.apiKey}`,
                'Content-Type': 'application/json'
            }
        };
        
        if (data) {
            options.body = JSON.stringify(data);
        }
        
        console.log(`Making ${method} request to ${url}`);
        // Simulate API call
        return { status: 200, data: `Response from ${endpoint}` };
    }
    
    get(endpoint) {
        return this.request('GET', endpoint);
    }
    
    post(endpoint, data) {
        return this.request('POST', endpoint, data);
    }
    
    put(endpoint, data) {
        return this.request('PUT', endpoint, data);
    }
    
    delete(endpoint) {
        return this.request('DELETE', endpoint);
    }
}

const api = new ApiClient('https://api.example.com', 'secret-key');

// These can be used as standalone functions because they're bound
const { get, post } = api;

get('/users');    // Works because 'this' is bound
post('/users', { name: 'New User' }); // Works because 'this' is bound

// Debounce function using bind
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

const searchHandler = {
    query: '',
    
    search(term) {
        this.query = term;
        console.log(`Searching for: ${this.query}`);
    }
};

// Create debounced version
const debouncedSearch = debounce(searchHandler.search.bind(searchHandler), 300);

// Simulate rapid typing
debouncedSearch('j');
debouncedSearch('ja');
debouncedSearch('jav');
debouncedSearch('java');
debouncedSearch('javascript');
// Only the last call will execute after 300ms delay
```

---

## 🎯 Coding Challenge #1: Poll Application

### The Challenge Requirements

```javascript
// Poll application with method binding and partial application
const poll = {
    question: 'What is your favourite programming language?',
    options: ['0: JavaScript', '1: Python', '2: Rust', '3: C++'],
    answers: new Array(4).fill(0),
    
    // Method 1: Register new answer
    registerNewAnswer() {
        // Display prompt with question and options
        const answer = Number(prompt(
            `${this.question}\n${this.options.join('\n')}\n(Write option number)`
        ));
        
        console.log(`User selected option: ${answer}`);
        
        // Validate and register answer
        if (typeof answer === 'number' && 
            answer >= 0 && 
            answer < this.answers.length) {
            this.answers[answer]++;
            console.log('✅ Answer registered successfully');
        } else {
            console.log('❌ Invalid option selected');
        }
        
        // Display results after each vote
        this.displayResults();
        this.displayResults('string');
    },
    
    // Method 2: Display results
    displayResults(type = 'array') {
        if (type === 'array') {
            console.log('Results (array):', this.answers);
        } else if (type === 'string') {
            console.log(`Poll results are ${this.answers.join(', ')}`);
        }
    }
};

// Create button for polling
const pollButton = document.createElement('button');
pollButton.textContent = 'Answer Poll';
pollButton.className = 'poll';
document.body.appendChild(pollButton);

// Bind the method to preserve 'this' context
pollButton.addEventListener('click', poll.registerNewAnswer.bind(poll));

// BONUS: Use displayResults with different data using call()
console.log('\n--- BONUS: Testing with external data ---');

// Test data 1
poll.displayResults.call({ answers: [5, 2, 3] }, 'string');
poll.displayResults.call({ answers: [5, 2, 3] }, 'array');

// Test data 2
poll.displayResults.call({ answers: [1, 5, 3, 9, 6, 1] }, 'string');
poll.displayResults.call({ answers: [1, 5, 3, 9, 6, 1] }, 'array');

// Output:
// Poll results are 5, 2, 3
// Results (array): [5, 2, 3]
// Poll results are 1, 5, 3, 9, 6, 1
// Results (array): [1, 5, 3, 9, 6, 1]
```

### Enhanced Poll Application

```javascript
// Enhanced version with more features
class AdvancedPoll {
    constructor(question, options) {
        this.question = question;
        this.options = options.map((option, index) => `${index}: ${option}`);
        this.answers = new Array(options.length).fill(0);
        this.totalVotes = 0;
        this.voters = new Set(); // Track unique voters
        
        // Bind methods
        this.vote = this.vote.bind(this);
        this.displayResults = this.displayResults.bind(this);
        this.getStatistics = this.getStatistics.bind(this);
    }
    
    vote(voterId = null) {
        // Check for duplicate voting
        if (voterId && this.voters.has(voterId)) {
            console.log('❌ You have already voted!');
            return false;
        }
        
        const answer = Number(prompt(
            `${this.question}\n${this.options.join('\n')}\n(Write option number)`
        ));
        
        if (this.isValidAnswer(answer)) {
            this.answers[answer]++;
            this.totalVotes++;
            
            if (voterId) {
                this.voters.add(voterId);
            }
            
            console.log(`✅ Vote registered for option ${answer}: ${this.options[answer].split(': ')[1]}`);
            this.displayResults('string');
            return true;
        } else {
            console.log('❌ Invalid option. Please try again.');
            return false;
        }
    }
    
    isValidAnswer(answer) {
        return typeof answer === 'number' && 
               answer >= 0 && 
               answer < this.answers.length &&
               !isNaN(answer);
    }
    
    displayResults(type = 'array') {
        console.log('\n--- Poll Results ---');
        
        if (type === 'array') {
            console.log('Raw results:', this.answers);
        } else if (type === 'string') {
            console.log(`Poll results are ${this.answers.join(', ')}`);
        } else if (type === 'detailed') {
            this.options.forEach((option, index) => {
                const votes = this.answers[index];
                const percentage = this.totalVotes > 0 ? 
                    ((votes / this.totalVotes) * 100).toFixed(1) : 0;
                console.log(`${option}: ${votes} votes (${percentage}%)`);
            });
        }
        
        console.log(`Total votes: ${this.totalVotes}`);
        console.log('-------------------\n');
    }
    
    getStatistics() {
        const maxVotes = Math.max(...this.answers);
        const winningOptions = this.answers
            .map((votes, index) => ({ index, votes, option: this.options[index] }))
            .filter(item => item.votes === maxVotes);
        
        return {
            totalVotes: this.totalVotes,
            uniqueVoters: this.voters.size,
            winningOptions,
            results: this.answers
        };
    }
    
    reset() {
        this.answers.fill(0);
        this.totalVotes = 0;
        this.voters.clear();
        console.log('Poll has been reset');
    }
}

// Create polls
const techPoll = new AdvancedPoll(
    'What is your favorite programming language?',
    ['JavaScript', 'Python', 'Rust', 'C++', 'Go']
);

const frameworkPoll = new AdvancedPoll(
    'Which frontend framework do you prefer?',
    ['React', 'Vue', 'Angular', 'Svelte']
);

// Simulate voting
console.log('=== Tech Poll ===');
techPoll.vote('user1');
techPoll.vote('user2');
techPoll.vote('user1'); // Duplicate vote attempt

console.log('\n=== Framework Poll ===');
frameworkPoll.vote('user3');
frameworkPoll.vote('user4');

// Display detailed results
techPoll.displayResults('detailed');
frameworkPoll.displayResults('detailed');

// Get statistics
console.log('Tech Poll Statistics:', techPoll.getStatistics());
console.log('Framework Poll Statistics:', frameworkPoll.getStatistics());
```---

## 
🚀 Immediately Invoked Function Expressions (IIFE)

### Understanding IIFE

```
🎯 IIFE Pattern:
┌─────────────────────────────────────────────────────────────┐
│ (function() {                                               │
│     // Code runs immediately                                │
│     // Variables are private to this scope                  │
│ })();                                                       │
│                                                             │
│ (() => {                                                    │
│     // Arrow function IIFE                                  │
│ })();                                                       │
└─────────────────────────────────────────────────────────────┘
```

### Basic IIFE Examples

```javascript
// Traditional function that can be called multiple times
const runOnce = function() {
    console.log('This will never run again');
};
runOnce(); // Can be called again
runOnce(); // Called again!

// ✅ IIFE - runs immediately and can't be called again
(function() {
    console.log('This will truly never run again');
    const isPrivate = 23;
    console.log('Private variable:', isPrivate);
})();

// Arrow function IIFE
(() => {
    console.log('Arrow IIFE executed');
    const anotherPrivate = 'secret';
    console.log('Another private variable:', anotherPrivate);
})();

// IIFE with parameters
((name, age) => {
    console.log(`Hello ${name}, you are ${age} years old`);
})('Alice', 25);

// IIFE with return value
const result = (function(a, b) {
    return a + b;
})(5, 3);

console.log('IIFE result:', result); // Output: 8
```

### Privacy and Scope Protection

```javascript
// ❌ Without IIFE - variables pollute global scope
var globalVar = 'I am global';
var anotherGlobal = 'Me too';

console.log('Global variables accessible:', globalVar, anotherGlobal);

// ✅ With IIFE - variables are private
(function() {
    var privateVar = 'I am private';
    var anotherPrivate = 'Me too';
    
    console.log('Inside IIFE:', privateVar, anotherPrivate);
    
    // Only expose what's necessary
    window.myModule = {
        publicMethod: function() {
            return 'This is public, but uses: ' + privateVar;
        }
    };
})();

// console.log(privateVar); // ReferenceError: privateVar is not defined
console.log(myModule.publicMethod()); // Output: This is public, but uses: I am private

// Modern alternative with block scope
{
    const blockScoped = 'I am block scoped';
    let alsoBlockScoped = 'Me too';
    var notBlockScoped = 'I escape the block'; // var ignores block scope
    
    console.log('Inside block:', blockScoped, alsoBlockScoped);
}

// console.log(blockScoped); // ReferenceError
console.log('Escaped var:', notBlockScoped); // This works because var ignores blocks
```

### Real-World IIFE Applications

```javascript
// Module pattern with IIFE
const Calculator = (function() {
    // Private variables and functions
    let history = [];
    
    function log(operation, result) {
        history.push({ operation, result, timestamp: new Date() });
    }
    
    function validateNumbers(...numbers) {
        return numbers.every(num => typeof num === 'number' && !isNaN(num));
    }
    
    // Public API
    return {
        add(a, b) {
            if (!validateNumbers(a, b)) {
                throw new Error('Invalid numbers provided');
            }
            const result = a + b;
            log(`${a} + ${b}`, result);
            return result;
        },
        
        subtract(a, b) {
            if (!validateNumbers(a, b)) {
                throw new Error('Invalid numbers provided');
            }
            const result = a - b;
            log(`${a} - ${b}`, result);
            return result;
        },
        
        multiply(a, b) {
            if (!validateNumbers(a, b)) {
                throw new Error('Invalid numbers provided');
            }
            const result = a * b;
            log(`${a} * ${b}`, result);
            return result;
        },
        
        getHistory() {
            return [...history]; // Return copy to prevent external modification
        },
        
        clearHistory() {
            history = [];
            console.log('History cleared');
        }
    };
})();

// Usage
console.log(Calculator.add(5, 3));      // Output: 8
console.log(Calculator.multiply(4, 6)); // Output: 24
console.log(Calculator.subtract(10, 4)); // Output: 6

console.log('Calculator history:', Calculator.getHistory());
// console.log(history); // ReferenceError - private variable not accessible

// Configuration module with IIFE
const AppConfig = (function() {
    // Private configuration
    const config = {
        apiUrl: 'https://api.example.com',
        timeout: 5000,
        retries: 3,
        debug: false
    };
    
    const allowedKeys = ['timeout', 'retries', 'debug'];
    
    return {
        get(key) {
            return config[key];
        },
        
        set(key, value) {
            if (!allowedKeys.includes(key)) {
                throw new Error(`Cannot modify ${key}. Allowed keys: ${allowedKeys.join(', ')}`);
            }
            
            const oldValue = config[key];
            config[key] = value;
            console.log(`Config updated: ${key} changed from ${oldValue} to ${value}`);
        },
        
        getAll() {
            return { ...config }; // Return copy
        }
    };
})();

// Usage
console.log('API URL:', AppConfig.get('apiUrl'));
AppConfig.set('timeout', 10000);
AppConfig.set('debug', true);

try {
    AppConfig.set('apiUrl', 'https://malicious.com'); // This will throw an error
} catch (error) {
    console.log('Security error:', error.message);
}

console.log('Full config:', AppConfig.getAll());
```

### Advanced IIFE Patterns

```javascript
// IIFE with dependency injection
const UserManager = (function($, _) {
    // Private state
    let users = [];
    let currentUser = null;
    
    // Private helper functions
    function validateUser(user) {
        return user && 
               typeof user.name === 'string' && 
               typeof user.email === 'string' &&
               user.email.includes('@');
    }
    
    function findUserById(id) {
        return _.find(users, { id });
    }
    
    // Public API
    return {
        addUser(userData) {
            if (!validateUser(userData)) {
                throw new Error('Invalid user data');
            }
            
            const user = {
                id: _.uniqueId('user_'),
                ...userData,
                createdAt: new Date()
            };
            
            users.push(user);
            console.log('User added:', user.name);
            return user;
        },
        
        removeUser(id) {
            const index = _.findIndex(users, { id });
            if (index !== -1) {
                const removedUser = users.splice(index, 1)[0];
                console.log('User removed:', removedUser.name);
                return removedUser;
            }
            return null;
        },
        
        login(email) {
            const user = _.find(users, { email });
            if (user) {
                currentUser = user;
                console.log('User logged in:', user.name);
                return user;
            }
            throw new Error('User not found');
        },
        
        logout() {
            if (currentUser) {
                console.log('User logged out:', currentUser.name);
                currentUser = null;
            }
        },
        
        getCurrentUser() {
            return currentUser ? { ...currentUser } : null;
        },
        
        getAllUsers() {
            return users.map(user => ({ ...user })); // Return copies
        }
    };
})(jQuery || {}, _ || {}); // Pass dependencies

// Simulate usage (assuming jQuery and Lodash are available)
// UserManager.addUser({ name: 'Alice', email: 'alice@example.com' });
// UserManager.addUser({ name: 'Bob', email: 'bob@example.com' });

// Async IIFE for initialization
(async function initializeApp() {
    console.log('Initializing application...');
    
    try {
        // Simulate async operations
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('✅ Database connected');
        
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log('✅ Configuration loaded');
        
        await new Promise(resolve => setTimeout(resolve, 300));
        console.log('✅ Services initialized');
        
        console.log('🚀 Application ready!');
    } catch (error) {
        console.error('❌ Initialization failed:', error);
    }
})();

// IIFE for feature detection
const FeatureDetector = (function() {
    const features = {};
    
    // Detect various browser features
    features.localStorage = (function() {
        try {
            const test = 'test';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch (e) {
            return false;
        }
    })();
    
    features.webGL = (function() {
        try {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
        } catch (e) {
            return false;
        }
    })();
    
    features.geolocation = (function() {
        return 'geolocation' in navigator;
    })();
    
    features.touchSupport = (function() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    })();
    
    return {
        hasFeature(feature) {
            return !!features[feature];
        },
        
        getAllFeatures() {
            return { ...features };
        },
        
        requireFeature(feature) {
            if (!this.hasFeature(feature)) {
                throw new Error(`Required feature '${feature}' is not supported`);
            }
        }
    };
})();

// Usage
console.log('Feature detection results:', FeatureDetector.getAllFeatures());

try {
    FeatureDetector.requireFeature('localStorage');
    console.log('✅ localStorage is available');
} catch (error) {
    console.log('❌', error.message);
}
```

### When to Use IIFE

```javascript
// ✅ Good use cases for IIFE:

// 1. Creating modules with private state
const CounterModule = (function() {
    let count = 0;
    
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
})();

// 2. Avoiding variable pollution in loops
for (let i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(() => {
            console.log(`Timer ${index} executed`);
        }, 100 * index);
    })(i);
}

// 3. One-time initialization
(function() {
    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded - IIFE initialization complete');
    });
    
    // Initialize third-party libraries
    // Configure global settings
})();

// 4. Creating closures with specific values
const buttons = [];
for (let i = 0; i < 3; i++) {
    buttons.push(
        (function(buttonIndex) {
            return function() {
                console.log(`Button ${buttonIndex} clicked`);
            };
        })(i)
    );
}

// Test the buttons
buttons.forEach((buttonHandler, index) => {
    console.log(`Simulating click on button ${index}:`);
    buttonHandler();
});

// ❌ Modern alternatives (often better):

// Instead of IIFE for modules, use ES6 modules
// export const myModule = { ... };

// Instead of IIFE for block scope, use let/const in blocks
{
    const blockScoped = 'private';
    // Use blockScoped here
}

// Instead of IIFE for async initialization, use top-level await (in modules)
// await initializeApp();
```

---

## 🔒 Closures

### Understanding Closures

```
🧠 Closure Concept:
┌─────────────────────────────────────────────────────────────┐
│ A closure is created when:                                  │
│ 1. A function is defined inside another function            │
│ 2. The inner function references outer function variables   │
│ 3. The inner function is made available outside outer func │
│                                                             │
│ Result: Inner function "remembers" outer function's scope   │
│ even after outer function has finished executing           │
└─────────────────────────────────────────────────────────────┘
```

### Basic Closure Example

```javascript
// Simple closure demonstration
function secureBooking() {
    let passengerCount = 0; // Private variable
    
    return function() {
        passengerCount++; // Accesses outer function's variable
        console.log(`${passengerCount} passengers`);
    };
}

const booker = secureBooking();

// The secureBooking function has finished executing,
// but the returned function still has access to passengerCount
booker(); // Output: 1 passengers
booker(); // Output: 2 passengers
booker(); // Output: 3 passengers

// Inspect the closure
console.dir(booker); // In browser console, you can see the closure

// Each call to secureBooking creates a new closure
const booker2 = secureBooking();
booker2(); // Output: 1 passengers (separate counter)
booker();  // Output: 4 passengers (original counter continues)
```

### How Closures Work

```javascript
// Step-by-step closure creation
function outerFunction(x) {
    console.log('Outer function called with:', x);
    
    // This variable will be "closed over"
    let outerVariable = x;
    
    function innerFunction(y) {
        console.log('Inner function called with:', y);
        console.log('Accessing outer variable:', outerVariable);
        return outerVariable + y;
    }
    
    console.log('Returning inner function');
    return innerFunction;
}

console.log('=== Creating closure ===');
const myClosure = outerFunction(10);
// Output: Outer function called with: 10
//         Returning inner function

console.log('=== Using closure ===');
const result = myClosure(5);
// Output: Inner function called with: 5
//         Accessing outer variable: 10

console.log('Result:', result); // Output: Result: 15

// The outer function has finished, but innerFunction still has access to outerVariable!
```

### Practical Closure Examples

```javascript
// 1. Counter factory
function createCounter(initialValue = 0, step = 1) {
    let count = initialValue;
    
    return {
        increment() {
            count += step;
            return count;
        },
        
        decrement() {
            count -= step;
            return count;
        },
        
        getValue() {
            return count;
        },
        
        reset() {
            count = initialValue;
            return count;
        }
    };
}

const counter1 = createCounter(0, 1);
const counter2 = createCounter(100, 5);

console.log('Counter 1:', counter1.increment()); // Output: 1
console.log('Counter 1:', counter1.increment()); // Output: 2
console.log('Counter 2:', counter2.increment()); // Output: 105
console.log('Counter 2:', counter2.decrement()); // Output: 100

// 2. Private methods with closures
function createBankAccount(initialBalance) {
    let balance = initialBalance;
    const transactions = [];
    
    function addTransaction(type, amount) {
        transactions.push({
            type,
            amount,
            date: new Date(),
            balance: balance
        });
    }
    
    return {
        deposit(amount) {
            if (amount > 0) {
                balance += amount;
                addTransaction('deposit', amount);
                console.log(`Deposited $${amount}. New balance: $${balance}`);
            } else {
                console.log('Invalid deposit amount');
            }
            return balance;
        },
        
        withdraw(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                addTransaction('withdrawal', amount);
                console.log(`Withdrew $${amount}. New balance: $${balance}`);
            } else {
                console.log('Invalid withdrawal amount or insufficient funds');
            }
            return balance;
        },
        
        getBalance() {
            return balance;
        },
        
        getTransactionHistory() {
            return [...transactions]; // Return copy to prevent external modification
        }
    };
}

const account = createBankAccount(1000);
account.deposit(500);   // Output: Deposited $500. New balance: $1500
account.withdraw(200);  // Output: Withdrew $200. New balance: $1300
account.withdraw(2000); // Output: Invalid withdrawal amount or insufficient funds

console.log('Final balance:', account.getBalance()); // Output: 1300
console.log('Transaction history:', account.getTransactionHistory());

// 3. Function configuration with closures
function createApiClient(baseUrl, defaultHeaders = {}) {
    const headers = { ...defaultHeaders };
    
    return {
        setHeader(key, value) {
            headers[key] = value;
        },
        
        removeHeader(key) {
            delete headers[key];
        },
        
        async get(endpoint) {
            const url = `${baseUrl}${endpoint}`;
            console.log(`GET ${url}`);
            console.log('Headers:', headers);
            
            // Simulate API call
            return {
                status: 200,
                data: `Data from ${endpoint}`,
                headers: { ...headers }
            };
        },
        
        async post(endpoint, data) {
            const url = `${baseUrl}${endpoint}`;
            console.log(`POST ${url}`);
            console.log('Headers:', headers);
            console.log('Data:', data);
            
            // Simulate API call
            return {
                status: 201,
                data: `Created resource at ${endpoint}`,
                headers: { ...headers }
            };
        }
    };
}

const apiClient = createApiClient('https://api.example.com', {
    'Content-Type': 'application/json'
});

apiClient.setHeader('Authorization', 'Bearer token123');
apiClient.get('/users');
apiClient.post('/users', { name: 'John Doe' });
```

### Advanced Closure Patterns

```javascript
// 1. Closure with variable reassignment
let f; // Declare variable in outer scope

const g = function() {
    const a = 23;
    f = function() {
        console.log(a * 2);
    };
};

const h = function() {
    const b = 777;
    f = function() {
        console.log(b * 2);
    };
};

g(); // Create closure with 'a'
f(); // Output: 46 (23 * 2)
console.dir(f); // Shows closure with variable 'a'

h(); // Reassign f with new closure containing 'b'
f(); // Output: 1554 (777 * 2)
console.dir(f); // Shows closure with variable 'b' (old closure is gone)

// 2. Closure in setTimeout
function boardPassengers(n, wait) {
    const perGroup = n / 3;
    
    setTimeout(function() {
        console.log(`We are now boarding all ${n} passengers`);
        console.log(`There are 3 groups, each with ${perGroup} passengers`);
    }, wait * 1000);
    
    console.log(`Will start boarding in ${wait} seconds`);
}

// Even though boardPassengers finishes immediately,
// the setTimeout callback still has access to n and perGroup
boardPassengers(180, 3);
// Output: Will start boarding in 3 seconds
//         (after 3 seconds) We are now boarding all 180 passengers
//                          There are 3 groups, each with 60 passengers

// 3. Closure priority over scope chain
const perGroup = 1000; // Global variable

// The closure variable takes priority over global variable
boardPassengers(180, 1);
// Uses perGroup = 60 from closure, not perGroup = 1000 from global scope

// 4. Module pattern with closures
const ShoppingCart = (function() {
    let items = [];
    let total = 0;
    
    function calculateTotal() {
        total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    }
    
    function findItem(id) {
        return items.find(item => item.id === id);
    }
    
    return {
        addItem(item) {
            const existingItem = findItem(item.id);
            
            if (existingItem) {
                existingItem.quantity += item.quantity || 1;
            } else {
                items.push({
                    ...item,
                    quantity: item.quantity || 1
                });
            }
            
            calculateTotal();
            console.log(`Added ${item.name} to cart. Total: $${total.toFixed(2)}`);
        },
        
        removeItem(id) {
            const index = items.findIndex(item => item.id === id);
            if (index !== -1) {
                const removedItem = items.splice(index, 1)[0];
                calculateTotal();
                console.log(`Removed ${removedItem.name} from cart. Total: $${total.toFixed(2)}`);
            }
        },
        
        getItems() {
            return items.map(item => ({ ...item })); // Return copies
        },
        
        getTotal() {
            return total;
        },
        
        clear() {
            items = [];
            total = 0;
            console.log('Cart cleared');
        }
    };
})();

// Usage
ShoppingCart.addItem({ id: 1, name: 'Laptop', price: 999.99 });
ShoppingCart.addItem({ id: 2, name: 'Mouse', price: 25.99, quantity: 2 });
ShoppingCart.addItem({ id: 1, name: 'Laptop', price: 999.99 }); // Increases quantity

console.log('Cart items:', ShoppingCart.getItems());
console.log('Cart total:', ShoppingCart.getTotal());
```

---

## 🎯 Coding Challenge #2: Closure Color Changer

### The Challenge

```javascript
// IIFE with closure for DOM manipulation
(function() {
    const header = document.querySelector('h1');
    header.style.color = 'red';
    
    // This event listener creates a closure
    document.querySelector('body').addEventListener('click', function() {
        header.style.color = 'blue';
    });
})();

// Why this works:
// 1. The IIFE runs immediately and selects the h1 element
// 2. It sets the initial color to red
// 3. It adds an event listener to the body
// 4. The event listener function creates a closure that "remembers" the header variable
// 5. Even after the IIFE finishes executing, the event listener still has access to header
// 6. When the body is clicked, the closure allows access to header to change its color

console.log('Explanation:');
console.log('The event listener function has access to the "header" variable');
console.log('through closure, even after the IIFE has finished executing.');
console.log('This is because closures allow inner functions to access');
console.log('variables from their outer (lexical) scope.');
```

### Enhanced Version with Multiple Features

```javascript
// Enhanced closure example with multiple interactive elements
(function() {
    // Private variables accessible through closures
    const elements = {
        header: document.querySelector('h1') || createHeader(),
        body: document.body,
        clickCount: 0
    };
    
    const colors = ['red', 'blue', 'green', 'purple', 'orange', 'teal'];
    let currentColorIndex = 0;
    
    function createHeader() {
        const h1 = document.createElement('h1');
        h1.textContent = 'Click anywhere to change my color!';
        document.body.appendChild(h1);
        return h1;
    }
    
    function getNextColor() {
        currentColorIndex = (currentColorIndex + 1) % colors.length;
        return colors[currentColorIndex];
    }
    
    function updateClickCounter() {
        elements.clickCount++;
        console.log(`Click count: ${elements.clickCount}`);
    }
    
    // Set initial styles
    elements.header.style.color = colors[0];
    elements.header.style.transition = 'color 0.3s ease';
    elements.header.style.textAlign = 'center';
    elements.header.style.fontSize = '2rem';
    elements.header.style.margin = '2rem 0';
    
    // Event listener with closure
    elements.body.addEventListener('click', function(event) {
        // All these variables are accessible through closure
        const newColor = getNextColor();
        elements.header.style.color = newColor;
        updateClickCounter();
        
        console.log(`Header color changed to: ${newColor}`);
        console.log(`Click position: (${event.clientX}, ${event.clientY})`);
        
        // Create ripple effect at click position
        createRipple(event.clientX, event.clientY, newColor);
    });
    
    function createRipple(x, y, color) {
        const ripple = document.createElement('div');
        ripple.style.position = 'fixed';
        ripple.style.left = x + 'px';
        ripple.style.top = y + 'px';
        ripple.style.width = '10px';
        ripple.style.height = '10px';
        ripple.style.backgroundColor = color;
        ripple.style.borderRadius = '50%';
        ripple.style.transform = 'translate(-50%, -50%)';
        ripple.style.animation = 'ripple 0.6s ease-out forwards';
        ripple.style.pointerEvents = 'none';
        ripple.style.zIndex = '1000';
        
        // Add CSS animation if not already added
        if (!document.querySelector('#ripple-styles')) {
            const style = document.createElement('style');
            style.id = 'ripple-styles';
            style.textContent = `
                @keyframes ripple {
                    to {
                        transform: translate(-50%, -50%) scale(20);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(ripple);
        
        // Remove ripple after animation
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.parentNode.removeChild(ripple);
            }
        }, 600);
    }
    
    // Expose some functionality globally while keeping internals private
    window.ColorChanger = {
        getClickCount() {
            return elements.clickCount;
        },
        
        getCurrentColor() {
            return colors[currentColorIndex];
        },
        
        reset() {
            elements.clickCount = 0;
            currentColorIndex = 0;
            elements.header.style.color = colors[0];
            console.log('Color changer reset');
        }
    };
    
    console.log('Color changer initialized!');
    console.log('Click anywhere on the page to change the header color.');
    console.log('Use ColorChanger.getClickCount() to see total clicks.');
})();

// Demonstration of closure persistence
setTimeout(() => {
    console.log('\n=== Closure Demonstration ===');
    console.log('Even after 3 seconds, the event listener still works!');
    console.log('This proves that closures preserve access to variables');
    console.log('from their lexical scope, even after the outer function');
    console.log('(the IIFE in this case) has finished executing.');
    
    if (window.ColorChanger) {
        console.log(`Current click count: ${ColorChanger.getClickCount()}`);
        console.log(`Current color: ${ColorChanger.getCurrentColor()}`);
    }
}, 3000);
```

---

## 🎯 Key Takeaways & Best Practices

### Function Design Principles

```javascript
// ✅ Best Practices Summary

// 1. Use default parameters for optional arguments
function processOrder(items, tax = 0.08, shipping = 'standard') {
    // Clear what parameters are optional and their defaults
}

// 2. Be aware of reference vs value passing
function updateUser(user) {
    // Create copy to avoid side effects
    const updatedUser = { ...user, lastModified: new Date() };
    return updatedUser; // Return new object instead of modifying original
}

// 3. Use higher-order functions for reusability
const withLogging = (fn) => (...args) => {
    console.log(`Calling ${fn.name} with:`, args);
    const result = fn(...args);
    console.log(`Result:`, result);
    return result;
};

// 4. Leverage closures for data privacy
function createSecureCounter() {
    let count = 0; // Private variable
    
    return {
        increment: () => ++count,
        getCount: () => count
        // count is not directly accessible
    };
}

// 5. Use bind() for method context preservation
class EventHandler {
    constructor() {
        this.handleClick = this.handleClick.bind(this);
    }
    
    handleClick() {
        // 'this' always refers to the instance
    }
}

// 6. IIFE for immediate execution and privacy
(function initializeApp() {
    // Initialization code that runs once
    // Variables here are private
})();
```

### Performance Considerations

```javascript
// ✅ Performance tips

// 1. Avoid creating functions in loops
// ❌ Bad
for (let i = 0; i < items.length; i++) {
    items[i].addEventListener('click', function() { /* ... */ });
}

// ✅ Good
function handleClick() { /* ... */ }
for (let i = 0; i < items.length; i++) {
    items[i].addEventListener('click', handleClick);
}

// 2. Use memoization for expensive functions
function memoize(fn) {
    const cache = new Map();
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache.has(key)) return cache.get(key);
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// 3. Prefer arrow functions for simple operations
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2); // Concise and clear
```

---

## 🏆 Mastery Checklist

```
🎯 Advanced Functions Mastery:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Master default parameters and function signatures        │
│ ✅ Understand value vs reference parameter passing          │
│ ✅ Create and use higher-order functions effectively        │
│ ✅ Implement callback patterns and function composition     │
│ ✅ Control 'this' context with call, apply, and bind       │
│ ✅ Leverage closures for data privacy and state management │
│ ✅ Use IIFE for immediate execution and scope isolation     │
│ ✅ Apply functional programming patterns                    │
└─────────────────────────────────────────────────────────────┘
```

**Remember:** Functions are the building blocks of JavaScript applications. Mastering these advanced concepts allows you to write more elegant, maintainable, and powerful code. The patterns you've learned here form the foundation of many JavaScript frameworks and libraries.

**Next Steps:**
1. Practice creating your own higher-order functions
2. Build applications using the module pattern with closures
3. Experiment with functional programming techniques
4. Study how popular libraries use these patterns
5. Learn about async functions and promises (next level!)

The power of JavaScript functions lies not just in what they can do individually, but in how they can be combined, composed, and orchestrated to create sophisticated applications!