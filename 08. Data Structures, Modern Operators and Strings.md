# 🏗️ 8. Data Structures, Modern Operators and Strings

> **Ultimate Modern JavaScript Guide** - Master ES6+ features, data structures, and string manipulation

---

## 🎯 What You'll Master

```
🚀 Modern JavaScript Arsenal:
┌─────────────────────────────────────────────────────────────┐
│ • Destructuring Arrays & Objects                            │
│ • Spread & Rest Operators                                   │
│ • Short Circuiting & Logical Operators                     │
│ • Enhanced Object Literals & Optional Chaining             │
│ • Sets, Maps & Modern Data Structures                      │
│ • String Methods & Text Processing                         │
│ • Real-World Applications & Best Practices                 │
└─────────────────────────────────────────────────────────────┘
```

---

## 📦 Destructuring Arrays

### Basic Array Destructuring

```javascript
// Traditional way (verbose)
const colors = ['red', 'green', 'blue'];
const firstColor = colors[0];
const secondColor = colors[1];
const thirdColor = colors[2];

console.log(firstColor, secondColor, thirdColor);
// Output: red green blue

// ✅ Modern way with destructuring
const [primary, secondary, tertiary] = colors;
console.log(primary, secondary, tertiary);
// Output: red green blue

// Skipping elements
const [first, , third] = colors;
console.log(first, third);
// Output: red blue
```

### Advanced Destructuring Patterns

```javascript
// Nested array destructuring
const nestedArray = [1, 2, [3, 4, [5, 6]]];
const [a, b, [c, d, [e, f]]] = nestedArray;

console.log(a, b, c, d, e, f);
// Output: 1 2 3 4 5 6

// Default values for missing elements
const [x = 10, y = 20, z = 30] = [100, 200];
console.log(x, y, z);
// Output: 100 200 30

// Swapping variables (elegant solution)
let main = 'Italian';
let secondary = 'Vegetarian';

console.log('Before swap:', main, secondary);
// Output: Before swap: Italian Vegetarian

[main, secondary] = [secondary, main];
console.log('After swap:', main, secondary);
// Output: After swap: Vegetarian Italian
```

### Function Return Value Destructuring

```javascript
// Restaurant order system example
const restaurant = {
    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
    mainMenu: ['Pizza', 'Pasta', 'Risotto'],
    
    order(starterIndex, mainIndex) {
        return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
    }
};

// Destructuring function return values
const [starter, mainCourse] = restaurant.order(2, 0);
console.log(`Starter: ${starter}, Main: ${mainCourse}`);
// Output: Starter: Garlic Bread, Main: Pizza

// Multiple return values from function
function getCoordinates() {
    return [40.7128, -74.0060, 'New York'];
}

const [lat, lng, city] = getCoordinates();
console.log(`${city} is located at ${lat}, ${lng}`);
// Output: New York is located at 40.7128, -74.0060
```

---

## 🎁 Destructuring Objects

### Basic Object Destructuring

```javascript
const user = {
    name: 'John Doe',
    age: 30,
    email: 'john@example.com',
    address: {
        street: '123 Main St',
        city: 'New York',
        country: 'USA'
    }
};

// Extract properties with same variable names
const { name, age, email } = user;
console.log(name, age, email);
// Output: John Doe 30 john@example.com

// Rename variables during destructuring
const { name: fullName, age: years, email: contactEmail } = user;
console.log(fullName, years, contactEmail);
// Output: John Doe 30 john@example.com
```

### Advanced Object Destructuring

```javascript
// Default values for missing properties
const { name, age, salary = 50000, department = 'General' } = user;
console.log(`${name} earns $${salary} in ${department}`);
// Output: John Doe earns $50000 in General

// Nested object destructuring
const { address: { street, city, country } } = user;
console.log(`Address: ${street}, ${city}, ${country}`);
// Output: Address: 123 Main St, New York, USA

// Renaming nested properties
const { address: { city: userCity, country: userCountry } } = user;
console.log(`User lives in ${userCity}, ${userCountry}`);
// Output: User lives in New York, USA
```

### Function Parameters Destructuring

```javascript
// Restaurant delivery system
const restaurant = {
    name: 'Classico Italiano',
    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
    mainMenu: ['Pizza', 'Pasta', 'Risotto'],
    
    // Destructuring in function parameters
    orderDelivery({ starterIndex = 1, mainIndex = 0, time = '20:00', address }) {
        console.log(`Order: ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]}`);
        console.log(`Delivery to ${address} at ${time}`);
    }
};

// Calling with object argument
restaurant.orderDelivery({
    time: '22:30',
    address: 'Via del Sole, 21',
    mainIndex: 2,
    starterIndex: 2
});
// Output: Order: Garlic Bread and Risotto
//         Delivery to Via del Sole, 21 at 22:30

// Using defaults when properties are missing
restaurant.orderDelivery({
    address: 'Main Street 123'
});
// Output: Order: Bruschetta and Pizza
//         Delivery to Main Street 123 at 20:00
```

### Mutating Variables with Destructuring

```javascript
let a = 111;
let b = 999;

const obj = { a: 23, b: 7, c: 14 };

// Need parentheses when destructuring into existing variables
({ a, b } = obj);

console.log('New values:', a, b);
// Output: New values: 23 7

// Practical example: Configuration updates
let config = {
    theme: 'dark',
    language: 'en',
    notifications: true
};

const updates = { theme: 'light', notifications: false };
({ theme: config.theme, notifications: config.notifications } = updates);

console.log('Updated config:', config);
// Output: Updated config: { theme: 'light', language: 'en', notifications: false }
```
---

##
 🌟 The Spread Operator (...)

### Array Spreading

```javascript
// Traditional array concatenation
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = arr1.concat(arr2);
console.log(combined);
// Output: [1, 2, 3, 4, 5, 6]

// ✅ Modern way with spread operator
const modernCombined = [...arr1, ...arr2];
console.log(modernCombined);
// Output: [1, 2, 3, 4, 5, 6]

// Adding elements while spreading
const newArray = [0, ...arr1, 3.5, ...arr2, 7];
console.log(newArray);
// Output: [0, 1, 2, 3, 3.5, 4, 5, 6, 7]

// Copying arrays (shallow copy)
const originalMenu = ['Pizza', 'Pasta', 'Risotto'];
const menuCopy = [...originalMenu];
menuCopy.push('Gnocchi');

console.log('Original:', originalMenu);
// Output: Original: ['Pizza', 'Pasta', 'Risotto']
console.log('Copy:', menuCopy);
// Output: Copy: ['Pizza', 'Pasta', 'Risotto', 'Gnocchi']
```

### String Spreading

```javascript
// Spreading strings into individual characters
const name = 'JavaScript';
const letters = [...name];
console.log(letters);
// Output: ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']

// Creating acronyms
const phrase = 'Application Programming Interface';
const acronym = phrase.split(' ').map(word => word[0]).join('');
console.log(acronym);
// Output: API

// Alternative with spread
const words = phrase.split(' ');
const acronymSpread = [...words.map(word => word[0])].join('');
console.log(acronymSpread);
// Output: API
```

### Object Spreading (ES2018)

```javascript
const restaurant = {
    name: 'Classico Italiano',
    location: 'Italy',
    categories: ['Italian', 'Pizzeria']
};

// Creating new object with additional properties
const newRestaurant = {
    foundedIn: 1998,
    ...restaurant,
    founder: 'Giuseppe',
    categories: [...restaurant.categories, 'Vegetarian']
};

console.log(newRestaurant);
// Output: {
//   foundedIn: 1998,
//   name: 'Classico Italiano',
//   location: 'Italy',
//   categories: ['Italian', 'Pizzeria', 'Vegetarian'],
//   founder: 'Giuseppe'
// }

// Copying objects (shallow copy)
const restaurantCopy = { ...restaurant };
restaurantCopy.name = 'Ristorante Roma';

console.log('Original:', restaurant.name);
// Output: Original: Classico Italiano
console.log('Copy:', restaurantCopy.name);
// Output: Copy: Ristorante Roma
```

### Function Arguments Spreading

```javascript
// Function that expects separate arguments
function calculateSum(a, b, c) {
    return a + b + c;
}

const numbers = [5, 10, 15];

// Traditional way
console.log(calculateSum(numbers[0], numbers[1], numbers[2]));
// Output: 30

// ✅ With spread operator
console.log(calculateSum(...numbers));
// Output: 30

// Real-world example: Math functions
const scores = [85, 92, 78, 96, 88];
console.log('Highest score:', Math.max(...scores));
// Output: Highest score: 96
console.log('Lowest score:', Math.min(...scores));
// Output: Lowest score: 78

// Date constructor with spread
const dateArray = [2024, 0, 15]; // Year, Month (0-indexed), Day
const date = new Date(...dateArray);
console.log(date.toDateString());
// Output: Mon Jan 15 2024
```

---

## 🎒 Rest Pattern and Parameters

### Rest in Destructuring

```javascript
// Rest with arrays - collects remaining elements
const [first, second, ...others] = [1, 2, 3, 4, 5, 6];
console.log(first);   // Output: 1
console.log(second);  // Output: 2
console.log(others);  // Output: [3, 4, 5, 6]

// Rest with objects - collects remaining properties
const user = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
    city: 'New York',
    country: 'USA'
};

const { name, age, ...contactInfo } = user;
console.log(name, age);        // Output: John 30
console.log(contactInfo);      // Output: { email: 'john@example.com', city: 'New York', country: 'USA' }

// Practical example: Separating weekdays and weekends
const schedule = {
    monday: '9-5',
    tuesday: '9-5',
    wednesday: '9-5',
    thursday: '9-5',
    friday: '9-5',
    saturday: '10-2',
    sunday: 'closed'
};

const { saturday, sunday, ...weekdays } = schedule;
console.log('Weekdays:', weekdays);
console.log('Weekend:', { saturday, sunday });
// Output: Weekdays: { monday: '9-5', tuesday: '9-5', wednesday: '9-5', thursday: '9-5', friday: '9-5' }
//         Weekend: { saturday: '10-2', sunday: 'closed' }
```

### Rest Parameters in Functions

```javascript
// Function that accepts any number of arguments
function sum(...numbers) {
    console.log('Received arguments:', numbers);
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));           // Output: 6
console.log(sum(1, 2, 3, 4, 5));     // Output: 15
console.log(sum(10, 20));            // Output: 30

// Mixed parameters: regular + rest
function greetUsers(greeting, ...names) {
    console.log(`${greeting} to: ${names.join(', ')}`);
}

greetUsers('Hello', 'John', 'Jane', 'Bob');
// Output: Hello to: John, Jane, Bob

// Real-world example: Pizza ordering system
function orderPizza(mainIngredient, ...otherIngredients) {
    console.log(`Main ingredient: ${mainIngredient}`);
    console.log(`Other ingredients: ${otherIngredients.join(', ')}`);
    console.log(`Total ingredients: ${1 + otherIngredients.length}`);
}

orderPizza('cheese', 'mushrooms', 'pepperoni', 'olives');
// Output: Main ingredient: cheese
//         Other ingredients: mushrooms, pepperoni, olives
//         Total ingredients: 4
```

### Spread vs Rest - Key Differences

```javascript
// SPREAD: Unpacks elements (right side of =)
const arr = [1, 2, 3];
const newArr = [0, ...arr, 4]; // Spreading
console.log(newArr); // Output: [0, 1, 2, 3, 4]

// REST: Packs elements (left side of =)
const [first, ...rest] = newArr; // Rest pattern
console.log(first); // Output: 0
console.log(rest);  // Output: [1, 2, 3, 4]

// Memory aid:
// SPREAD = "Spread out" (expand)
// REST = "Rest of them" (collect)
```

---

## ⚡ Short Circuiting (&& and ||)

### OR Operator (||) - Returns First Truthy Value

```javascript
// Traditional conditional assignment
let username = '';
let displayName;
if (username) {
    displayName = username;
} else {
    displayName = 'Guest';
}
console.log(displayName); // Output: Guest

// ✅ Short circuiting with OR
const displayNameShort = username || 'Guest';
console.log(displayNameShort); // Output: Guest

// Chain of fallbacks
const config = {
    theme: null,
    language: '',
    notifications: undefined
};

const theme = config.theme || config.defaultTheme || 'light';
const language = config.language || navigator.language || 'en';
const notifications = config.notifications || true;

console.log(`Theme: ${theme}, Language: ${language}, Notifications: ${notifications}`);
// Output: Theme: light, Language: en-US, Notifications: true

// Real-world example: API response handling
function processApiResponse(response) {
    const data = response.data || response.result || response.payload || {};
    const message = response.message || response.error || 'No message';
    const status = response.status || response.code || 200;
    
    return { data, message, status };
}

const apiResponse1 = { data: { users: [] }, status: 200 };
const apiResponse2 = { result: { products: [] }, code: 201 };
const apiResponse3 = { error: 'Not found' };

console.log(processApiResponse(apiResponse1));
// Output: { data: { users: [] }, message: 'No message', status: 200 }
console.log(processApiResponse(apiResponse2));
// Output: { data: { products: [] }, message: 'No message', status: 201 }
console.log(processApiResponse(apiResponse3));
// Output: { data: {}, message: 'Not found', status: 200 }
```

### AND Operator (&&) - Returns First Falsy Value

```javascript
// Traditional conditional execution
const user = { name: 'John', isAdmin: true };

if (user && user.isAdmin) {
    console.log('User has admin privileges');
}

// ✅ Short circuiting with AND
user && user.isAdmin && console.log('User has admin privileges');
// Output: User has admin privileges

// Method existence checking
const restaurant = {
    orderPizza(ingredients) {
        console.log(`Ordering pizza with: ${ingredients.join(', ')}`);
    }
};

// Traditional way
if (restaurant.orderPizza) {
    restaurant.orderPizza(['cheese', 'mushrooms']);
}

// ✅ Short circuit way
restaurant.orderPizza && restaurant.orderPizza(['cheese', 'mushrooms']);
// Output: Ordering pizza with: cheese, mushrooms

// Chain of conditions
const permissions = {
    canRead: true,
    canWrite: true,
    canDelete: false
};

permissions.canRead && permissions.canWrite && console.log('User can read and write');
// Output: User can read and write

permissions.canRead && permissions.canWrite && permissions.canDelete && console.log('User has full access');
// (No output - canDelete is false)
```

### Practical Examples

```javascript
// Form validation
function validateForm(formData) {
    const isValid = formData.email && 
                   formData.password && 
                   formData.password.length >= 8 &&
                   formData.email.includes('@');
    
    return isValid && 'Form is valid' || 'Form has errors';
}

console.log(validateForm({ email: 'test@example.com', password: 'password123' }));
// Output: Form is valid

console.log(validateForm({ email: 'invalid', password: '123' }));
// Output: Form has errors

// Feature flags
const features = {
    darkMode: true,
    notifications: false,
    analytics: true
};

features.darkMode && document.body.classList.add('dark-theme');
features.notifications && console.log('Notifications enabled');
features.analytics && console.log('Analytics tracking started');
// Output: Analytics tracking started
```

---

## 🔄 The Nullish Coalescing Operator (??)

### Solving the Zero Problem

```javascript
// Problem with OR operator
const restaurant = {
    name: 'Pizza Palace',
    numGuests: 0  // Valid value, but falsy
};

// ❌ OR operator treats 0 as falsy
const guests1 = restaurant.numGuests || 10;
console.log(`Guests with ||: ${guests1}`);
// Output: Guests with ||: 10 (Wrong! Should be 0)

// ✅ Nullish coalescing only considers null/undefined as "nullish"
const guests2 = restaurant.numGuests ?? 10;
console.log(`Guests with ??: ${guests2}`);
// Output: Guests with ??: 0 (Correct!)

// Comparison of falsy vs nullish values
const testValues = [0, '', false, null, undefined, NaN];

testValues.forEach(value => {
    console.log(`Value: ${value}`);
    console.log(`  With ||: ${value || 'default'}`);
    console.log(`  With ??: ${value ?? 'default'}`);
});
// Output shows ?? only replaces null/undefined, not other falsy values
```

### Real-World Applications

```javascript
// Configuration with meaningful zero values
const gameConfig = {
    playerLives: 0,        // Game over state
    score: 0,              // Starting score
    level: null,           // Not set yet
    difficulty: undefined, // Not chosen
    soundEnabled: false    // Explicitly disabled
};

// Using nullish coalescing for proper defaults
const lives = gameConfig.playerLives ?? 3;
const score = gameConfig.score ?? 0;
const level = gameConfig.level ?? 1;
const difficulty = gameConfig.difficulty ?? 'normal';
const sound = gameConfig.soundEnabled ?? true;

console.log(`Lives: ${lives}, Score: ${score}, Level: ${level}`);
// Output: Lives: 0, Score: 0, Level: 1
console.log(`Difficulty: ${difficulty}, Sound: ${sound}`);
// Output: Difficulty: normal, Sound: false

// API response handling
function processUserData(userData) {
    return {
        id: userData.id ?? generateId(),
        name: userData.name ?? 'Anonymous',
        age: userData.age ?? null,           // Keep null if not provided
        score: userData.score ?? 0,          // Default to 0, preserve 0 if given
        isActive: userData.isActive ?? true  // Default to true, preserve false if given
    };
}

const user1 = { id: 1, name: 'John', age: 0, score: 0, isActive: false };
const user2 = { name: 'Jane' };

console.log(processUserData(user1));
// Output: { id: 1, name: 'John', age: 0, score: 0, isActive: false }
console.log(processUserData(user2));
// Output: { id: 'generated-id', name: 'Jane', age: null, score: 0, isActive: true }
```

---

## 🔧 Logical Assignment Operators (ES2021)

### OR Assignment (||=)

```javascript
// Traditional OR assignment
let user = { name: 'John' };
user.role = user.role || 'guest';

// ✅ Modern OR assignment
user.role ||= 'guest';
console.log(user.role); // Output: guest

// Only assigns if left side is falsy
user.role ||= 'admin'; // Won't change because 'guest' is truthy
console.log(user.role); // Output: guest (unchanged)

// Practical example: Default values for objects
const restaurants = [
    { name: 'Pizza Place', numGuests: 20 },
    { name: 'Burger Joint' }, // Missing numGuests
    { name: 'Taco Stand', numGuests: 0 }
];

restaurants.forEach(restaurant => {
    restaurant.numGuests ||= 10; // Set default only if falsy
    console.log(`${restaurant.name}: ${restaurant.numGuests} guests`);
});
// Output: Pizza Place: 20 guests
//         Burger Joint: 10 guests  
//         Taco Stand: 10 guests (0 was replaced!)
```

### Nullish Assignment (??=)

```javascript
// Better solution for the zero problem
const restaurants2 = [
    { name: 'Pizza Place', numGuests: 20 },
    { name: 'Burger Joint' }, // Missing numGuests
    { name: 'Taco Stand', numGuests: 0 }
];

restaurants2.forEach(restaurant => {
    restaurant.numGuests ??= 10; // Set default only if null/undefined
    console.log(`${restaurant.name}: ${restaurant.numGuests} guests`);
});
// Output: Pizza Place: 20 guests
//         Burger Joint: 10 guests
//         Taco Stand: 0 guests (0 preserved!)

// Configuration management
const config = {
    theme: 'dark',
    timeout: 0,        // Intentional zero
    retries: null,     // Not set
    debug: undefined   // Not set
};

config.theme ??= 'light';     // Won't change (already set)
config.timeout ??= 5000;      // Won't change (0 is not nullish)
config.retries ??= 3;         // Will set to 3 (null is nullish)
config.debug ??= false;       // Will set to false (undefined is nullish)

console.log(config);
// Output: { theme: 'dark', timeout: 0, retries: 3, debug: false }
```

### AND Assignment (&&=)

```javascript
// Assigns only if left side is truthy
const users = [
    { name: 'John', isActive: true },
    { name: 'Jane', isActive: false },
    { name: 'Bob' } // No isActive property
];

users.forEach(user => {
    // Only modify name if user is active
    user.isActive &&= user.name.toUpperCase();
    console.log(user);
});
// Output: { name: 'John', isActive: 'JOHN' }
//         { name: 'Jane', isActive: false }
//         { name: 'Bob' }

// Conditional property modification
const products = [
    { name: 'Laptop', price: 999, onSale: true },
    { name: 'Mouse', price: 25, onSale: false },
    { name: 'Keyboard', price: 75, onSale: true }
];

products.forEach(product => {
    // Apply discount only if on sale
    product.onSale &&= product.price * 0.8; // 20% discount
    console.log(product);
});
// Output: { name: 'Laptop', price: 999, onSale: 799.2 }
//         { name: 'Mouse', price: 25, onSale: false }
//         { name: 'Keyboard', price: 75, onSale: 60 }
```---


## 🔄 Looping Arrays: The for-of Loop

### Basic for-of Loop

```javascript
const menu = ['Pizza', 'Pasta', 'Risotto', 'Gnocchi'];

// Traditional for loop
for (let i = 0; i < menu.length; i++) {
    console.log(`${i + 1}: ${menu[i]}`);
}

// ✅ Modern for-of loop (cleaner syntax)
for (const item of menu) {
    console.log(`Dish: ${item}`);
}
// Output: Dish: Pizza
//         Dish: Pasta
//         Dish: Risotto
//         Dish: Gnocchi

// Getting index with entries()
for (const [index, item] of menu.entries()) {
    console.log(`${index + 1}: ${item}`);
}
// Output: 1: Pizza
//         2: Pasta
//         3: Risotto
//         4: Gnocchi

// What entries() returns
console.log([...menu.entries()]);
// Output: [[0, 'Pizza'], [1, 'Pasta'], [2, 'Risotto'], [3, 'Gnocchi']]
```

### Advanced for-of Applications

```javascript
// Iterating over strings
const message = 'Hello';
for (const char of message) {
    console.log(char);
}
// Output: H e l l o (each on new line)

// Iterating over Sets
const uniqueIngredients = new Set(['tomato', 'cheese', 'basil', 'tomato']);
for (const ingredient of uniqueIngredients) {
    console.log(`Ingredient: ${ingredient}`);
}
// Output: Ingredient: tomato
//         Ingredient: cheese
//         Ingredient: basil

// Iterating over Maps
const restaurantHours = new Map([
    ['monday', '9-17'],
    ['tuesday', '9-17'],
    ['wednesday', 'closed']
]);

for (const [day, hours] of restaurantHours) {
    console.log(`${day}: ${hours}`);
}
// Output: monday: 9-17
//         tuesday: 9-17
//         wednesday: closed

// Real-world example: Processing form data
const formInputs = [
    { name: 'email', value: 'user@example.com', required: true },
    { name: 'password', value: '', required: true },
    { name: 'newsletter', value: 'yes', required: false }
];

const errors = [];
for (const input of formInputs) {
    if (input.required && !input.value) {
        errors.push(`${input.name} is required`);
    }
}

console.log('Validation errors:', errors);
// Output: Validation errors: ['password is required']
```

---

## 🎨 Enhanced Object Literals (ES6)

### Property Shorthand

```javascript
// Traditional object creation
const name = 'Modern Restaurant';
const location = 'Downtown';
const capacity = 50;

const restaurant1 = {
    name: name,
    location: location,
    capacity: capacity
};

// ✅ Enhanced object literals - property shorthand
const restaurant2 = {
    name,        // Same as name: name
    location,    // Same as location: location
    capacity     // Same as capacity: capacity
};

console.log(restaurant2);
// Output: { name: 'Modern Restaurant', location: 'Downtown', capacity: 50 }
```

### Method Shorthand

```javascript
// Traditional method definition
const calculator1 = {
    add: function(a, b) {
        return a + b;
    },
    multiply: function(a, b) {
        return a * b;
    }
};

// ✅ Enhanced object literals - method shorthand
const calculator2 = {
    add(a, b) {
        return a + b;
    },
    multiply(a, b) {
        return a * b;
    },
    // Arrow functions work too, but lose 'this' binding
    subtract: (a, b) => a - b
};

console.log(calculator2.add(5, 3));      // Output: 8
console.log(calculator2.multiply(4, 6)); // Output: 24
console.log(calculator2.subtract(10, 4)); // Output: 6
```

### Computed Property Names

```javascript
// Dynamic property names
const weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];

// Traditional way (verbose)
const schedule1 = {};
schedule1[weekdays[0]] = '9-17';
schedule1[weekdays[1]] = '9-17';
schedule1[weekdays[2]] = '9-17';

// ✅ Enhanced object literals - computed properties
const schedule2 = {
    [weekdays[0]]: '9-17',
    [weekdays[1]]: '9-17',
    [weekdays[2]]: '9-17',
    [weekdays[3]]: '9-17',
    [weekdays[4]]: '9-17',
    [`${weekdays[0]}_backup`]: '10-16'  // Complex expressions
};

console.log(schedule2);
// Output: { monday: '9-17', tuesday: '9-17', ..., monday_backup: '10-16' }

// Real-world example: Dynamic API endpoints
const apiVersion = 'v2';
const endpoints = {
    [`${apiVersion}/users`]: 'GET',
    [`${apiVersion}/users`]: 'POST',
    [`${apiVersion}/products`]: 'GET',
    [`get${apiVersion.toUpperCase()}Users`]: function() {
        return `Fetching users from API ${apiVersion}`;
    }
};

console.log(endpoints);
// Output: { 'v2/users': 'POST', 'v2/products': 'GET', getV2Users: [Function] }
```

### Combining All Features

```javascript
// Real-world restaurant management system
const restaurantName = 'Bella Vista';
const chefName = 'Mario';
const openingHours = {
    monday: { open: 12, close: 22 },
    tuesday: { open: 12, close: 22 },
    wednesday: { open: 12, close: 22 }
};

const restaurant = {
    // Property shorthand
    restaurantName,
    chefName,
    openingHours,
    
    // Computed property names
    [`${restaurantName.toLowerCase().replace(' ', '_')}_id`]: 'rest_001',
    
    // Method shorthand
    getInfo() {
        return `${this.restaurantName} by Chef ${this.chefName}`;
    },
    
    isOpen(day, time) {
        const hours = this.openingHours[day];
        return hours && time >= hours.open && time <= hours.close;
    },
    
    // Method with complex logic
    getSchedule() {
        const schedule = [];
        for (const [day, hours] of Object.entries(this.openingHours)) {
            schedule.push(`${day}: ${hours.open}:00 - ${hours.close}:00`);
        }
        return schedule.join('\n');
    }
};

console.log(restaurant.getInfo());
// Output: Bella Vista by Chef Mario

console.log(restaurant.isOpen('monday', 15));
// Output: true

console.log(restaurant.getSchedule());
// Output: monday: 12:00 - 22:00
//         tuesday: 12:00 - 22:00
//         wednesday: 12:00 - 22:00
```

---

## 🔗 Optional Chaining (?.) - ES2020

### Basic Optional Chaining

```javascript
const restaurant = {
    name: 'Classico Italiano',
    openingHours: {
        thursday: { open: 12, close: 22 },
        friday: { open: 11, close: 23 },
        saturday: { open: 0, close: 24 }
    }
};

// ❌ Traditional way (risky)
// console.log(restaurant.openingHours.monday.open); // TypeError!

// ❌ Safe but verbose
if (restaurant.openingHours && restaurant.openingHours.monday) {
    console.log(restaurant.openingHours.monday.open);
}

// ✅ Optional chaining (clean and safe)
console.log(restaurant.openingHours.monday?.open);
// Output: undefined (no error!)

console.log(restaurant.openingHours?.monday?.open);
// Output: undefined

console.log(restaurant.openingHours?.thursday?.open);
// Output: 12
```

### Optional Chaining with Arrays

```javascript
const users = [
    { name: 'John', address: { street: '123 Main St', city: 'NYC' } },
    { name: 'Jane' }, // No address
    null,             // Null user
];

// Safe array access
console.log(users[0]?.name);           // Output: John
console.log(users[0]?.address?.city);  // Output: NYC
console.log(users[1]?.address?.city);  // Output: undefined
console.log(users[2]?.name);           // Output: undefined
console.log(users[10]?.name);          // Output: undefined

// Real-world example: API response handling
function displayUserInfo(apiResponse) {
    const user = apiResponse?.data?.user;
    const name = user?.profile?.name ?? 'Unknown User';
    const email = user?.contact?.email ?? 'No email';
    const city = user?.address?.city ?? 'Unknown location';
    
    console.log(`${name} (${email}) from ${city}`);
}

displayUserInfo({
    data: {
        user: {
            profile: { name: 'Alice' },
            contact: { email: 'alice@example.com' },
            address: { city: 'Boston' }
        }
    }
});
// Output: Alice (alice@example.com) from Boston

displayUserInfo({ data: {} });
// Output: Unknown User (No email) from Unknown location

displayUserInfo(null);
// Output: Unknown User (No email) from Unknown location
```

### Optional Chaining with Methods

```javascript
const api = {
    users: {
        getAll() { return ['user1', 'user2']; },
        getById(id) { return `user_${id}`; }
    }
};

// Safe method calling
console.log(api.users?.getAll?.());
// Output: ['user1', 'user2']

console.log(api.users?.getById?.(123));
// Output: user_123

console.log(api.products?.getAll?.());
// Output: undefined (no error!)

// Real-world example: Plugin system
const plugins = {
    analytics: {
        track(event) { console.log(`Tracking: ${event}`); }
    }
    // notifications plugin not loaded
};

// Safe plugin method calls
plugins.analytics?.track?.('page_view');
// Output: Tracking: page_view

plugins.notifications?.send?.('Welcome message');
// (No output, no error)

// Conditional method execution
const logger = {
    debug: console.log,
    // info method not available in production
};

logger.debug?.('Debug message');
// Output: Debug message

logger.info?.('Info message');
// (No output, no error)
```

### Combining with Nullish Coalescing

```javascript
// Perfect combination for robust data access
const config = {
    database: {
        host: 'localhost',
        // port missing
        credentials: {
            username: 'admin'
            // password missing
        }
    }
};

// Safe configuration access with defaults
const dbHost = config?.database?.host ?? 'default-host';
const dbPort = config?.database?.port ?? 5432;
const dbUser = config?.database?.credentials?.username ?? 'guest';
const dbPass = config?.database?.credentials?.password ?? 'default-pass';

console.log(`Connecting to ${dbHost}:${dbPort} as ${dbUser}`);
// Output: Connecting to localhost:5432 as admin

// Dynamic property access
const days = ['monday', 'tuesday', 'wednesday'];
const restaurant = {
    openingHours: {
        monday: { open: 9, close: 17 },
        tuesday: { open: 9, close: 17 }
        // wednesday missing
    }
};

for (const day of days) {
    const hours = restaurant.openingHours?.[day];
    const status = hours ? `${hours.open}-${hours.close}` : 'closed';
    console.log(`${day}: ${status}`);
}
// Output: monday: 9-17
//         tuesday: 9-17
//         wednesday: closed
```---


## 🔄 Looping Objects: Keys, Values, and Entries

### Object.keys() - Property Names

```javascript
const restaurant = {
    name: 'Classico Italiano',
    location: 'Italy',
    categories: ['Italian', 'Pizzeria', 'Vegetarian'],
    openingHours: {
        thursday: { open: 12, close: 22 },
        friday: { open: 11, close: 23 },
        saturday: { open: 0, close: 24 }
    }
};

// Get all property names
const properties = Object.keys(restaurant);
console.log('Properties:', properties);
// Output: Properties: ['name', 'location', 'categories', 'openingHours']

// Dynamic string building
let info = `${restaurant.name} has ${properties.length} main properties: `;
for (const prop of properties) {
    info += `${prop}, `;
}
console.log(info.slice(0, -2)); // Remove last comma and space
// Output: Classico Italiano has 4 main properties: name, location, categories, openingHours

// Nested object keys
const hourKeys = Object.keys(restaurant.openingHours);
console.log(`Open ${hourKeys.length} days:`, hourKeys);
// Output: Open 3 days: ['thursday', 'friday', 'saturday']
```

### Object.values() - Property Values

```javascript
// Get all property values
const values = Object.values(restaurant.openingHours);
console.log('Opening hours values:', values);
// Output: Opening hours values: [
//   { open: 12, close: 22 },
//   { open: 11, close: 23 },
//   { open: 0, close: 24 }
// ]

// Processing values
let totalHours = 0;
for (const dayHours of values) {
    const hoursPerDay = dayHours.close - dayHours.open;
    totalHours += hoursPerDay;
}
console.log(`Total opening hours per week: ${totalHours}`);
// Output: Total opening hours per week: 34

// Real-world example: Inventory management
const inventory = {
    apples: 50,
    bananas: 30,
    oranges: 25,
    grapes: 40
};

const quantities = Object.values(inventory);
const totalItems = quantities.reduce((sum, qty) => sum + qty, 0);
const averageStock = totalItems / quantities.length;

console.log(`Total items: ${totalItems}, Average stock: ${averageStock}`);
// Output: Total items: 145, Average stock: 36.25
```

### Object.entries() - Key-Value Pairs

```javascript
// Get key-value pairs as arrays
const entries = Object.entries(restaurant.openingHours);
console.log('Entries:', entries);
// Output: Entries: [
//   ['thursday', { open: 12, close: 22 }],
//   ['friday', { open: 11, close: 23 }],
//   ['saturday', { open: 0, close: 24 }]
// ]

// Destructuring in for-of loop
for (const [day, hours] of entries) {
    console.log(`On ${day} we open at ${hours.open} and close at ${hours.close}`);
}
// Output: On thursday we open at 12 and close at 22
//         On friday we open at 11 and close at 23
//         On saturday we open at 0 and close at 24

// Advanced destructuring with nested objects
for (const [day, { open, close }] of entries) {
    const duration = close - open;
    console.log(`${day}: ${duration} hours (${open}:00 - ${close}:00)`);
}
// Output: thursday: 10 hours (12:00 - 22:00)
//         friday: 12 hours (11:00 - 23:00)
//         saturday: 24 hours (0:00 - 24:00)
```

### Real-World Applications

```javascript
// User preferences management
const userPreferences = {
    theme: 'dark',
    language: 'en',
    notifications: true,
    autoSave: false,
    fontSize: 16
};

// Generate settings summary
function generateSettingsSummary(prefs) {
    const summary = [];
    
    for (const [setting, value] of Object.entries(prefs)) {
        const displayName = setting.replace(/([A-Z])/g, ' $1').toLowerCase();
        summary.push(`${displayName}: ${value}`);
    }
    
    return summary.join('\n');
}

console.log(generateSettingsSummary(userPreferences));
// Output: theme: dark
//         language: en
//         notifications: true
//         auto save: false
//         font size: 16

// Configuration validation
function validateConfig(config, requiredKeys) {
    const configKeys = Object.keys(config);
    const missing = requiredKeys.filter(key => !configKeys.includes(key));
    
    if (missing.length > 0) {
        console.log(`Missing required keys: ${missing.join(', ')}`);
        return false;
    }
    
    console.log('Configuration is valid');
    return true;
}

const apiConfig = {
    baseUrl: 'https://api.example.com',
    timeout: 5000,
    retries: 3
};

validateConfig(apiConfig, ['baseUrl', 'timeout', 'apiKey']);
// Output: Missing required keys: apiKey

// Object transformation
function transformObject(obj, transformer) {
    const result = {};
    
    for (const [key, value] of Object.entries(obj)) {
        const [newKey, newValue] = transformer(key, value);
        result[newKey] = newValue;
    }
    
    return result;
}

const prices = { apple: 1.2, banana: 0.8, orange: 1.5 };

// Convert to uppercase keys and add currency
const pricesWithCurrency = transformObject(prices, (key, value) => [
    key.toUpperCase(),
    `$${value.toFixed(2)}`
]);

console.log(pricesWithCurrency);
// Output: { APPLE: '$1.20', BANANA: '$0.80', ORANGE: '$1.50' }
```

---

## 🎯 Coding Challenge Solutions

### Challenge #1: Football Betting App

```javascript
const game = {
    team1: 'Bayern Munich',
    team2: 'Borrussia Dortmund',
    players: [
        ['Neuer', 'Pavard', 'Martinez', 'Alaba', 'Davies', 'Kimmich', 'Goretzka', 'Coman', 'Muller', 'Gnarby', 'Lewandowski'],
        ['Burki', 'Schulz', 'Hummels', 'Akanji', 'Hakimi', 'Weigl', 'Witsel', 'Hazard', 'Brandt', 'Sancho', 'Gotze']
    ],
    score: '4:0',
    scored: ['Lewandowski', 'Gnarby', 'Lewandowski', 'Hummels'],
    date: 'Nov 9th, 2037',
    odds: {
        team1: 1.33,
        x: 3.25,
        team2: 6.5
    }
};

// 1. Create player arrays for each team
const [players1, players2] = game.players;
console.log('Team 1 players:', players1);
console.log('Team 2 players:', players2);

// 2. Goalkeeper and field players for Bayern Munich
const [gk, ...fieldPlayers] = players1;
console.log('Goalkeeper:', gk);
console.log('Field players:', fieldPlayers);

// 3. All players array
const allPlayers = [...players1, ...players2];
console.log('All players:', allPlayers.length, 'total');

// 4. Final team1 with substitutes
const players1Final = [...players1, 'Thiago', 'Coutinho', 'Perisic'];
console.log('Final team1:', players1Final);

// 5. Destructure odds
const { odds: { team1, x: draw, team2 } } = game;
console.log(`Odds - Team1: ${team1}, Draw: ${draw}, Team2: ${team2}`);

// 6. Print goals function
const printGoals = function(...players) {
    console.log(`${players.length} goals scored by:`, players.join(', '));
};

printGoals('Davies', 'Muller', 'Lewandowski', 'Kimmich');
printGoals(...game.scored);

// 7. Team more likely to win (without if/else)
team1 < team2 && console.log('Team 1 more likely to win');
team1 > team2 && console.log('Team 2 more likely to win');
```

### Challenge #2: Game Statistics

```javascript
// 1. Loop over scored array with goal numbers
for (const [index, player] of game.scored.entries()) {
    console.log(`Goal ${index + 1}: ${player}`);
}

// 2. Calculate average odd
const odds = Object.values(game.odds);
const average = odds.reduce((sum, odd) => sum + odd, 0) / odds.length;
console.log(`Average odd: ${average.toFixed(2)}`);

// 3. Print odds in formatted way
for (const [team, odd] of Object.entries(game.odds)) {
    const teamStr = team === 'x' ? 'draw' : `victory ${game[team]}`;
    console.log(`Odd of ${teamStr}: ${odd}`);
}

// BONUS: Create scorers object
const scorers = {};
for (const player of game.scored) {
    scorers[player] = (scorers[player] || 0) + 1;
}
console.log('Scorers:', scorers);
// Output: { Lewandowski: 2, Gnarby: 1, Hummels: 1 }
```

---

## 🎲 Sets - Unique Collections

### Basic Set Operations

```javascript
// Creating sets
const ordersSet = new Set(['Pasta', 'Pizza', 'Pizza', 'Risotto', 'Pasta', 'Pizza']);
console.log(ordersSet);
// Output: Set(3) {'Pasta', 'Pizza', 'Risotto'}

console.log(ordersSet.size);        // Output: 3
console.log(ordersSet.has('Pizza')); // Output: true
console.log(ordersSet.has('Bread')); // Output: false

// Adding and deleting elements
ordersSet.add('Garlic Bread');
ordersSet.add('Garlic Bread'); // Duplicate ignored
console.log(ordersSet);
// Output: Set(4) {'Pasta', 'Pizza', 'Risotto', 'Garlic Bread'}

ordersSet.delete('Risotto');
console.log(ordersSet);
// Output: Set(3) {'Pasta', 'Pizza', 'Garlic Bread'}

// Clear all elements
// ordersSet.clear(); // Uncomment to clear all
```

### Practical Set Applications

```javascript
// Remove duplicates from array
const staff = ['Waiter', 'Chef', 'Waiter', 'Manager', 'Chef', 'Waiter'];
const staffUnique = [...new Set(staff)];
console.log('Unique staff roles:', staffUnique);
// Output: Unique staff roles: ['Waiter', 'Chef', 'Manager']

// Count unique values
console.log(`${new Set(staff).size} unique roles`);
// Output: 3 unique roles

// String character uniqueness
const name = 'javascript';
const uniqueLetters = new Set(name);
console.log(`"${name}" has ${uniqueLetters.size} unique letters`);
// Output: "javascript" has 8 unique letters

// Set operations (intersection, union, difference)
const italianFoods = new Set(['pizza', 'pasta', 'risotto']);
const mexicanFoods = new Set(['tacos', 'burritos', 'quesadillas']);
const popularFoods = new Set(['pizza', 'tacos', 'pasta']);

// Union (combine sets)
const allFoods = new Set([...italianFoods, ...mexicanFoods]);
console.log('All foods:', [...allFoods]);

// Intersection (common elements)
const commonFoods = new Set([...italianFoods].filter(food => popularFoods.has(food)));
console.log('Common foods:', [...commonFoods]);

// Difference (elements in first set but not in second)
const uniqueItalian = new Set([...italianFoods].filter(food => !popularFoods.has(food)));
console.log('Unique Italian foods:', [...uniqueItalian]);
```

### Real-World Set Examples

```javascript
// User permissions system
class UserPermissions {
    constructor(permissions = []) {
        this.permissions = new Set(permissions);
    }
    
    addPermission(permission) {
        this.permissions.add(permission);
        console.log(`Added permission: ${permission}`);
    }
    
    removePermission(permission) {
        if (this.permissions.delete(permission)) {
            console.log(`Removed permission: ${permission}`);
        } else {
            console.log(`Permission ${permission} not found`);
        }
    }
    
    hasPermission(permission) {
        return this.permissions.has(permission);
    }
    
    getAllPermissions() {
        return [...this.permissions];
    }
}

const userPerms = new UserPermissions(['read', 'write']);
userPerms.addPermission('delete');
userPerms.addPermission('read'); // Duplicate ignored
console.log('User permissions:', userPerms.getAllPermissions());
// Output: User permissions: ['read', 'write', 'delete']

// Tag system for blog posts
const blogPost = {
    title: 'JavaScript Sets',
    tags: new Set(['javascript', 'es6', 'data-structures'])
};

blogPost.tags.add('programming');
blogPost.tags.add('javascript'); // Duplicate ignored

console.log('Post tags:', [...blogPost.tags]);
// Output: Post tags: ['javascript', 'es6', 'data-structures', 'programming']
```

---

## 🗺️ Maps - Key-Value Pairs with Any Key Type

### Basic Map Operations

```javascript
// Creating and populating maps
const restaurant = new Map();
restaurant.set('name', 'Classico Italiano');
restaurant.set(1, 'Firenze, Italy');
restaurant.set(2, 'Lisbon, Portugal');

// Method chaining
restaurant
    .set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'])
    .set('open', 11)
    .set('close', 23)
    .set(true, 'We are open 😊')
    .set(false, 'We are closed 😞');

console.log(restaurant.get('name'));     // Output: Classico Italiano
console.log(restaurant.get(true));      // Output: We are open 😊
console.log(restaurant.get(1));         // Output: Firenze, Italy

// Clever boolean key usage
const time = 21;
const isOpen = time > restaurant.get('open') && time < restaurant.get('close');
console.log(restaurant.get(isOpen));
// Output: We are open 😊 (if time is between 11 and 23)

console.log(restaurant.has('categories')); // Output: true
console.log(restaurant.size);             // Output: 8

// Using objects and arrays as keys
const keyArray = [1, 2];
const keyObject = { type: 'location' };

restaurant.set(keyArray, 'Array key test');
restaurant.set(keyObject, 'Object key test');

console.log(restaurant.get(keyArray));   // Output: Array key test
console.log(restaurant.get(keyObject));  // Output: Object key test
```

### Map Initialization and Iteration

```javascript
// Initialize map with array of arrays
const question = new Map([
    ['question', 'What is the best programming language?'],
    [1, 'C'],
    [2, 'Java'],
    [3, 'JavaScript'],
    ['correct', 3],
    [true, 'Correct! 🎉'],
    [false, 'Try again! 😅']
]);

console.log(question.get('question'));
// Output: What is the best programming language?

// Convert object to map
const hoursObj = {
    thursday: { open: 12, close: 22 },
    friday: { open: 11, close: 23 },
    saturday: { open: 0, close: 24 }
};

const hoursMap = new Map(Object.entries(hoursObj));
console.log(hoursMap);

// Iterating over maps
for (const [key, value] of question) {
    if (typeof key === 'number') {
        console.log(`Answer ${key}: ${value}`);
    }
}
// Output: Answer 1: C
//         Answer 2: Java
//         Answer 3: JavaScript

// Quiz application
const userAnswer = 3;
const isCorrect = question.get('correct') === userAnswer;
console.log(question.get(isCorrect));
// Output: Correct! 🎉
```

### Advanced Map Applications

```javascript
// User session management
const userSessions = new Map();

class User {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}

const user1 = new User(1, 'John');
const user2 = new User(2, 'Jane');

// Using objects as keys
userSessions.set(user1, { loginTime: new Date(), isActive: true });
userSessions.set(user2, { loginTime: new Date(), isActive: false });

console.log('John session:', userSessions.get(user1));
// Output: John session: { loginTime: 2024-01-15T..., isActive: true }

// Cache system with expiration
class Cache {
    constructor() {
        this.cache = new Map();
    }
    
    set(key, value, ttl = 60000) { // TTL in milliseconds
        const expiry = Date.now() + ttl;
        this.cache.set(key, { value, expiry });
    }
    
    get(key) {
        const item = this.cache.get(key);
        if (!item) return null;
        
        if (Date.now() > item.expiry) {
            this.cache.delete(key);
            return null;
        }
        
        return item.value;
    }
    
    size() {
        return this.cache.size;
    }
}

const cache = new Cache();
cache.set('user:1', { name: 'John', age: 30 }, 5000); // 5 second TTL
console.log('Cached user:', cache.get('user:1'));

// Convert map back to array/object
console.log('Map entries:', [...question.entries()]);
console.log('Map keys:', [...question.keys()]);
console.log('Map values:', [...question.values()]);

// Convert map to object
const questionObj = Object.fromEntries(question);
console.log('Map as object:', questionObj);
```

---

## 📊 Data Structure Decision Guide

### When to Use Each Data Structure

```
📋 Data Structure Selection Guide:
┌─────────────────────────────────────────────────────────────┐
│                    ARRAYS vs SETS                           │
├─────────────────────────────────────────────────────────────┤
│ Use ARRAYS when:                                            │
│ • You need ordered data                                     │
│ • You need to access elements by index                     │
│ • You need to manipulate data (map, filter, reduce)        │
│ • Duplicates are meaningful                                 │
│                                                             │
│ Use SETS when:                                              │
│ • You need unique values only                               │
│ • You need fast lookups (has() method)                     │
│ • You need to remove duplicates                             │
│ • Order doesn't matter                                      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                   OBJECTS vs MAPS                           │
├─────────────────────────────────────────────────────────────┤
│ Use OBJECTS when:                                           │
│ • You need records with string keys                         │
│ • You need methods (functions as values)                   │
│ • You need JSON serialization                              │
│ • You're working with classes/prototypes                   │
│                                                             │
│ Use MAPS when:                                              │
│ • Keys are not strings (numbers, objects, etc.)            │
│ • You need frequent additions/deletions                     │
│ • You need to iterate in insertion order                   │
│ • You need the size property                                │
└─────────────────────────────────────────────────────────────┘
```

### Performance Comparison Examples

```javascript
// Performance comparison: Array vs Set for lookups
const largeArray = Array.from({ length: 100000 }, (_, i) => i);
const largeSet = new Set(largeArray);

// Array lookup (slow for large arrays)
console.time('Array includes');
const foundInArray = largeArray.includes(99999);
console.timeEnd('Array includes');

// Set lookup (fast)
console.time('Set has');
const foundInSet = largeSet.has(99999);
console.timeEnd('Set has');

// Object vs Map for frequent updates
const obj = {};
const map = new Map();

// Adding 10000 properties/entries
console.time('Object property addition');
for (let i = 0; i < 10000; i++) {
    obj[`key${i}`] = `value${i}`;
}
console.timeEnd('Object property addition');

console.time('Map entry addition');
for (let i = 0; i < 10000; i++) {
    map.set(`key${i}`, `value${i}`);
}
console.timeEnd('Map entry addition');

console.log(`Object size: ${Object.keys(obj).length}`);
console.log(`Map size: ${map.size}`);
```---


## 🔤 Working with Strings - Part 1: Basics

### String Indexing and Length

```javascript
const airline = 'TAP Air Portugal';
const plane = 'A320';

// Accessing characters by index
console.log(plane[0]);        // Output: A
console.log(plane[1]);        // Output: 3
console.log(plane[2]);        // Output: 2
console.log('B737'[0]);       // Output: B

// String length
console.log(airline.length);  // Output: 16
console.log('B737'.length);   // Output: 4

// Strings are immutable - you can't change individual characters
// plane[0] = 'B'; // This won't work!
```

### Finding Characters and Substrings

```javascript
// indexOf() - first occurrence
console.log(airline.indexOf('r'));        // Output: 6
console.log(airline.indexOf('Portugal')); // Output: 8
console.log(airline.indexOf('portugal')); // Output: -1 (case sensitive!)

// lastIndexOf() - last occurrence
console.log(airline.lastIndexOf('r'));    // Output: 10

// Real-world example: Email validation
const email = 'user@example.com';
const atIndex = email.indexOf('@');
const dotIndex = email.lastIndexOf('.');

if (atIndex > 0 && dotIndex > atIndex) {
    console.log('Valid email format');
} else {
    console.log('Invalid email format');
}
// Output: Valid email format
```

### String Slicing

```javascript
// slice(start, end) - extracts substring
console.log(airline.slice(4));           // Output: Air Portugal
console.log(airline.slice(4, 7));        // Output: Air
console.log(airline.slice(0, airline.indexOf(' '))); // Output: TAP
console.log(airline.slice(airline.lastIndexOf(' ') + 1)); // Output: Portugal

// Negative indices (count from end)
console.log(airline.slice(-2));          // Output: al
console.log(airline.slice(1, -1));       // Output: AP Air Portuga

// Practical example: Extract file extension
function getFileExtension(filename) {
    const dotIndex = filename.lastIndexOf('.');
    return dotIndex !== -1 ? filename.slice(dotIndex + 1) : '';
}

console.log(getFileExtension('document.pdf'));    // Output: pdf
console.log(getFileExtension('image.jpg'));       // Output: jpg
console.log(getFileExtension('noextension'));     // Output: (empty string)
```

### Airline Seat Checker Example

```javascript
// Real-world application: Check middle seat
const checkMiddleSeat = function(seat) {
    // B and E are middle seats in most aircraft configurations
    const seatLetter = seat.slice(-1);
    
    if (seatLetter === 'B' || seatLetter === 'E') {
        console.log(`${seat}: You got the middle seat 😬`);
    } else {
        console.log(`${seat}: You got lucky 😎`);
    }
};

checkMiddleSeat('11B');  // Output: 11B: You got the middle seat 😬
checkMiddleSeat('23C');  // Output: 23C: You got lucky 😎
checkMiddleSeat('3E');   // Output: 3E: You got the middle seat 😬
checkMiddleSeat('1A');   // Output: 1A: You got lucky 😎

// Enhanced version with row information
const analyzeSeat = function(seat) {
    const row = seat.slice(0, -1);
    const letter = seat.slice(-1);
    const rowNum = parseInt(row);
    
    let position, location;
    
    // Determine seat position
    if (['A', 'F'].includes(letter)) position = 'window';
    else if (['B', 'E'].includes(letter)) position = 'middle';
    else position = 'aisle';
    
    // Determine location in plane
    if (rowNum <= 10) location = 'front';
    else if (rowNum <= 30) location = 'middle';
    else location = 'back';
    
    console.log(`Seat ${seat}: ${position} seat in ${location} of plane`);
};

analyzeSeat('5A');   // Output: Seat 5A: window seat in front of plane
analyzeSeat('15C');  // Output: Seat 15C: aisle seat in middle of plane
analyzeSeat('35E');  // Output: Seat 35E: middle seat in back of plane
```

### String Boxing Concept

```javascript
// JavaScript automatically converts string primitives to String objects
console.log(typeof 'jonas');                    // Output: string
console.log(typeof new String('jonas'));        // Output: object
console.log(new String('jonas'));               // Output: String {'jonas'}

// When you call methods on strings, boxing happens automatically
console.log('jonas'.toUpperCase());             // Output: JONAS
console.log(typeof 'jonas'.toUpperCase());      // Output: string (result is primitive)

// This is what happens behind the scenes:
// 'jonas' -> new String('jonas') -> method call -> convert back to primitive
```

---

## 🔤 Working with Strings - Part 2: Transformation

### Case Conversion

```javascript
const airline = 'TAP Air Portugal';

console.log(airline.toLowerCase());  // Output: tap air portugal
console.log(airline.toUpperCase());  // Output: TAP AIR PORTUGAL

// Practical example: Fix capitalization
const passenger = 'jOnAS';
const passengerCorrect = passenger.toLowerCase();
const passengerFixed = passengerCorrect[0].toUpperCase() + passengerCorrect.slice(1);
console.log(passengerFixed);  // Output: Jonas

// Function to capitalize names
function capitalizeName(name) {
    const nameLower = name.toLowerCase();
    return nameLower[0].toUpperCase() + nameLower.slice(1);
}

console.log(capitalizeName('MARY'));     // Output: Mary
console.log(capitalizeName('john'));     // Output: John
console.log(capitalizeName('aNNa'));     // Output: Anna
```

### Trimming Whitespace

```javascript
// Comparing emails with whitespace issues
const email = 'hello@jonas.io';
const loginEmail = '  Hello@Jonas.Io \n';

console.log(loginEmail);  // Output: "  Hello@Jonas.Io \n"

// Clean up the email
const normalizedEmail = loginEmail.toLowerCase().trim();
console.log(normalizedEmail);           // Output: hello@jonas.io
console.log(email === normalizedEmail); // Output: true

// Real-world form processing
function processFormInput(input) {
    return input.trim().toLowerCase();
}

const userInputs = [
    '  John Doe  ',
    '\n  jane@example.com  \t',
    '  PASSWORD123  '
];

userInputs.forEach(input => {
    console.log(`"${input}" -> "${processFormInput(input)}"`);
});
// Output: "  John Doe  " -> "john doe"
//         "\n  jane@example.com  \t" -> "jane@example.com"
//         "  PASSWORD123  " -> "password123"
```

### String Replacement

```javascript
// Basic replacement
const priceGB = '288,97£';
const priceUS = priceGB.replace('£', '$').replace(',', '.');
console.log(priceUS);  // Output: 288.97$

// Replace only replaces first occurrence
const announcement = 'All passengers come to boarding door 23. Boarding door 23!';
console.log(announcement.replace('door', 'gate'));
// Output: All passengers come to boarding gate 23. Boarding door 23!

// Replace all occurrences (ES2021)
console.log(announcement.replaceAll('door', 'gate'));
// Output: All passengers come to boarding gate 23. Boarding gate 23!

// Using regular expressions for global replacement
console.log(announcement.replace(/door/g, 'gate'));
// Output: All passengers come to boarding gate 23. Boarding gate 23!

// Case-insensitive replacement
const text = 'JavaScript is great. javascript is powerful.';
console.log(text.replace(/javascript/gi, 'JS'));
// Output: JS is great. JS is powerful.
```

### Boolean String Methods

```javascript
const plane = 'Airbus A320neo';

// includes() - check if substring exists
console.log(plane.includes('A320'));    // Output: true
console.log(plane.includes('Boeing'));  // Output: false

// startsWith() - check if string starts with substring
console.log(plane.startsWith('Airb'));  // Output: true
console.log(plane.startsWith('Boeing')); // Output: false

// endsWith() - check if string ends with substring
console.log(plane.endsWith('neo'));     // Output: true
console.log(plane.endsWith('A320'));    // Output: false

// Combining conditions
if (plane.startsWith('Airbus') && plane.endsWith('neo')) {
    console.log('Part of the NEW Airbus family');
}
// Output: Part of the NEW Airbus family

// Real-world example: Security check
const checkBaggage = function(items) {
    const baggage = items.toLowerCase();
    
    const prohibitedItems = ['knife', 'gun', 'bomb', 'weapon'];
    const hasProhibited = prohibitedItems.some(item => baggage.includes(item));
    
    if (hasProhibited) {
        console.log('🚫 You are NOT allowed on board');
    } else {
        console.log('✅ Welcome aboard!');
    }
};

checkBaggage('I have a laptop, some Food and a pocket Knife');
// Output: 🚫 You are NOT allowed on board

checkBaggage('Socks and camera');
// Output: ✅ Welcome aboard!

checkBaggage('Got some snacks and a gun for protection');
// Output: 🚫 You are NOT allowed on board

// URL validation example
function isValidUrl(url) {
    const urlLower = url.toLowerCase();
    return urlLower.startsWith('http://') || urlLower.startsWith('https://');
}

console.log(isValidUrl('https://example.com'));  // Output: true
console.log(isValidUrl('ftp://example.com'));    // Output: false
console.log(isValidUrl('HTTP://EXAMPLE.COM'));   // Output: true
```

---

## 🔤 Working with Strings - Part 3: Advanced Operations

### Split and Join

```javascript
// split() - convert string to array
console.log('a+very+nice+string'.split('+'));
// Output: ['a', 'very', 'nice', 'string']

console.log('Jonas Schmedtmann'.split(' '));
// Output: ['Jonas', 'Schmedtmann']

// Destructuring with split
const [firstName, lastName] = 'Jonas Schmedtmann'.split(' ');
console.log(firstName, lastName);  // Output: Jonas Schmedtmann

// join() - convert array to string
const newName = ['Mr.', firstName, lastName.toUpperCase()].join(' ');
console.log(newName);  // Output: Mr. Jonas SCHMEDTMANN

// Real-world example: Capitalize all words
const capitalizeName = function(name) {
    const names = name.split(' ');
    const namesUpper = [];
    
    for (const word of names) {
        // Method 1: Using charAt and slice
        namesUpper.push(word[0].toUpperCase() + word.slice(1));
        
        // Method 2: Using replace
        // namesUpper.push(word.replace(word[0], word[0].toUpperCase()));
    }
    
    return namesUpper.join(' ');
};

console.log(capitalizeName('jessica ann smith davis'));
// Output: Jessica Ann Smith Davis

console.log(capitalizeName('jonas schmedtmann'));
// Output: Jonas Schmedtmann

// Advanced: Handle edge cases
const smartCapitalize = function(name) {
    const exceptions = ['de', 'da', 'the', 'van', 'von'];
    
    return name
        .toLowerCase()
        .split(' ')
        .map(word => {
            if (exceptions.includes(word)) {
                return word;
            }
            return word[0].toUpperCase() + word.slice(1);
        })
        .join(' ');
};

console.log(smartCapitalize('leonardo da vinci'));
// Output: Leonardo da Vinci

console.log(smartCapitalize('vincent van gogh'));
// Output: Vincent van Gogh
```

### Padding Strings

```javascript
// padStart() - add characters to beginning
const message = 'Go to gate 23!';
console.log(message.padStart(20, '+'));
// Output: ++++++Go to gate 23!

console.log(message.padStart(20, '+').padEnd(30, '+'));
// Output: ++++++Go to gate 23!++++++++++

console.log('Jonas'.padStart(20, '+').padEnd(30, '+'));
// Output: +++++++++++++++Jonas++++++++++

// Real-world example: Credit card masking
const maskCreditCard = function(number) {
    const str = number + ''; // Convert to string
    const last4 = str.slice(-4);
    return last4.padStart(str.length, '*');
};

console.log(maskCreditCard(64637836));
// Output: ****7836

console.log(maskCreditCard(43378463864647384));
// Output: *************7384

console.log(maskCreditCard('334859493847755774747'));
// Output: *****************4747

// Formatting numbers with padding
const formatAccountNumber = function(number) {
    return String(number).padStart(8, '0');
};

console.log(formatAccountNumber(123));      // Output: 00000123
console.log(formatAccountNumber(45678));    // Output: 00045678
console.log(formatAccountNumber(12345678)); // Output: 12345678

// Creating simple tables
const products = [
    { name: 'Laptop', price: 999.99 },
    { name: 'Mouse', price: 25.50 },
    { name: 'Keyboard', price: 75.00 }
];

console.log('Product'.padEnd(15) + 'Price'.padStart(10));
console.log('-'.repeat(25));

products.forEach(product => {
    const name = product.name.padEnd(15);
    const price = `$${product.price.toFixed(2)}`.padStart(10);
    console.log(name + price);
});
// Output: Product        Price
//         -------------------------
//         Laptop           $999.99
//         Mouse             $25.50
//         Keyboard          $75.00
```

### String Repetition

```javascript
// repeat() - repeat string multiple times
const message2 = 'Bad weather... All departures delayed... ';
console.log(message2.repeat(5));
// Output: Bad weather... All departures delayed... (repeated 5 times)

// Real-world example: Visual indicators
const planesInLine = function(n) {
    console.log(`There are ${n} planes in line ${'✈️'.repeat(n)}`);
};

planesInLine(5);   // Output: There are 5 planes in line ✈️✈️✈️✈️✈️
planesInLine(3);   // Output: There are 3 planes in line ✈️✈️✈️
planesInLine(12);  // Output: There are 12 planes in line ✈️✈️✈️✈️✈️✈️✈️✈️✈️✈️✈️✈️

// Progress bar simulation
const showProgress = function(percentage) {
    const filled = Math.floor(percentage / 5); // Each block represents 5%
    const empty = 20 - filled;
    
    const bar = '█'.repeat(filled) + '░'.repeat(empty);
    console.log(`[${bar}] ${percentage}%`);
};

showProgress(0);    // Output: [░░░░░░░░░░░░░░░░░░░░] 0%
showProgress(25);   // Output: [█████░░░░░░░░░░░░░░░] 25%
showProgress(50);   // Output: [██████████░░░░░░░░░░] 50%
showProgress(75);   // Output: [███████████████░░░░░] 75%
showProgress(100);  // Output: [████████████████████] 100%

// Creating ASCII art borders
const createBorder = function(text, char = '*') {
    const border = char.repeat(text.length + 4);
    console.log(border);
    console.log(`${char} ${text} ${char}`);
    console.log(border);
};

createBorder('WELCOME', '*');
// Output: *********
//         * WELCOME *
//         *********

createBorder('JavaScript Rocks!', '=');
// Output: ==================
//         = JavaScript Rocks! =
//         ==================
```

---

## 🎯 Coding Challenge #4: CamelCase Converter

### The Challenge

```javascript
// Challenge: Convert underscore_case to camelCase
// Input from textarea, output with checkmarks

document.body.append(document.createElement('textarea'));
document.body.append(document.createElement('button'));

document.querySelector('button').addEventListener('click', function() {
    const text = document.querySelector('textarea').value;
    const rows = text.split('\n');
    
    for (const [index, row] of rows.entries()) {
        const [first, second] = row.toLowerCase().trim().split('_');
        
        const output = `${first}${second.replace(second[0], second[0].toUpperCase())}`;
        console.log(`${output.padEnd(20)}${'✅'.repeat(index + 1)}`);
    }
});

// Test input:
// underscore_case
// first_name
// Some_Variable
// calculate_AGE
// delayed_departure

// Expected output:
// underscoreCase      ✅
// firstName           ✅✅
// someVariable        ✅✅✅
// calculateAge        ✅✅✅✅
// delayedDeparture    ✅✅✅✅✅
```

### Enhanced Version with Error Handling

```javascript
const convertToCamelCase = function() {
    const textarea = document.querySelector('textarea');
    const text = textarea.value;
    
    if (!text.trim()) {
        console.log('Please enter some text to convert');
        return;
    }
    
    const rows = text.split('\n').filter(row => row.trim()); // Remove empty lines
    
    console.log('Converting to camelCase:');
    console.log('-'.repeat(30));
    
    rows.forEach((row, index) => {
        const cleanRow = row.trim();
        
        if (!cleanRow.includes('_')) {
            console.log(`${cleanRow.padEnd(20)} ❌ (no underscore found)`);
            return;
        }
        
        const parts = cleanRow.toLowerCase().split('_');
        
        if (parts.length < 2) {
            console.log(`${cleanRow.padEnd(20)} ❌ (invalid format)`);
            return;
        }
        
        // Convert to camelCase
        const camelCase = parts[0] + parts.slice(1)
            .map(part => part[0].toUpperCase() + part.slice(1))
            .join('');
        
        console.log(`${camelCase.padEnd(20)}${'✅'.repeat(index + 1)}`);
    });
};

// Alternative implementation using reduce
const convertToCamelCaseAdvanced = function(text) {
    return text
        .split('\n')
        .filter(row => row.trim())
        .map((row, index) => {
            const parts = row.toLowerCase().trim().split('_');
            
            const camelCase = parts.reduce((acc, part, i) => {
                return i === 0 ? part : acc + part[0].toUpperCase() + part.slice(1);
            }, '');
            
            return `${camelCase.padEnd(20)}${'✅'.repeat(index + 1)}`;
        })
        .join('\n');
};

// Test the advanced version
const testInput = `underscore_case
first_name
Some_Variable
calculate_AGE
delayed_departure`;

console.log(convertToCamelCaseAdvanced(testInput));
```

---

## 🛠️ String Methods Practice: Flight Data Processing

### Real-World Data Processing

```javascript
// Raw flight data string
const flights = '_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30';

// Expected output format:
// 🔴 Delayed Departure from FAO to TXL (11h25)
//              Arrival from BRU to FAO (11h45)
//   🔴 Delayed Arrival from HEL to FAO (12h05)
//            Departure from FAO to LIS (12h30)

// Helper function to extract airport code
const getCode = str => str.slice(0, 3).toUpperCase();

// Process each flight
for (const flight of flights.split('+')) {
    const [type, from, to, time] = flight.split(';');
    
    // Clean up the flight type
    const output = `${type.startsWith('_Delayed') ? '🔴' : ''}${type.replaceAll('_', ' ')} from ${getCode(from)} to ${getCode(to)} (${time.replace(':', 'h')})`.padStart(50);
    
    console.log(output);
}

// Enhanced version with better formatting
const processFlightData = function(flightString) {
    const flights = flightString.split('+');
    
    console.log('✈️  FLIGHT INFORMATION BOARD  ✈️');
    console.log('='.repeat(50));
    
    flights.forEach(flight => {
        const [type, from, to, time] = flight.split(';');
        
        // Extract airport codes
        const fromCode = getCode(from);
        const toCode = getCode(to);
        
        // Format time
        const formattedTime = time.replace(':', 'h');
        
        // Determine if delayed
        const isDelayed = type.startsWith('_Delayed');
        const status = isDelayed ? '🔴 DELAYED' : '✅ ON TIME';
        
        // Clean flight type
        const flightType = type.replaceAll('_', ' ').trim();
        
        // Format output
        const flightInfo = `${flightType} from ${fromCode} to ${toCode} (${formattedTime})`;
        
        console.log(`${status} ${flightInfo}`);
    });
    
    console.log('='.repeat(50));
};

processFlightData(flights);

// Statistical analysis of flight data
const analyzeFlights = function(flightString) {
    const flights = flightString.split('+');
    let delayed = 0;
    let onTime = 0;
    const routes = new Set();
    const airports = new Set();
    
    flights.forEach(flight => {
        const [type, from, to, time] = flight.split(';');
        
        // Count delays
        if (type.startsWith('_Delayed')) {
            delayed++;
        } else {
            onTime++;
        }
        
        // Track routes and airports
        const fromCode = getCode(from);
        const toCode = getCode(to);
        routes.add(`${fromCode}-${toCode}`);
        airports.add(fromCode);
        airports.add(toCode);
    });
    
    console.log('\n📊 FLIGHT STATISTICS');
    console.log('-'.repeat(30));
    console.log(`Total flights: ${flights.length}`);
    console.log(`On time: ${onTime} (${((onTime/flights.length)*100).toFixed(1)}%)`);
    console.log(`Delayed: ${delayed} (${((delayed/flights.length)*100).toFixed(1)}%)`);
    console.log(`Unique routes: ${routes.size}`);
    console.log(`Airports served: ${airports.size}`);
    console.log(`Airports: ${[...airports].join(', ')}`);
};

analyzeFlights(flights);
```

---

## 🎯 Key Takeaways & Best Practices

### Modern JavaScript Patterns

```javascript
// ✅ Best Practices Summary

// 1. Use destructuring for cleaner code
const user = { name: 'John', age: 30, email: 'john@example.com' };
const { name, age } = user; // Instead of user.name, user.age

// 2. Use spread operator for array/object operations
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // Instead of arr1.concat([4, 5])

// 3. Use rest parameters for flexible functions
const sum = (...numbers) => numbers.reduce((a, b) => a + b, 0);

// 4. Use nullish coalescing for meaningful falsy values
const config = { timeout: 0 };
const timeout = config.timeout ?? 5000; // Preserves 0, unlike ||

// 5. Use optional chaining for safe property access
const city = user?.address?.city ?? 'Unknown';

// 6. Choose the right data structure
const uniqueItems = new Set(array); // For unique values
const keyValuePairs = new Map(); // For non-string keys

// 7. Use modern string methods
const formatted = text.trim().toLowerCase().replaceAll(' ', '-');

// 8. Combine techniques for powerful solutions
const processUsers = (users) => {
    return users
        ?.filter(user => user?.isActive)
        ?.map(({ name, email, ...rest }) => ({
            displayName: name?.toUpperCase() ?? 'UNKNOWN',
            contact: email?.toLowerCase().trim(),
            ...rest
        })) ?? [];
};
```

### Performance Tips

```javascript
// ✅ Performance optimizations

// 1. Use Set for fast lookups instead of Array.includes()
const allowedUsers = new Set(['admin', 'user', 'guest']);
const isAllowed = allowedUsers.has(userRole); // O(1) vs O(n)

// 2. Use Map for frequent key-value operations
const cache = new Map();
cache.set(key, value); // Faster than object property assignment

// 3. Use string methods efficiently
const processText = (text) => {
    return text
        .trim()
        .toLowerCase()
        .split(' ')
        .filter(word => word.length > 2)
        .join(' ');
};

// 4. Avoid unnecessary string concatenation in loops
const buildString = (items) => {
    return items.join(', '); // Instead of loop with +=
};
```

---

## 🏆 Mastery Checklist

```
🎯 Modern JavaScript Data Structures & Operators Mastery:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Master destructuring for arrays and objects             │
│ ✅ Use spread and rest operators effectively               │
│ ✅ Apply short-circuiting and logical operators           │
│ ✅ Leverage optional chaining and nullish coalescing      │
│ ✅ Choose appropriate data structures (Set vs Array)       │
│ ✅ Utilize Maps for complex key-value relationships        │
│ ✅ Process strings with modern methods efficiently         │
│ ✅ Combine techniques for elegant solutions                │
└─────────────────────────────────────────────────────────────┘
```

**Remember:** These modern JavaScript features aren't just syntactic sugar - they solve real problems, improve code readability, and often provide better performance. Master them to write more elegant, maintainable, and efficient code!

**Next Steps:**
1. Practice combining multiple techniques in real projects
2. Learn about advanced array methods (map, filter, reduce)
3. Explore more ES6+ features like classes and modules
4. Study functional programming patterns in JavaScript
5. Build applications that showcase these modern patterns

The power of modern JavaScript lies in combining these features to create clean, expressive, and robust applications!