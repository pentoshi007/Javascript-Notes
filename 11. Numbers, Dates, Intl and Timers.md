# 🔢 11. Numbers, Dates, Intl and Timers

> **Ultimate JavaScript Numbers & Dates Masterclass** - Master number operations, date handling, internationalization, and timing functions

---

## 🎯 What You'll Master

```
🚀 Numbers, Dates & Internationalization Arsenal:
┌─────────────────────────────────────────────────────────────┐
│ • Number Conversion & Validation                            │
│ • Math Operations & Rounding Techniques                    │
│ • Date Creation & Manipulation                             │
│ • Internationalization (Intl API)                          │
│ • Timers & Asynchronous Operations                         │
│ • BigInt for Large Numbers                                 │
│ • Real-World Banking Application                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔢 Converting and Checking Numbers

### Number System Fundamentals

```javascript
// JavaScript uses 64-bit floating point (IEEE 754 standard)
console.log(23 === 23.0); // Output: true (integers are floats internally)

// Binary representation limitations
console.log(0.1 + 0.2); // Output: 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // Output: false (floating point precision issue)

// Why this happens:
// Base 10: 1/10 = 0.1 (exact)
// Base 2: 1/10 = 0.0001100110011... (infinite)
console.log('Precision issue explanation:');
console.log('0.1 in binary is infinite, so JavaScript approximates it');

// Safe comparison for decimals
function isEqual(a, b, tolerance = 0.0001) {
    return Math.abs(a - b) < tolerance;
}

console.log('Safe decimal comparison:');
console.log(isEqual(0.1 + 0.2, 0.3)); // Output: true
```

### Number Conversion Methods

```javascript
// String to number conversion
console.log('=== Number Conversion ===');

// Method 1: Number() constructor
console.log(Number('23')); // Output: 23
console.log(Number('23.5')); // Output: 23.5
console.log(Number('23px')); // Output: NaN
console.log(Number('')); // Output: 0
console.log(Number('   ')); // Output: 0

// Method 2: Unary plus operator (most concise)
console.log(+'23'); // Output: 23
console.log(+'23.5'); // Output: 23.5
console.log(+'23px'); // Output: NaN

// Method 3: parseInt() - extracts integer from string
console.log('=== parseInt Examples ===');
console.log(Number.parseInt('30px', 10)); // Output: 30 (base 10)
console.log(Number.parseInt('e23', 10)); // Output: NaN (doesn't start with number)
console.log(Number.parseInt('30.5px', 10)); // Output: 30 (stops at decimal)
console.log(Number.parseInt('1010', 2)); // Output: 10 (binary to decimal)
console.log(Number.parseInt('FF', 16)); // Output: 255 (hex to decimal)

// Method 4: parseFloat() - extracts decimal number
console.log('=== parseFloat Examples ===');
console.log(Number.parseFloat('  2.5rem  ')); // Output: 2.5
console.log(Number.parseFloat('2.5.6px')); // Output: 2.5 (stops at second dot)
console.log(Number.parseFloat('abc2.5')); // Output: NaN (doesn't start with number)

// Global vs Number namespace (both work, Number is preferred)
console.log(parseFloat('2.5rem')); // Output: 2.5 (global function)
console.log(Number.parseFloat('2.5rem')); // Output: 2.5 (namespace method - preferred)

// Real-world example: Extract numeric values from CSS
function extractNumericValue(cssValue) {
    const number = Number.parseFloat(cssValue);
    const unit = cssValue.replace(number.toString(), '').trim();
    return { value: number, unit: unit };
}

console.log('CSS value extraction:');
console.log(extractNumericValue('16px')); // Output: { value: 16, unit: 'px' }
console.log(extractNumericValue('2.5rem')); // Output: { value: 2.5, unit: 'rem' }
console.log(extractNumericValue('100%')); // Output: { value: 100, unit: '%' }
```

### Number Validation

```javascript
// Checking for NaN (Not a Number)
console.log('=== NaN Checking ===');
console.log(Number.isNaN(20)); // Output: false
console.log(Number.isNaN('20')); // Output: false (string is not NaN)
console.log(Number.isNaN(+'20X')); // Output: true (conversion failed)
console.log(Number.isNaN(23 / 0)); // Output: false (Infinity is not NaN)
console.log(Number.isNaN(0 / 0)); // Output: true (undefined operation)

// ⚠️ Global isNaN vs Number.isNaN
console.log('Global vs Number.isNaN:');
console.log(isNaN('20X')); // Output: true (converts to number first)
console.log(Number.isNaN('20X')); // Output: false (doesn't convert)

// ✅ Best method: Check if value is a finite number
console.log('=== Finite Number Checking ===');
console.log(Number.isFinite(20)); // Output: true
console.log(Number.isFinite('20')); // Output: false (string)
console.log(Number.isFinite(+'20X')); // Output: false (NaN)
console.log(Number.isFinite(23 / 0)); // Output: false (Infinity)
console.log(Number.isFinite(-23 / 0)); // Output: false (-Infinity)

// Check if value is an integer
console.log('=== Integer Checking ===');
console.log(Number.isInteger(23)); // Output: true
console.log(Number.isInteger(23.0)); // Output: true (23.0 is integer)
console.log(Number.isInteger(23.5)); // Output: false
console.log(Number.isInteger('23')); // Output: false (string)
console.log(Number.isInteger(23 / 0)); // Output: false (Infinity)

// Practical validation function
function validateNumber(input, options = {}) {
    const { 
        allowStrings = false, 
        mustBeInteger = false, 
        min = -Infinity, 
        max = Infinity 
    } = options;
    
    let num = input;
    
    // Convert string to number if allowed
    if (allowStrings && typeof input === 'string') {
        num = Number(input);
    }
    
    // Check if it's a valid finite number
    if (!Number.isFinite(num)) {
        return { valid: false, error: 'Not a valid number' };
    }
    
    // Check if integer is required
    if (mustBeInteger && !Number.isInteger(num)) {
        return { valid: false, error: 'Must be an integer' };
    }
    
    // Check range
    if (num < min || num > max) {
        return { valid: false, error: `Must be between ${min} and ${max}` };
    }
    
    return { valid: true, value: num };
}

// Test validation function
console.log('=== Validation Examples ===');
console.log(validateNumber(25)); // Output: { valid: true, value: 25 }
console.log(validateNumber('25', { allowStrings: true })); // Output: { valid: true, value: 25 }
console.log(validateNumber(25.5, { mustBeInteger: true })); // Output: { valid: false, error: 'Must be an integer' }
console.log(validateNumber(150, { min: 0, max: 100 })); // Output: { valid: false, error: 'Must be between 0 and 100' }
```

---

## 📐 Math and Rounding

### Math Object Methods

```javascript
// Square roots and powers
console.log('=== Roots and Powers ===');
console.log(Math.sqrt(25)); // Output: 5
console.log(25 ** (1/2)); // Output: 5 (alternative syntax)
console.log(Math.pow(25, 0.5)); // Output: 5 (alternative method)

// Cube root
console.log(Math.cbrt(8)); // Output: 2
console.log(8 ** (1/3)); // Output: 2 (alternative)

// Other roots
console.log(16 ** (1/4)); // Output: 2 (fourth root)
console.log(32 ** (1/5)); // Output: 2 (fifth root)

// Min and Max
console.log('=== Min and Max ===');
console.log(Math.max(5, 18, 23, 11, 2)); // Output: 23
console.log(Math.max(5, 18, '23', 11, 2)); // Output: 23 (type coercion)
console.log(Math.max(5, 18, '23px', 11, 2)); // Output: NaN (can't convert)

console.log(Math.min(5, 18, 23, 11, 2)); // Output: 2

// Find min/max in arrays
const numbers = [5, 18, 23, 11, 2, 45, 7];
console.log('Array min/max:');
console.log(Math.max(...numbers)); // Output: 45
console.log(Math.min(...numbers)); // Output: 2

// Constants
console.log('=== Math Constants ===');
console.log(Math.PI); // Output: 3.141592653589793
console.log(Math.E); // Output: 2.718281828459045

// Calculate circle area
const radius = 10;
const area = Math.PI * radius ** 2;
console.log(`Circle area (radius ${radius}):`, area.toFixed(2)); // Output: 314.16

// Random numbers
console.log('=== Random Numbers ===');
console.log(Math.random()); // Output: 0.0 to 0.999... (random)

// Random integer between min and max (inclusive)
const randomInt = (min, max) => 
    Math.floor(Math.random() * (max - min + 1)) + min;

console.log('Random integers:');
console.log(randomInt(1, 6)); // Dice roll
console.log(randomInt(10, 20)); // Random between 10-20
console.log(randomInt(-5, 5)); // Random between -5 and 5

// Generate array of random numbers
const generateRandomArray = (length, min, max) =>
    Array.from({ length }, () => randomInt(min, max));

console.log('Random array:', generateRandomArray(5, 1, 100));
```

### Rounding Methods

```javascript
// Rounding integers
console.log('=== Integer Rounding ===');
const testNumber = 23.7;

console.log(Math.round(testNumber)); // Output: 24 (rounds to nearest)
console.log(Math.round(23.3)); // Output: 23
console.log(Math.round(23.5)); // Output: 24

console.log(Math.ceil(testNumber)); // Output: 24 (always rounds up)
console.log(Math.ceil(23.1)); // Output: 24
console.log(Math.ceil(23.0)); // Output: 23

console.log(Math.floor(testNumber)); // Output: 23 (always rounds down)
console.log(Math.floor(23.9)); // Output: 23
console.log(Math.floor('23.9')); // Output: 23 (type coercion)

console.log(Math.trunc(testNumber)); // Output: 23 (removes decimal part)
console.log(Math.trunc(23.9)); // Output: 23

// Difference between floor and trunc with negative numbers
console.log('=== Negative Numbers ===');
console.log(Math.trunc(-23.3)); // Output: -23 (removes decimal)
console.log(Math.floor(-23.3)); // Output: -24 (rounds down = more negative)

// ✅ floor() is better for random integers (works with negative numbers)
const betterRandomInt = (min, max) => 
    Math.floor(Math.random() * (max - min + 1)) + min;

// Rounding decimals
console.log('=== Decimal Rounding ===');
console.log((2.7).toFixed(0)); // Output: "3" (string!)
console.log((2.7).toFixed(3)); // Output: "2.700"
console.log((2.345).toFixed(2)); // Output: "2.35" (rounds)
console.log(+(2.345).toFixed(2)); // Output: 2.35 (convert back to number)

// Custom rounding function
function roundToDecimalPlaces(number, places) {
    const factor = Math.pow(10, places);
    return Math.round(number * factor) / factor;
}

console.log('Custom rounding:');
console.log(roundToDecimalPlaces(2.345, 2)); // Output: 2.35
console.log(roundToDecimalPlaces(2.344, 2)); // Output: 2.34

// Practical examples
console.log('=== Practical Examples ===');

// Price calculation with proper rounding
function calculatePrice(basePrice, taxRate, discountPercent = 0) {
    const discountAmount = basePrice * (discountPercent / 100);
    const discountedPrice = basePrice - discountAmount;
    const tax = discountedPrice * (taxRate / 100);
    const finalPrice = discountedPrice + tax;
    
    return {
        basePrice: +basePrice.toFixed(2),
        discount: +discountAmount.toFixed(2),
        discountedPrice: +discountedPrice.toFixed(2),
        tax: +tax.toFixed(2),
        finalPrice: +finalPrice.toFixed(2)
    };
}

const priceBreakdown = calculatePrice(99.99, 8.25, 15);
console.log('Price breakdown:', priceBreakdown);
// Output: { basePrice: 99.99, discount: 15, discountedPrice: 84.99, tax: 7.01, finalPrice: 92 }

// Boxing explanation (primitives don't have methods)
console.log('=== Boxing Explanation ===');
// When we call (2.7).toFixed(), JavaScript does this behind the scenes:
// 1. new Number(2.7) - creates Number object
// 2. calls toFixed() method on the object
// 3. converts result back to primitive
// This is called "boxing"
```

---

## ➗ The Remainder Operator

### Understanding Modulo

```javascript
// Basic remainder operations
console.log('=== Basic Remainder ===');
console.log(5 % 2); // Output: 1 (5 = 2 * 2 + 1)
console.log(5 / 2); // Output: 2.5

console.log(8 % 3); // Output: 2 (8 = 3 * 2 + 2)
console.log(8 / 3); // Output: 2.6666666666666665

console.log(6 % 2); // Output: 0 (6 = 2 * 3 + 0)
console.log(7 % 2); // Output: 1 (7 = 2 * 3 + 1)

// Even/odd checking
const isEven = n => n % 2 === 0;
const isOdd = n => n % 2 !== 0;

console.log('=== Even/Odd Checking ===');
console.log(isEven(8)); // Output: true
console.log(isEven(23)); // Output: false
console.log(isOdd(23)); // Output: true
console.log(isOdd(514)); // Output: false

// Practical applications
console.log('=== Practical Applications ===');

// 1. Cycle through array indices
const colors = ['red', 'green', 'blue'];
function getColorByIndex(index) {
    return colors[index % colors.length];
}

console.log('Color cycling:');
for (let i = 0; i < 10; i++) {
    console.log(`Index ${i}: ${getColorByIndex(i)}`);
}
// Output: Cycles through red, green, blue repeatedly

// 2. Check divisibility
function isDivisibleBy(number, divisor) {
    return number % divisor === 0;
}

console.log('Divisibility checks:');
console.log(`15 divisible by 3: ${isDivisibleBy(15, 3)}`); // Output: true
console.log(`15 divisible by 4: ${isDivisibleBy(15, 4)}`); // Output: false

// 3. Find multiples
function findMultiples(number, max) {
    const multiples = [];
    for (let i = number; i <= max; i += number) {
        multiples.push(i);
    }
    return multiples;
}

console.log('Multiples of 7 up to 50:', findMultiples(7, 50));
// Output: [7, 14, 21, 28, 35, 42, 49]

// 4. Alternating patterns
function createAlternatingPattern(length) {
    return Array.from({ length }, (_, i) => i % 2 === 0 ? 'A' : 'B');
}

console.log('Alternating pattern:', createAlternatingPattern(8));
// Output: ['A', 'B', 'A', 'B', 'A', 'B', 'A', 'B']

// 5. Group items into batches
function groupIntoBatches(items, batchSize) {
    const batches = [];
    for (let i = 0; i < items.length; i += batchSize) {
        batches.push(items.slice(i, i + batchSize));
    }
    return batches;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log('Grouped into batches of 3:', groupIntoBatches(numbers, 3));
// Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

// 6. Time calculations
function formatSeconds(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

console.log('Time formatting:');
console.log(formatSeconds(3661)); // Output: 01:01:01
console.log(formatSeconds(7325)); // Output: 02:02:05

// DOM example: Alternating row colors (simulated)
function simulateAlternatingRows() {
    const rows = Array.from({ length: 10 }, (_, i) => ({ id: i, content: `Row ${i + 1}` }));
    
    rows.forEach((row, i) => {
        const backgroundColor = i % 2 === 0 ? 'lightgray' : 'white';
        const textColor = i % 3 === 0 ? 'blue' : 'black';
        
        console.log(`Row ${i + 1}: background=${backgroundColor}, color=${textColor}`);
    });
}

console.log('=== Simulated DOM Styling ===');
simulateAlternatingRows();
```

---

## 🔢 Numeric Separators (ES2021)

### Making Large Numbers Readable

```javascript
// Traditional way (hard to read)
const earthDiameter = 12742000; // Is this 12 million or 127 million?
const lightSpeed = 299792458; // Hard to parse visually

// ✅ With numeric separators (ES2021)
console.log('=== Numeric Separators ===');
const earthDiameterReadable = 12_742_000; // 12.742 million meters
const lightSpeedReadable = 299_792_458; // 299,792,458 m/s

console.log(earthDiameterReadable); // Output: 12742000 (separator ignored at runtime)
console.log(lightSpeedReadable); // Output: 299792458

// Different grouping styles
const population = 7_800_000_000; // 7.8 billion
const price = 345_99; // $345.99
const transferFee1 = 15_00; // $15.00
const transferFee2 = 1_500; // $1,500

console.log('Readable numbers:');
console.log(`World population: ${population.toLocaleString()}`);
console.log(`Price: $${(price / 100).toFixed(2)}`);
console.log(`Transfer fee 1: $${(transferFee1 / 100).toFixed(2)}`);
console.log(`Transfer fee 2: $${transferFee2.toLocaleString()}`);

// Binary, octal, and hexadecimal
const binaryNumber = 0b1010_0001; // Binary with separators
const octalNumber = 0o755_644; // Octal with separators
const hexNumber = 0xFF_EC_DE_5E; // Hexadecimal with separators

console.log('Different bases:');
console.log(`Binary 1010_0001 = ${binaryNumber}`); // Output: 161
console.log(`Octal 755_644 = ${octalNumber}`); // Output: 252836
console.log(`Hex FF_EC_DE_5E = ${hexNumber}`); // Output: 4293713502

// Decimal numbers
const pi = 3.141_592_653_589_793;
const avogadro = 6.022_140_76e23; // Scientific notation with separators

console.log('Scientific constants:');
console.log(`π = ${pi}`);
console.log(`Avogadro's number = ${avogadro}`);

// ⚠️ Limitations and rules
console.log('=== Separator Rules ===');

// ✅ Valid uses
const valid1 = 1_000_000;
const valid2 = 1_000.50;
const valid3 = 0xFF_EC;

// ❌ Invalid uses (would cause SyntaxError)
// const invalid1 = _1000; // Can't start with separator
// const invalid2 = 1000_; // Can't end with separator
// const invalid3 = 1__000; // Can't have consecutive separators
// const invalid4 = 1._000; // Can't be adjacent to decimal point
// const invalid5 = 1.000_; // Can't end fractional part with separator

// Conversion limitations
console.log('=== Conversion Limitations ===');
console.log(Number('230_000')); // Output: NaN (separators not recognized in strings)
console.log(parseInt('230_000')); // Output: 230 (stops at separator)

// ✅ Proper way to handle user input with separators
function parseNumberWithSeparators(str) {
    // Remove separators and parse
    const cleaned = str.replace(/_/g, '');
    return Number(cleaned);
}

console.log('Parsing with separators:');
console.log(parseNumberWithSeparators('1_000_000')); // Output: 1000000
console.log(parseNumberWithSeparators('3.14_159')); // Output: 3.14159

// Real-world example: Configuration values
const config = {
    maxFileSize: 50_000_000, // 50 MB
    cacheTimeout: 5_000, // 5 seconds
    maxConnections: 1_000,
    bufferSize: 64_000, // 64 KB
    retryDelay: 2_500 // 2.5 seconds
};

console.log('Configuration values:');
Object.entries(config).forEach(([key, value]) => {
    console.log(`${key}: ${value.toLocaleString()}`);
});

// Financial calculations with readable numbers
function calculateLoan(principal, annualRate, years) {
    const monthlyRate = annualRate / 100 / 12;
    const numberOfPayments = years * 12;
    
    const monthlyPayment = principal * 
        (monthlyRate * Math.pow(1 + monthlyRate, numberOfPayments)) /
        (Math.pow(1 + monthlyRate, numberOfPayments) - 1);
    
    return {
        principal: principal,
        monthlyPayment: monthlyPayment,
        totalPaid: monthlyPayment * numberOfPayments,
        totalInterest: (monthlyPayment * numberOfPayments) - principal
    };
}

const loanDetails = calculateLoan(250_000, 3.5, 30); // $250k at 3.5% for 30 years
console.log('Loan calculation:');
console.log(`Principal: $${loanDetails.principal.toLocaleString()}`);
console.log(`Monthly payment: $${loanDetails.monthlyPayment.toFixed(2)}`);
console.log(`Total paid: $${loanDetails.totalPaid.toLocaleString()}`);
console.log(`Total interest: $${loanDetails.totalInterest.toLocaleString()}`);
```---


## 🔢 Working with BigInt (ES2020)

### Understanding JavaScript Number Limitations

```javascript
// JavaScript's number precision limit
console.log('=== Number Precision Limits ===');
console.log(2 ** 53 - 1); // Output: 9007199254740991
console.log(Number.MAX_SAFE_INTEGER); // Output: 9007199254740991

// Beyond safe integer range - precision is lost
console.log(2 ** 53 + 1); // Output: 9007199254740992
console.log(2 ** 53 + 2); // Output: 9007199254740994 (should be 9007199254740993!)
console.log(2 ** 53 + 3); // Output: 9007199254740996 (should be 9007199254740994!)
console.log(2 ** 53 + 4); // Output: 9007199254740996 (precision lost!)

console.log('Precision loss demonstration:');
console.log(`2^53 + 1 = ${2 ** 53 + 1}`);
console.log(`2^53 + 2 = ${2 ** 53 + 2}`);
console.log('Notice how some numbers are skipped!');
```

### Creating and Using BigInt

```javascript
// Creating BigInt values
console.log('=== Creating BigInt ===');

// Method 1: Append 'n' to integer literal
const bigInt1 = 4838430248342043823408394839483204n;
console.log(bigInt1); // Output: 4838430248342043823408394839483204n
console.log(typeof bigInt1); // Output: bigint

// Method 2: BigInt() constructor
const bigInt2 = BigInt(48384302);
console.log(bigInt2); // Output: 48384302n

const bigInt3 = BigInt('123456789012345678901234567890');
console.log(bigInt3); // Output: 123456789012345678901234567890n

// ⚠️ BigInt constructor limitations
// console.log(BigInt(1.5)); // TypeError: Cannot convert 1.5 to a BigInt
// console.log(BigInt('1.5')); // SyntaxError: Cannot convert 1.5 to a BigInt

// Safe conversion function
function toBigInt(value) {
    try {
        if (typeof value === 'string') {
            // Remove decimal part if present
            const integerPart = value.split('.')[0];
            return BigInt(integerPart);
        }
        if (typeof value === 'number') {
            if (!Number.isInteger(value)) {
                return BigInt(Math.trunc(value));
            }
            return BigInt(value);
        }
        return BigInt(value);
    } catch (error) {
        console.error('Cannot convert to BigInt:', value);
        return null;
    }
}

console.log('Safe BigInt conversion:');
console.log(toBigInt('123.456')); // Output: 123n
console.log(toBigInt(123.456)); // Output: 123n
console.log(toBigInt('invalid')); // Output: null (with error message)
```

### BigInt Operations

```javascript
// Basic arithmetic operations
console.log('=== BigInt Arithmetic ===');
const big1 = 10000n;
const big2 = 20000n;

console.log(big1 + big2); // Output: 30000n
console.log(big1 - big2); // Output: -10000n
console.log(big1 * big2); // Output: 200000000n
console.log(big2 / big1); // Output: 2n (integer division)
console.log(big2 % big1); // Output: 0n

// Large number calculations
const huge1 = 36286372637263726376237263726372632n;
const huge2 = 10000000n;
console.log('Large number multiplication:');
console.log(huge1 * huge2);

// ⚠️ Cannot mix BigInt with regular numbers
const regularNumber = 23;
// console.log(huge1 * regularNumber); // TypeError!

// ✅ Must convert regular numbers to BigInt
console.log(huge1 * BigInt(regularNumber));

// Practical example: Factorial calculation for large numbers
function factorial(n) {
    if (n <= 1) return 1n;
    
    let result = 1n;
    for (let i = 2n; i <= n; i++) {
        result *= i;
    }
    return result;
}

console.log('Large factorials:');
console.log(`20! = ${factorial(20n)}`);
console.log(`50! = ${factorial(50n)}`);
console.log(`100! = ${factorial(100n)}`);

// Fibonacci sequence with BigInt
function fibonacciBig(n) {
    if (n <= 1n) return n;
    
    let a = 0n, b = 1n;
    for (let i = 2n; i <= n; i++) {
        [a, b] = [b, a + b];
    }
    return b;
}

console.log('Large Fibonacci numbers:');
console.log(`fib(100) = ${fibonacciBig(100n)}`);
console.log(`fib(1000) = ${fibonacciBig(1000n)}`);
```

### BigInt Comparisons and Type Coercion

```javascript
// Comparison operations
console.log('=== BigInt Comparisons ===');
console.log(20n > 15); // Output: true (comparison works)
console.log(20n > 15n); // Output: true
console.log(20n === 20); // Output: false (strict equality fails)
console.log(20n == 20); // Output: true (loose equality works)
console.log(20n == '20'); // Output: true

// Type checking
console.log('Type information:');
console.log(typeof 20n); // Output: bigint
console.log(typeof 20); // Output: number

// String conversion
const hugeBigInt = 20289830237283728378237n;
console.log(hugeBigInt + ' is REALLY big!!!');
// Output: 20289830237283728378237 is REALLY big!!!

// JSON serialization issue
const data = {
    regularNumber: 123,
    bigIntNumber: 123n
};

// console.log(JSON.stringify(data)); // TypeError: Do not know how to serialize a BigInt

// ✅ Custom JSON serialization for BigInt
function serializeBigInt(key, value) {
    if (typeof value === 'bigint') {
        return value.toString() + 'n';
    }
    return value;
}

function deserializeBigInt(key, value) {
    if (typeof value === 'string' && value.endsWith('n')) {
        const numStr = value.slice(0, -1);
        if (/^\d+$/.test(numStr)) {
            return BigInt(numStr);
        }
    }
    return value;
}

console.log('BigInt JSON handling:');
const jsonString = JSON.stringify(data, serializeBigInt);
console.log('Serialized:', jsonString);
const parsed = JSON.parse(jsonString, deserializeBigInt);
console.log('Deserialized:', parsed);
```

### BigInt Division and Precision

```javascript
// Division behavior with BigInt
console.log('=== BigInt Division ===');
console.log(11n / 3n); // Output: 3n (truncated to integer)
console.log(10 / 3); // Output: 3.3333333333333335 (decimal result)

console.log(10n / 3n); // Output: 3n
console.log(11n / 3n); // Output: 3n
console.log(12n / 3n); // Output: 4n

// Getting remainder
console.log('Division with remainder:');
console.log(`11 ÷ 3 = ${11n / 3n} remainder ${11n % 3n}`);
console.log(`17 ÷ 5 = ${17n / 5n} remainder ${17n % 5n}`);

// Practical example: Time calculations with nanoseconds
function convertNanosecondsToTime(nanoseconds) {
    const ns = BigInt(nanoseconds);
    
    const secondsInNs = 1_000_000_000n;
    const minutesInNs = secondsInNs * 60n;
    const hoursInNs = minutesInNs * 60n;
    
    const hours = ns / hoursInNs;
    const minutes = (ns % hoursInNs) / minutesInNs;
    const seconds = (ns % minutesInNs) / secondsInNs;
    const remainingNs = ns % secondsInNs;
    
    return {
        hours: Number(hours),
        minutes: Number(minutes),
        seconds: Number(seconds),
        nanoseconds: Number(remainingNs)
    };
}

const largeNanoseconds = 3_661_500_000_000n; // ~1 hour, 1 minute, 1.5 seconds
console.log('Time conversion:', convertNanosecondsToTime(largeNanoseconds));

// Cryptocurrency calculations (wei to ether)
function weiToEther(wei) {
    const weiPerEther = 1_000_000_000_000_000_000n; // 10^18
    const etherAmount = wei / weiPerEther;
    const remainderWei = wei % weiPerEther;
    
    return {
        ether: Number(etherAmount),
        remainderWei: remainderWei,
        exactEther: Number(wei) / Number(weiPerEther) // For decimal precision
    };
}

const weiAmount = 1_500_000_000_000_000_000n; // 1.5 ETH in wei
console.log('Wei to Ether conversion:', weiToEther(weiAmount));

// Performance comparison: BigInt vs Number
function performanceTest() {
    const iterations = 100000;
    
    // Regular number performance
    console.time('Regular number operations');
    let sum1 = 0;
    for (let i = 0; i < iterations; i++) {
        sum1 += i * 2;
    }
    console.timeEnd('Regular number operations');
    
    // BigInt performance
    console.time('BigInt operations');
    let sum2 = 0n;
    for (let i = 0n; i < BigInt(iterations); i++) {
        sum2 += i * 2n;
    }
    console.timeEnd('BigInt operations');
    
    console.log('Regular sum:', sum1);
    console.log('BigInt sum:', sum2);
}

console.log('=== Performance Comparison ===');
performanceTest();
```

---

## 📅 Creating and Working with Dates

### Date Creation Methods

```javascript
// Different ways to create dates
console.log('=== Date Creation Methods ===');

// 1. Current date and time
const now = new Date();
console.log('Current date:', now);

// 2. From string (not recommended for production)
console.log('From strings:');
console.log(new Date('Aug 02 2020 18:05:41'));
console.log(new Date('December 24, 2015'));
console.log(new Date('2023-12-25')); // ISO format (recommended)

// 3. From individual components (month is 0-indexed!)
console.log('From components:');
console.log(new Date(2037, 10, 19, 15, 23, 5)); // Nov 19, 2037 (month 10 = November)
console.log(new Date(2037, 10, 31)); // JavaScript auto-corrects to Dec 1

// 4. From timestamp (milliseconds since Unix epoch)
console.log('From timestamp:');
console.log(new Date(0)); // Unix epoch: Jan 1, 1970
console.log(new Date(3 * 24 * 60 * 60 * 1000)); // 3 days after epoch

// 5. ISO string format (recommended for data exchange)
console.log('ISO format:');
console.log(new Date('2023-12-25T10:30:00.000Z')); // UTC time
console.log(new Date('2023-12-25T10:30:00')); // Local time

// Date validation
function isValidDate(dateString) {
    const date = new Date(dateString);
    return date instanceof Date && !isNaN(date);
}

console.log('Date validation:');
console.log(isValidDate('2023-12-25')); // Output: true
console.log(isValidDate('invalid')); // Output: false
console.log(isValidDate('2023-13-25')); // Output: false (invalid month)

// Safe date creation function
function createSafeDate(year, month, day, hour = 0, minute = 0, second = 0) {
    // Validate inputs
    if (month < 1 || month > 12) {
        throw new Error('Month must be between 1 and 12');
    }
    
    // Convert to 0-indexed month for Date constructor
    return new Date(year, month - 1, day, hour, minute, second);
}

console.log('Safe date creation:');
console.log(createSafeDate(2023, 12, 25, 10, 30)); // Dec 25, 2023
// console.log(createSafeDate(2023, 13, 25)); // Throws error
```

### Date Methods and Properties

```javascript
// Working with date components
const future = new Date(2037, 10, 19, 15, 23, 45, 123);
console.log('=== Date Components ===');
console.log('Full date:', future);

// Get methods
console.log('Year:', future.getFullYear()); // Output: 2037
console.log('Month:', future.getMonth()); // Output: 10 (November, 0-indexed)
console.log('Date:', future.getDate()); // Output: 19
console.log('Day of week:', future.getDay()); // Output: 4 (Thursday, 0=Sunday)
console.log('Hours:', future.getHours()); // Output: 15
console.log('Minutes:', future.getMinutes()); // Output: 23
console.log('Seconds:', future.getSeconds()); // Output: 45
console.log('Milliseconds:', future.getMilliseconds()); // Output: 123

// String representations
console.log('=== String Representations ===');
console.log('ISO string:', future.toISOString());
console.log('Date string:', future.toDateString());
console.log('Time string:', future.toTimeString());
console.log('Locale string:', future.toLocaleString());

// Timestamp
console.log('Timestamp:', future.getTime()); // Milliseconds since epoch
console.log('Current timestamp:', Date.now()); // Static method

// Set methods (mutate the date)
console.log('=== Modifying Dates ===');
const mutableDate = new Date(2023, 0, 1); // Jan 1, 2023
console.log('Original:', mutableDate);

mutableDate.setFullYear(2024);
console.log('After setFullYear(2024):', mutableDate);

mutableDate.setMonth(11); // December (0-indexed)
console.log('After setMonth(11):', mutableDate);

mutableDate.setDate(25);
console.log('After setDate(25):', mutableDate);

mutableDate.setHours(10, 30, 0, 0); // 10:30:00.000
console.log('After setHours(10, 30, 0, 0):', mutableDate);

// UTC methods (for timezone-independent operations)
console.log('=== UTC Methods ===');
const utcDate = new Date();
console.log('Local time:', utcDate.toString());
console.log('UTC time:', utcDate.toUTCString());
console.log('UTC year:', utcDate.getUTCFullYear());
console.log('UTC month:', utcDate.getUTCMonth());
console.log('UTC date:', utcDate.getUTCDate());
console.log('UTC hours:', utcDate.getUTCHours());

// Timezone offset
console.log('Timezone offset (minutes):', utcDate.getTimezoneOffset());
console.log('Timezone offset (hours):', utcDate.getTimezoneOffset() / 60);
```

### Date Calculations and Operations

```javascript
// Date arithmetic
console.log('=== Date Arithmetic ===');

const date1 = new Date(2023, 11, 25); // Dec 25, 2023
const date2 = new Date(2024, 0, 1);   // Jan 1, 2024

// Calculate difference in milliseconds
const diffMs = date2 - date1;
console.log('Difference in milliseconds:', diffMs);

// Convert to different units
const diffSeconds = diffMs / 1000;
const diffMinutes = diffMs / (1000 * 60);
const diffHours = diffMs / (1000 * 60 * 60);
const diffDays = diffMs / (1000 * 60 * 60 * 24);

console.log('Difference in seconds:', diffSeconds);
console.log('Difference in minutes:', diffMinutes);
console.log('Difference in hours:', diffHours);
console.log('Difference in days:', diffDays);

// Utility function for date differences
function dateDifference(date1, date2, unit = 'days') {
    const diff = Math.abs(date2 - date1);
    
    const units = {
        milliseconds: 1,
        seconds: 1000,
        minutes: 1000 * 60,
        hours: 1000 * 60 * 60,
        days: 1000 * 60 * 60 * 24,
        weeks: 1000 * 60 * 60 * 24 * 7,
        months: 1000 * 60 * 60 * 24 * 30.44, // Average month
        years: 1000 * 60 * 60 * 24 * 365.25   // Account for leap years
    };
    
    return diff / units[unit];
}

console.log('=== Date Difference Utility ===');
const birthday = new Date(1990, 5, 15); // June 15, 1990
const today = new Date();

console.log(`Age in years: ${dateDifference(birthday, today, 'years').toFixed(1)}`);
console.log(`Age in days: ${Math.floor(dateDifference(birthday, today, 'days'))}`);
console.log(`Age in hours: ${Math.floor(dateDifference(birthday, today, 'hours'))}`);

// Add/subtract time from dates
function addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

function addMonths(date, months) {
    const result = new Date(date);
    result.setMonth(result.getMonth() + months);
    return result;
}

function addYears(date, years) {
    const result = new Date(date);
    result.setFullYear(result.getFullYear() + years);
    return result;
}

console.log('=== Date Addition ===');
const baseDate = new Date(2023, 0, 15); // Jan 15, 2023
console.log('Base date:', baseDate.toDateString());
console.log('Add 30 days:', addDays(baseDate, 30).toDateString());
console.log('Add 6 months:', addMonths(baseDate, 6).toDateString());
console.log('Add 2 years:', addYears(baseDate, 2).toDateString());

// Business days calculation
function addBusinessDays(date, days) {
    const result = new Date(date);
    let addedDays = 0;
    
    while (addedDays < days) {
        result.setDate(result.getDate() + 1);
        // Skip weekends (0 = Sunday, 6 = Saturday)
        if (result.getDay() !== 0 && result.getDay() !== 6) {
            addedDays++;
        }
    }
    
    return result;
}

console.log('Business days calculation:');
const startDate = new Date(2023, 11, 22); // Friday, Dec 22, 2023
console.log('Start date:', startDate.toDateString());
console.log('Add 5 business days:', addBusinessDays(startDate, 5).toDateString());

// Age calculation with precise handling
function calculateAge(birthDate, referenceDate = new Date()) {
    const birth = new Date(birthDate);
    const reference = new Date(referenceDate);
    
    let years = reference.getFullYear() - birth.getFullYear();
    let months = reference.getMonth() - birth.getMonth();
    let days = reference.getDate() - birth.getDate();
    
    // Adjust for negative days
    if (days < 0) {
        months--;
        const lastMonth = new Date(reference.getFullYear(), reference.getMonth(), 0);
        days += lastMonth.getDate();
    }
    
    // Adjust for negative months
    if (months < 0) {
        years--;
        months += 12;
    }
    
    return { years, months, days };
}

console.log('=== Precise Age Calculation ===');
const birthDate = new Date(1990, 5, 15); // June 15, 1990
const age = calculateAge(birthDate);
console.log(`Age: ${age.years} years, ${age.months} months, ${age.days} days`);

// Relative time formatting
function formatRelativeTime(date, referenceDate = new Date()) {
    const diff = referenceDate - date;
    const absDiff = Math.abs(diff);
    const isPast = diff > 0;
    
    const minute = 60 * 1000;
    const hour = minute * 60;
    const day = hour * 24;
    const week = day * 7;
    const month = day * 30.44;
    const year = day * 365.25;
    
    if (absDiff < minute) {
        return 'just now';
    } else if (absDiff < hour) {
        const minutes = Math.floor(absDiff / minute);
        return `${minutes} minute${minutes !== 1 ? 's' : ''} ${isPast ? 'ago' : 'from now'}`;
    } else if (absDiff < day) {
        const hours = Math.floor(absDiff / hour);
        return `${hours} hour${hours !== 1 ? 's' : ''} ${isPast ? 'ago' : 'from now'}`;
    } else if (absDiff < week) {
        const days = Math.floor(absDiff / day);
        return `${days} day${days !== 1 ? 's' : ''} ${isPast ? 'ago' : 'from now'}`;
    } else if (absDiff < month) {
        const weeks = Math.floor(absDiff / week);
        return `${weeks} week${weeks !== 1 ? 's' : ''} ${isPast ? 'ago' : 'from now'}`;
    } else if (absDiff < year) {
        const months = Math.floor(absDiff / month);
        return `${months} month${months !== 1 ? 's' : ''} ${isPast ? 'ago' : 'from now'}`;
    } else {
        const years = Math.floor(absDiff / year);
        return `${years} year${years !== 1 ? 's' : ''} ${isPast ? 'ago' : 'from now'}`;
    }
}

console.log('=== Relative Time Formatting ===');
const now = new Date();
console.log(formatRelativeTime(new Date(now - 30000))); // 30 seconds ago
console.log(formatRelativeTime(new Date(now - 3600000))); // 1 hour ago
console.log(formatRelativeTime(new Date(now - 86400000))); // 1 day ago
console.log(formatRelativeTime(new Date(now + 86400000))); // 1 day from now
```---


## 🌍 Internationalization (Intl API)

### Number Formatting

```javascript
// Basic number formatting
console.log('=== Basic Number Formatting ===');
const number = 3884764.23;

// Different locales
console.log('US format:', new Intl.NumberFormat('en-US').format(number));
// Output: 3,884,764.23

console.log('German format:', new Intl.NumberFormat('de-DE').format(number));
// Output: 3.884.764,23

console.log('Indian format:', new Intl.NumberFormat('en-IN').format(number));
// Output: 38,84,764.23

console.log('Arabic format:', new Intl.NumberFormat('ar-EG').format(number));
// Output: ٣٬٨٨٤٬٧٦٤٫٢٣

// Currency formatting
console.log('=== Currency Formatting ===');
const price = 1234.56;

const currencyOptions = {
    style: 'currency',
    currency: 'USD'
};

console.log('USD:', new Intl.NumberFormat('en-US', currencyOptions).format(price));
// Output: $1,234.56

console.log('EUR (German):', new Intl.NumberFormat('de-DE', {
    style: 'currency',
    currency: 'EUR'
}).format(price));
// Output: 1.234,56 €

console.log('JPY:', new Intl.NumberFormat('ja-JP', {
    style: 'currency',
    currency: 'JPY'
}).format(price));
// Output: ¥1,235

// Percentage formatting
console.log('=== Percentage Formatting ===');
const percentage = 0.1234;

console.log('US percentage:', new Intl.NumberFormat('en-US', {
    style: 'percent'
}).format(percentage));
// Output: 12%

console.log('German percentage:', new Intl.NumberFormat('de-DE', {
    style: 'percent',
    minimumFractionDigits: 2
}).format(percentage));
// Output: 12,34 %

// Unit formatting
console.log('=== Unit Formatting ===');
const distance = 1234.5;

console.log('Kilometers:', new Intl.NumberFormat('en-US', {
    style: 'unit',
    unit: 'kilometer'
}).format(distance));
// Output: 1,234.5 km

console.log('Miles:', new Intl.NumberFormat('en-US', {
    style: 'unit',
    unit: 'mile',
    unitDisplay: 'long'
}).format(distance));
// Output: 1,234.5 miles

// Advanced formatting options
console.log('=== Advanced Formatting ===');
const largeNumber = 1234567.89;

const advancedOptions = {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
    useGrouping: true
};

console.log('Advanced USD:', new Intl.NumberFormat('en-US', advancedOptions).format(largeNumber));

// Compact notation (ES2020)
console.log('Compact notation:', new Intl.NumberFormat('en-US', {
    notation: 'compact',
    compactDisplay: 'short'
}).format(largeNumber));
// Output: 1.2M

console.log('Compact long:', new Intl.NumberFormat('en-US', {
    notation: 'compact',
    compactDisplay: 'long'
}).format(largeNumber));
// Output: 1.2 million

// Scientific notation
console.log('Scientific:', new Intl.NumberFormat('en-US', {
    notation: 'scientific'
}).format(largeNumber));
// Output: 1.235E6

// Engineering notation
console.log('Engineering:', new Intl.NumberFormat('en-US', {
    notation: 'engineering'
}).format(largeNumber));
// Output: 1.235E6
```

### Date and Time Formatting

```javascript
// Basic date formatting
console.log('=== Date Formatting ===');
const date = new Date(2023, 11, 25, 14, 30, 0); // Dec 25, 2023, 2:30 PM

// Different locales
console.log('US format:', new Intl.DateTimeFormat('en-US').format(date));
// Output: 12/25/2023

console.log('UK format:', new Intl.DateTimeFormat('en-GB').format(date));
// Output: 25/12/2023

console.log('German format:', new Intl.DateTimeFormat('de-DE').format(date));
// Output: 25.12.2023

console.log('Japanese format:', new Intl.DateTimeFormat('ja-JP').format(date));
// Output: 2023/12/25

// Custom formatting options
console.log('=== Custom Date Formatting ===');
const dateOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    weekday: 'long'
};

console.log('Full date:', new Intl.DateTimeFormat('en-US', dateOptions).format(date));
// Output: Monday, December 25, 2023

console.log('German full:', new Intl.DateTimeFormat('de-DE', dateOptions).format(date));
// Output: Montag, 25. Dezember 2023

// Time formatting
console.log('=== Time Formatting ===');
const timeOptions = {
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric',
    hour12: true
};

console.log('US time:', new Intl.DateTimeFormat('en-US', timeOptions).format(date));
// Output: 2:30:00 PM

console.log('24-hour time:', new Intl.DateTimeFormat('en-US', {
    ...timeOptions,
    hour12: false
}).format(date));
// Output: 14:30:00

// Combined date and time
console.log('=== Combined Formatting ===');
const fullOptions = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    timeZoneName: 'short'
};

console.log('Full datetime:', new Intl.DateTimeFormat('en-US', fullOptions).format(date));

// Relative time formatting (ES2020)
console.log('=== Relative Time Formatting ===');
const rtf = new Intl.RelativeTimeFormat('en-US', { numeric: 'auto' });

console.log(rtf.format(-1, 'day')); // Output: yesterday
console.log(rtf.format(1, 'day')); // Output: tomorrow
console.log(rtf.format(-2, 'week')); // Output: 2 weeks ago
console.log(rtf.format(3, 'month')); // Output: in 3 months

// Different locales for relative time
const rtfGerman = new Intl.RelativeTimeFormat('de-DE', { numeric: 'auto' });
console.log('German relative:', rtfGerman.format(-1, 'day')); // Output: gestern

// Utility function for smart relative time
function formatSmartRelativeTime(date, locale = 'en-US') {
    const now = new Date();
    const diff = date - now;
    const absDiff = Math.abs(diff);
    
    const minute = 60 * 1000;
    const hour = minute * 60;
    const day = hour * 24;
    const week = day * 7;
    const month = day * 30;
    const year = day * 365;
    
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    
    if (absDiff < minute) {
        return rtf.format(0, 'second');
    } else if (absDiff < hour) {
        return rtf.format(Math.round(diff / minute), 'minute');
    } else if (absDiff < day) {
        return rtf.format(Math.round(diff / hour), 'hour');
    } else if (absDiff < week) {
        return rtf.format(Math.round(diff / day), 'day');
    } else if (absDiff < month) {
        return rtf.format(Math.round(diff / week), 'week');
    } else if (absDiff < year) {
        return rtf.format(Math.round(diff / month), 'month');
    } else {
        return rtf.format(Math.round(diff / year), 'year');
    }
}

console.log('Smart relative time:');
const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
const nextWeek = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
console.log(formatSmartRelativeTime(yesterday));
console.log(formatSmartRelativeTime(nextWeek));
```

### Locale Detection and Formatting

```javascript
// Automatic locale detection
console.log('=== Locale Detection ===');
console.log('Browser language:', navigator.language);
console.log('Browser languages:', navigator.languages);

// Use browser locale for formatting
const browserLocale = navigator.language;
const autoNumber = 1234567.89;

console.log('Auto-formatted number:', 
    new Intl.NumberFormat(browserLocale, {
        style: 'currency',
        currency: 'USD'
    }).format(autoNumber)
);

// Locale-aware sorting
console.log('=== Locale-Aware Sorting ===');
const names = ['Müller', 'Möller', 'Moller', 'Miller'];

// Default sort (may not handle accents correctly)
console.log('Default sort:', [...names].sort());

// Locale-aware sort
const collator = new Intl.Collator('de-DE');
console.log('German sort:', [...names].sort(collator.compare));

// Case-insensitive sorting
const caseInsensitiveCollator = new Intl.Collator('en-US', {
    sensitivity: 'base'
});

const mixedCase = ['apple', 'Banana', 'cherry', 'Date'];
console.log('Case-insensitive sort:', 
    [...mixedCase].sort(caseInsensitiveCollator.compare)
);

// Practical formatting utilities
class LocaleFormatter {
    constructor(locale = navigator.language) {
        this.locale = locale;
    }
    
    currency(amount, currencyCode = 'USD') {
        return new Intl.NumberFormat(this.locale, {
            style: 'currency',
            currency: currencyCode
        }).format(amount);
    }
    
    percentage(value, decimals = 0) {
        return new Intl.NumberFormat(this.locale, {
            style: 'percent',
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals
        }).format(value);
    }
    
    date(date, options = {}) {
        const defaultOptions = {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        };
        
        return new Intl.DateTimeFormat(this.locale, {
            ...defaultOptions,
            ...options
        }).format(date);
    }
    
    relativeTime(date) {
        return formatSmartRelativeTime(date, this.locale);
    }
    
    number(value, options = {}) {
        return new Intl.NumberFormat(this.locale, options).format(value);
    }
}

console.log('=== Formatter Utility ===');
const formatter = new LocaleFormatter('en-US');

console.log('Currency:', formatter.currency(1234.56));
console.log('Percentage:', formatter.percentage(0.1234, 2));
console.log('Date:', formatter.date(new Date()));
console.log('Number:', formatter.number(1234567.89));

// Multi-locale support
const locales = ['en-US', 'de-DE', 'ja-JP', 'ar-SA'];
const testAmount = 1234.56;

console.log('=== Multi-locale Formatting ===');
locales.forEach(locale => {
    const formatter = new LocaleFormatter(locale);
    console.log(`${locale}: ${formatter.currency(testAmount, 'USD')}`);
});
```

---

## ⏰ Timers and Asynchronous Operations

### setTimeout and clearTimeout

```javascript
// Basic setTimeout
console.log('=== setTimeout Basics ===');

console.log('Before timeout');

const timeoutId = setTimeout(() => {
    console.log('This runs after 2 seconds');
}, 2000);

console.log('After timeout setup');

// setTimeout with parameters
const greetUser = (name, greeting) => {
    console.log(`${greeting}, ${name}!`);
};

setTimeout(greetUser, 1000, 'Alice', 'Hello');

// Conditional timeout clearing
const ingredients = ['olives', 'spinach'];
const pizzaTimer = setTimeout(
    (ing1, ing2) => console.log(`Here is your pizza with ${ing1} and ${ing2} 🍕`),
    3000,
    ...ingredients
);

console.log('Pizza order placed...');

// Cancel if spinach is included
if (ingredients.includes('spinach')) {
    clearTimeout(pizzaTimer);
    console.log('Pizza order cancelled - no spinach please!');
}

// Practical example: Debounced function
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Simulated search function
const search = (query) => {
    console.log(`Searching for: ${query}`);
};

const debouncedSearch = debounce(search, 300);

// Simulate rapid typing
console.log('=== Debounced Search Demo ===');
debouncedSearch('j');
debouncedSearch('ja');
debouncedSearch('jav');
debouncedSearch('java');
debouncedSearch('javascript');
// Only the last call will execute after 300ms

// Delayed execution with promise
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Usage with async/await
async function delayedExecution() {
    console.log('Starting delayed execution...');
    await delay(1000);
    console.log('1 second passed');
    await delay(1000);
    console.log('2 seconds passed');
    await delay(1000);
    console.log('3 seconds passed - done!');
}

// delayedExecution(); // Uncomment to run
```

### setInterval and clearInterval

```javascript
// Basic setInterval
console.log('=== setInterval Basics ===');

let counter = 0;
const intervalId = setInterval(() => {
    counter++;
    console.log(`Interval tick: ${counter}`);
    
    // Stop after 5 ticks
    if (counter >= 5) {
        clearInterval(intervalId);
        console.log('Interval stopped');
    }
}, 1000);

// Clock example
function createClock() {
    const clockInterval = setInterval(() => {
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        console.log(`Current time: ${timeString}`);
    }, 1000);
    
    // Return function to stop the clock
    return () => {
        clearInterval(clockInterval);
        console.log('Clock stopped');
    };
}

// const stopClock = createClock(); // Uncomment to run
// setTimeout(stopClock, 5000); // Stop after 5 seconds

// Progress indicator
function showProgress(duration, steps = 10) {
    let currentStep = 0;
    const stepDuration = duration / steps;
    
    console.log('Progress: [' + ' '.repeat(steps) + '] 0%');
    
    const progressInterval = setInterval(() => {
        currentStep++;
        const percentage = Math.round((currentStep / steps) * 100);
        const filled = '█'.repeat(currentStep);
        const empty = ' '.repeat(steps - currentStep);
        
        console.log(`Progress: [${filled}${empty}] ${percentage}%`);
        
        if (currentStep >= steps) {
            clearInterval(progressInterval);
            console.log('Progress complete! ✅');
        }
    }, stepDuration);
}

// showProgress(5000); // 5-second progress bar

// Polling example
function createPoller(checkFunction, interval = 1000, maxAttempts = 10) {
    let attempts = 0;
    
    return new Promise((resolve, reject) => {
        const pollInterval = setInterval(() => {
            attempts++;
            console.log(`Polling attempt ${attempts}...`);
            
            if (checkFunction()) {
                clearInterval(pollInterval);
                resolve(`Success after ${attempts} attempts`);
            } else if (attempts >= maxAttempts) {
                clearInterval(pollInterval);
                reject(new Error(`Failed after ${maxAttempts} attempts`));
            }
        }, interval);
    });
}

// Example: Wait for a condition to be true
let conditionMet = false;
setTimeout(() => { conditionMet = true; }, 3500); // Condition met after 3.5 seconds

const poller = createPoller(() => conditionMet, 500, 10);
// poller.then(console.log).catch(console.error); // Uncomment to run
```

### Advanced Timer Patterns

```javascript
// Timeout with cleanup
class TimeoutManager {
    constructor() {
        this.timeouts = new Map();
    }
    
    set(id, callback, delay, ...args) {
        // Clear existing timeout with same id
        this.clear(id);
        
        const timeoutId = setTimeout(() => {
            callback(...args);
            this.timeouts.delete(id);
        }, delay);
        
        this.timeouts.set(id, timeoutId);
    }
    
    clear(id) {
        const timeoutId = this.timeouts.get(id);
        if (timeoutId) {
            clearTimeout(timeoutId);
            this.timeouts.delete(id);
        }
    }
    
    clearAll() {
        this.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
        this.timeouts.clear();
    }
    
    has(id) {
        return this.timeouts.has(id);
    }
    
    size() {
        return this.timeouts.size;
    }
}

console.log('=== Timeout Manager ===');
const timeoutManager = new TimeoutManager();

timeoutManager.set('greeting', () => console.log('Hello!'), 1000);
timeoutManager.set('farewell', () => console.log('Goodbye!'), 2000);

console.log(`Active timeouts: ${timeoutManager.size()}`);

// Cancel greeting
timeoutManager.clear('greeting');
console.log(`Active timeouts after clearing: ${timeoutManager.size()}`);

// Retry mechanism with exponential backoff
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            if (attempt === maxRetries) {
                throw error;
            }
            
            const delay = baseDelay * Math.pow(2, attempt - 1);
            console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Example usage
async function unreliableFunction() {
    if (Math.random() < 0.7) {
        throw new Error('Random failure');
    }
    return 'Success!';
}

// retryWithBackoff(unreliableFunction, 3, 500)
//     .then(result => console.log('Final result:', result))
//     .catch(error => console.log('Final error:', error.message));

// Animation frame timing (for smooth animations)
function createAnimationTimer(callback, duration) {
    const startTime = performance.now();
    
    function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        callback(progress);
        
        if (progress < 1) {
            requestAnimationFrame(animate);
        }
    }
    
    requestAnimationFrame(animate);
}

// Example: Animated counter
function animateCounter(element, from, to, duration) {
    createAnimationTimer((progress) => {
        const current = from + (to - from) * progress;
        console.log(`Counter: ${Math.round(current)}`);
        // In real DOM: element.textContent = Math.round(current);
    }, duration);
}

// animateCounter(null, 0, 100, 2000); // Animate from 0 to 100 over 2 seconds

// High-precision timing
class PrecisionTimer {
    constructor() {
        this.startTime = null;
        this.running = false;
    }
    
    start() {
        this.startTime = performance.now();
        this.running = true;
    }
    
    stop() {
        this.running = false;
        return this.getElapsed();
    }
    
    getElapsed() {
        if (!this.startTime) return 0;
        return performance.now() - this.startTime;
    }
    
    reset() {
        this.startTime = null;
        this.running = false;
    }
}

console.log('=== Precision Timer ===');
const timer = new PrecisionTimer();
timer.start();

setTimeout(() => {
    console.log(`Elapsed time: ${timer.getElapsed().toFixed(2)}ms`);
    timer.stop();
}, 1000);
```

---

## 🎯 Key Takeaways & Best Practices

### Number Handling Best Practices

```javascript
// ✅ Best practices for numbers

// 1. Use Number.isFinite() for validation
function validateNumber(input) {
    return Number.isFinite(input) && !Number.isNaN(input);
}

// 2. Handle floating point precision
function safeEquals(a, b, tolerance = Number.EPSILON) {
    return Math.abs(a - b) < tolerance;
}

// 3. Use appropriate rounding methods
function roundCurrency(amount) {
    return Math.round(amount * 100) / 100; // Avoid floating point issues
}

// 4. Use BigInt for large integers
function factorial(n) {
    if (n <= 1) return 1n;
    return BigInt(n) * factorial(n - 1);
}

// 5. Format numbers for display
function formatCurrency(amount, locale = 'en-US', currency = 'USD') {
    return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency: currency
    }).format(amount);
}
```

### Date Handling Best Practices

```javascript
// ✅ Best practices for dates

// 1. Always use ISO strings for data exchange
function serializeDate(date) {
    return date.toISOString();
}

// 2. Create dates safely
function createSafeDate(year, month, day) {
    const date = new Date(year, month - 1, day); // month is 0-indexed
    
    // Validate the date
    if (date.getFullYear() !== year || 
        date.getMonth() !== month - 1 || 
        date.getDate() !== day) {
        throw new Error('Invalid date');
    }
    
    return date;
}

// 3. Use UTC for server communication
function getUTCDate(date) {
    return new Date(Date.UTC(
        date.getFullYear(),
        date.getMonth(),
        date.getDate()
    ));
}

// 4. Handle timezones properly
function formatDateForTimezone(date, timezone, locale = 'en-US') {
    return new Intl.DateTimeFormat(locale, {
        timeZone: timezone,
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric'
    }).format(date);
}
```

### Timer Best Practices

```javascript
// ✅ Best practices for timers

// 1. Always clean up timers
class ComponentWithTimer {
    constructor() {
        this.timers = [];
    }
    
    addTimer(callback, delay) {
        const id = setTimeout(callback, delay);
        this.timers.push(id);
        return id;
    }
    
    destroy() {
        this.timers.forEach(clearTimeout);
        this.timers = [];
    }
}

// 2. Use debouncing for user input
function createDebouncer(delay = 300) {
    let timeoutId;
    
    return function(callback) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(callback, delay);
    };
}

// 3. Prefer requestAnimationFrame for animations
function smoothAnimation(callback, duration) {
    const start = performance.now();
    
    function frame(time) {
        const progress = Math.min((time - start) / duration, 1);
        callback(progress);
        
        if (progress < 1) {
            requestAnimationFrame(frame);
        }
    }
    
    requestAnimationFrame(frame);
}
```

---

## 🏆 Mastery Checklist

```
🎯 Numbers, Dates & Internationalization Mastery:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Master number conversion and validation techniques       │
│ ✅ Handle floating point precision and BigInt operations   │
│ ✅ Create, manipulate, and format dates effectively        │
│ ✅ Use Intl API for proper internationalization            │
│ ✅ Implement timers and asynchronous patterns              │
│ ✅ Apply best practices for number and date handling       │
│ ✅ Build locale-aware applications                         │
│ ✅ Handle edge cases and error conditions properly         │
└─────────────────────────────────────────────────────────────┘
```

**Remember:** Working with numbers, dates, and internationalization requires careful attention to precision, locale differences, and edge cases. The Intl API is your friend for creating truly global applications, while proper timer management ensures smooth user experiences.

**Next Steps:**
1. Practice building locale-aware applications
2. Implement proper date handling in real projects
3. Learn about timezone management libraries
4. Explore advanced Intl API features
5. Study performance implications of different approaches

The mastery of these concepts is essential for building professional, international-ready JavaScript applications!