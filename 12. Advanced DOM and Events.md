# 🎭 12. Advanced DOM and Events

> **Ultimate Advanced DOM Masterclass** - Master event handling, DOM manipulation, performance optimization, and modern web APIs

---

## 🎯 Learning Objectives

By the end of this masterclass, you will understand:

```
🚀 Advanced DOM & Events Arsenal:
┌─────────────────────────────────────────────────────────────┐
│ • Event Lifecycle & Propagation Mechanics                  │
│ • Event Delegation & Performance Optimization              │
│ • DOM Traversal & Manipulation Techniques                  │
│ • Intersection Observer & Modern APIs                      │
│ • Lifecycle Events & Page Performance                      │
│ • Custom Events & Event-Driven Architecture               │
│ • Real-World Interactive Applications                      │
└─────────────────────────────────────────────────────────────┘
```

### 📚 Prerequisites
- Basic JavaScript knowledge (variables, functions, objects)
- Understanding of HTML and CSS
- Familiarity with basic DOM methods (querySelector, addEventListener)
- Basic understanding of asynchronous JavaScript (Promises, async/await)

---

## 🏗️ Understanding the DOM Architecture

### What is the DOM?

The **Document Object Model (DOM)** is a programming interface that represents HTML documents as a tree structure of objects. It's the bridge between JavaScript and web pages.

```
🌳 DOM Tree Structure:
┌─────────────────────────────────────────────────────────────┐
│                    Document                                 │
│                       │                                     │
│                   HTML Element                              │
│                   ┌───┴───┐                                │
│               HEAD        BODY                              │
│                │            │                              │
│            META, TITLE   DIV, P, etc.                      │
│                              │                              │
│                         Text Nodes                         │
└─────────────────────────────────────────────────────────────┘
```

### DOM Inheritance Hierarchy

Every DOM element inherits from a chain of prototypes, giving them different capabilities:

```javascript
/**
 * DOM INHERITANCE CHAIN DEMONSTRATION
 * 
 * This example shows how DOM elements inherit properties and methods
 * from their parent classes in the inheritance hierarchy.
 */

// Create elements to demonstrate inheritance
const div = document.createElement('div');
const text = document.createTextNode('Hello World');
const comment = document.createComment('This is a comment');

console.log('=== DOM Node Types and Inheritance ===');

// Every DOM node has a nodeType property that identifies its type
console.log('Element Node Type:', div.nodeType);     // 1 - ELEMENT_NODE
console.log('Text Node Type:', text.nodeType);       // 3 - TEXT_NODE  
console.log('Comment Node Type:', comment.nodeType); // 8 - COMMENT_NODE

/**
 * INHERITANCE CHAIN EXPLANATION:
 * 
 * EventTarget (base class)
 *    ↓
 * Node (adds tree structure methods)
 *    ↓  
 * Element (adds attributes, classes, etc.)
 *    ↓
 * HTMLElement (adds HTML-specific properties)
 *    ↓
 * Specific elements (HTMLDivElement, HTMLButtonElement, etc.)
 */

// Check inheritance chain
console.log('\n🧬 Inheritance Chain Verification:');
console.log('div instanceof HTMLDivElement:', div instanceof HTMLDivElement);     // true
console.log('div instanceof HTMLElement:', div instanceof HTMLElement);           // true
console.log('div instanceof Element:', div instanceof Element);                   // true
console.log('div instanceof Node:', div instanceof Node);                         // true
console.log('div instanceof EventTarget:', div instanceof EventTarget);           // true

/**
 * PRACTICAL IMPLICATIONS:
 * 
 * - EventTarget: Provides addEventListener, removeEventListener, dispatchEvent
 * - Node: Provides parentNode, childNodes, appendChild, etc.
 * - Element: Provides className, id, getAttribute, querySelector, etc.
 * - HTMLElement: Provides style, hidden, click(), focus(), etc.
 */

// Demonstrate available methods at each level
console.log('\n📋 Available Methods by Inheritance Level:');

// EventTarget methods (event handling)
console.log('EventTarget methods:', [
    'addEventListener', 'removeEventListener', 'dispatchEvent'
]);

// Node methods (tree manipulation)  
console.log('Node methods:', [
    'appendChild', 'removeChild', 'insertBefore', 'cloneNode'
]);

// Element methods (attributes and queries)
console.log('Element methods:', [
    'getAttribute', 'setAttribute', 'querySelector', 'classList'
]);

// HTMLElement methods (HTML-specific)
console.log('HTMLElement methods:', [
    'click', 'focus', 'blur', 'style property'
]);
```

### DOM Collections vs NodeLists

Understanding the difference between live and static collections is crucial for performance:

```javascript
/**
 * DOM COLLECTIONS VS NODELISTS
 * 
 * This demonstrates the important difference between live collections
 * (HTMLCollection) and static collections (NodeList).
 */

console.log('=== Collections vs NodeLists Demo ===');

// HTMLCollection - LIVE (updates automatically when DOM changes)
const liveCollection = document.getElementsByTagName('div');

// NodeList - STATIC (snapshot at time of query)
const staticNodeList = document.querySelectorAll('div');

console.log('Initial counts:');
console.log('Live collection length:', liveCollection.length);
console.log('Static NodeList length:', staticNodeList.length);

// Add a new div to see the difference
const newDiv = document.createElement('div');
newDiv.textContent = 'New div added dynamically';
document.body.appendChild(newDiv);

console.log('\nAfter adding new div:');
console.log('Live collection length:', liveCollection.length);    // Increased by 1
console.log('Static NodeList length:', staticNodeList.length);   // Unchanged

/**
 * PERFORMANCE IMPLICATIONS:
 * 
 * Live Collections (getElementsByTagName, getElementsByClassName):
 * ✅ Always up-to-date with DOM changes
 * ❌ Slower for repeated access (re-queries DOM each time)
 * ❌ Can cause infinite loops if modified during iteration
 * 
 * Static NodeLists (querySelectorAll):
 * ✅ Faster for repeated access (cached result)
 * ✅ Safe to modify DOM during iteration
 * ❌ May become outdated if DOM changes
 */

// Best practice: Convert to array for safe iteration
const safeArray = Array.from(liveCollection);
console.log('Converted to array length:', safeArray.length);

// Demonstrate safe iteration
console.log('\n🔄 Safe iteration patterns:');

// ❌ Dangerous - live collection can change during iteration
// for (let i = 0; i < liveCollection.length; i++) {
//     if (someCondition) {
//         liveCollection[i].remove(); // This changes the collection!
//     }
// }

// ✅ Safe - iterate over static array
safeArray.forEach((element, index) => {
    console.log(`Element ${index}:`, element.tagName);
    // Safe to modify DOM here
});
```

---

## 🎪 Event Propagation: The Complete Guide

### Understanding Event Flow

Events in the DOM follow a specific path through the document tree. Understanding this flow is essential for effective event handling.

```
🌊 Event Propagation Phases:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ 1. CAPTURING PHASE (top-down)                              │
│    Document → HTML → Body → ... → Target Element           │
│                                                             │
│ 2. TARGET PHASE                                             │
│    Event reaches the target element                         │
│                                                             │
│ 3. BUBBLING PHASE (bottom-up)                              │
│    Target Element → ... → Body → HTML → Document           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Interactive Event Propagation Demo

```javascript
/**
 * EVENT PROPAGATION COMPREHENSIVE DEMO
 * 
 * This example demonstrates all three phases of event propagation
 * with detailed logging and interactive controls.
 */

console.log('=== Event Propagation Masterclass ===');

// Create nested HTML structure for demonstration
const propagationDemo = document.createElement('div');
propagationDemo.className = 'propagation-demo';
propagationDemo.innerHTML = `
    <h3>🎪 Event Propagation Interactive Demo</h3>
    
    <!-- Nested structure to show propagation -->
    <div class="container" style="padding: 20px; border: 3px solid blue; margin: 10px; cursor: pointer;">
        <strong>Container (Blue Border)</strong>
        <div class="section" style="padding: 15px; border: 3px solid green; margin: 10px; cursor: pointer;">
            <strong>Section (Green Border)</strong>
            <button class="target-btn" style="padding: 10px; border: 3px solid red; margin: 10px; cursor: pointer;">
                🎯 Target Button (Red Border) - Click Me!
            </button>
        </div>
    </div>
    
    <!-- Event log to show propagation in real-time -->
    <div class="event-log" style="
        background: #f5f5f5; 
        padding: 10px; 
        margin: 10px 0; 
        height: 200px; 
        overflow-y: auto; 
        font-family: monospace; 
        font-size: 12px;
        border: 1px solid #ccc;
    "></div>
    
    <!-- Controls to modify propagation behavior -->
    <div class="controls" style="margin: 10px 0; padding: 10px; background: #e8f4f8;">
        <button class="clear-log">🧹 Clear Log</button>
        <button class="toggle-propagation">🛑 Toggle stopPropagation</button>
        <button class="toggle-immediate">⚡ Toggle stopImmediatePropagation</button>
        <button class="toggle-prevent">🚫 Toggle preventDefault</button>
    </div>
`;
propagationDemo.style.cssText = 'border: 2px solid #333; padding: 20px; margin: 10px;';

// Get references to elements
const container = propagationDemo.querySelector('.container');
const section = propagationDemo.querySelector('.section');
const targetBtn = propagationDemo.querySelector('.target-btn');
const eventLog = propagationDemo.querySelector('.event-log');

// Control flags
let stopPropagation = false;
let stopImmediatePropagation = false;
let preventDefault = false;

/**
 * UTILITY FUNCTION: Log events with detailed information
 * 
 * @param {string} message - The message to log
 * @param {string} phase - The event phase (CAPTURING, TARGET, BUBBLING)
 * @param {string} element - The element name
 */
function logEvent(message, phase, element) {
    const timestamp = new Date().toLocaleTimeString();
    
    // Color-code different phases for visual clarity
    const phaseColors = {
        'CAPTURING': '#ff6b6b',   // Red for capturing
        'TARGET': '#4ecdc4',      // Teal for target
        'BUBBLING': '#45b7d1',    // Blue for bubbling
        'SYSTEM': '#ffc107'       // Yellow for system messages
    };
    
    const logEntry = document.createElement('div');
    logEntry.style.cssText = `
        color: ${phaseColors[phase] || 'black'};
        margin: 2px 0;
        padding: 2px 5px;
        border-left: 3px solid ${phaseColors[phase] || 'black'};
    `;
    logEntry.textContent = `[${timestamp}] ${phase}: ${message} (${element})`;
    
    eventLog.appendChild(logEntry);
    eventLog.scrollTop = eventLog.scrollHeight; // Auto-scroll to bottom
}

/**
 * CAPTURING PHASE LISTENERS
 * 
 * These listeners fire during the capturing phase (top-down).
 * Set useCapture parameter to true to listen during capturing.
 */

// Container capturing listener
container.addEventListener('click', function(e) {
    logEvent('Container clicked', 'CAPTURING', e.currentTarget.className);
    
    console.log('🔽 CAPTURING Phase - Container');
    console.log('  Event phase:', e.eventPhase); // 1 = capturing
    console.log('  Current target:', e.currentTarget.className);
    console.log('  Actual target:', e.target.className);
}, true); // true = listen during capturing phase

// Section capturing listener  
section.addEventListener('click', function(e) {
    logEvent('Section clicked', 'CAPTURING', e.currentTarget.className);
    
    console.log('🔽 CAPTURING Phase - Section');
    console.log('  Event phase:', e.eventPhase);
}, true);

// Button capturing listener
targetBtn.addEventListener('click', function(e) {
    logEvent('Button clicked', 'CAPTURING', e.currentTarget.className);
    
    console.log('🔽 CAPTURING Phase - Button');
    console.log('  Event phase:', e.eventPhase);
}, true);

/**
 * TARGET PHASE LISTENERS
 * 
 * These listeners fire when the event reaches the target element.
 * Multiple listeners on the same element fire in the order they were added.
 */

// First target listener
targetBtn.addEventListener('click', function(e) {
    logEvent('Button clicked (first listener)', 'TARGET', e.currentTarget.className);
    
    console.log('🎯 TARGET Phase - Button (first listener)');
    console.log('  Event phase:', e.eventPhase); // 2 = target
    
    // stopImmediatePropagation prevents other listeners on the same element
    if (stopImmediatePropagation) {
        e.stopImmediatePropagation();
        logEvent('stopImmediatePropagation() called - no more listeners on this element', 'SYSTEM', 'system');
        return;
    }
});

// Second target listener (won't fire if stopImmediatePropagation was called)
targetBtn.addEventListener('click', function(e) {
    logEvent('Button clicked (second listener)', 'TARGET', e.currentTarget.className);
    
    console.log('🎯 TARGET Phase - Button (second listener)');
    console.log('  Event phase:', e.eventPhase);
    
    // stopPropagation prevents bubbling to parent elements
    if (stopPropagation) {
        e.stopPropagation();
        logEvent('stopPropagation() called - no bubbling to parents', 'SYSTEM', 'system');
    }
    
    // preventDefault prevents default browser behavior
    if (preventDefault) {
        e.preventDefault();
        logEvent('preventDefault() called - default behavior prevented', 'SYSTEM', 'system');
    }
});

/**
 * BUBBLING PHASE LISTENERS
 * 
 * These listeners fire during the bubbling phase (bottom-up).
 * This is the default behavior when useCapture is false or omitted.
 */

// Button bubbling listener
targetBtn.addEventListener('click', function(e) {
    logEvent('Button clicked', 'BUBBLING', e.currentTarget.className);
    
    console.log('🔼 BUBBLING Phase - Button');
    console.log('  Event phase:', e.eventPhase); // 3 = bubbling
});

// Section bubbling listener
section.addEventListener('click', function(e) {
    logEvent('Section clicked', 'BUBBLING', e.currentTarget.className);
    
    console.log('🔼 BUBBLING Phase - Section');
    console.log('  Event phase:', e.eventPhase);
    console.log('  Target vs CurrentTarget:');
    console.log('    - target (where click occurred):', e.target.className);
    console.log('    - currentTarget (element with listener):', e.currentTarget.className);
});

// Container bubbling listener
container.addEventListener('click', function(e) {
    logEvent('Container clicked', 'BUBBLING', e.currentTarget.className);
    
    console.log('🔼 BUBBLING Phase - Container');
    console.log('  Event phase:', e.eventPhase);
});

/**
 * CONTROL BUTTON HANDLERS
 * 
 * These buttons allow you to experiment with different propagation behaviors.
 */

// Clear log button
propagationDemo.querySelector('.clear-log').addEventListener('click', () => {
    eventLog.innerHTML = '';
    console.clear();
    logEvent('Event log cleared', 'SYSTEM', 'system');
});

// Toggle stopPropagation
propagationDemo.querySelector('.toggle-propagation').addEventListener('click', (e) => {
    stopPropagation = !stopPropagation;
    e.target.textContent = `🛑 stopPropagation: ${stopPropagation ? 'ON' : 'OFF'}`;
    e.target.style.backgroundColor = stopPropagation ? '#ffebee' : '#e8f5e8';
    
    logEvent(`stopPropagation toggled: ${stopPropagation ? 'ON' : 'OFF'}`, 'SYSTEM', 'system');
});

// Toggle stopImmediatePropagation  
propagationDemo.querySelector('.toggle-immediate').addEventListener('click', (e) => {
    stopImmediatePropagation = !stopImmediatePropagation;
    e.target.textContent = `⚡ stopImmediatePropagation: ${stopImmediatePropagation ? 'ON' : 'OFF'}`;
    e.target.style.backgroundColor = stopImmediatePropagation ? '#ffebee' : '#e8f5e8';
    
    logEvent(`stopImmediatePropagation toggled: ${stopImmediatePropagation ? 'ON' : 'OFF'}`, 'SYSTEM', 'system');
});

// Toggle preventDefault
propagationDemo.querySelector('.toggle-prevent').addEventListener('click', (e) => {
    preventDefault = !preventDefault;
    e.target.textContent = `🚫 preventDefault: ${preventDefault ? 'ON' : 'OFF'}`;
    e.target.style.backgroundColor = preventDefault ? '#ffebee' : '#e8f5e8';
    
    logEvent(`preventDefault toggled: ${preventDefault ? 'ON' : 'OFF'}`, 'SYSTEM', 'system');
});

// Add the demo to the page
document.body.appendChild(propagationDemo);

/**
 * EXPECTED OUTPUT WHEN BUTTON IS CLICKED:
 * 
 * With all toggles OFF:
 * 1. 🔽 CAPTURING: Container clicked
 * 2. 🔽 CAPTURING: Section clicked  
 * 3. 🔽 CAPTURING: Button clicked
 * 4. 🎯 TARGET: Button clicked (first listener)
 * 5. 🎯 TARGET: Button clicked (second listener)
 * 6. 🔼 BUBBLING: Button clicked
 * 7. 🔼 BUBBLING: Section clicked
 * 8. 🔼 BUBBLING: Container clicked
 */

console.log('✅ Event Propagation Demo initialized');
console.log('💡 Click the red button to see event propagation in action!');
console.log('🎛️ Use the control buttons to experiment with different behaviors');
```

### Event Object Deep Dive

```javascript
/**
 * EVENT OBJECT COMPREHENSIVE EXPLORATION
 * 
 * The event object contains valuable information about the event.
 * This demo explores all the important properties and methods.
 */

const eventObjectDemo = document.createElement('div');
eventObjectDemo.innerHTML = `
    <h3>🔍 Event Object Properties Explorer</h3>
    
    <div class="interaction-area" style="
        padding: 30px; 
        border: 2px dashed #999; 
        margin: 10px; 
        cursor: pointer;
        background: linear-gradient(45deg, #f0f8ff, #e6f3ff);
        text-align: center;
        font-size: 16px;
    ">
        🖱️ Click, right-click, or use keyboard here to explore event properties
        <br><small>Try different mouse buttons, modifier keys, and keyboard input</small>
    </div>
    
    <div class="event-details" style="
        background: #f9f9f9; 
        padding: 15px; 
        margin: 10px; 
        font-family: monospace; 
        font-size: 12px; 
        max-height: 400px; 
        overflow-y: auto;
        border: 1px solid #ddd;
        white-space: pre-wrap;
    "></div>
`;
eventObjectDemo.style.cssText = 'border: 2px solid #666; padding: 20px; margin: 10px;';

const interactionArea = eventObjectDemo.querySelector('.interaction-area');
const eventDetails = eventObjectDemo.querySelector('.event-details');

/**
 * COMPREHENSIVE EVENT HANDLER
 * 
 * This function extracts and displays all relevant event properties
 * in an organized, easy-to-understand format.
 */
function analyzeEvent(e) {
    // Prevent default behavior for demonstration
    if (e.type === 'contextmenu') {
        e.preventDefault(); // Prevent right-click menu
    }
    
    /**
     * BASIC EVENT INFORMATION
     * These properties are available on all events
     */
    const basicInfo = {
        type: e.type,                           // Event type (click, keydown, etc.)
        timeStamp: e.timeStamp.toFixed(2),     // Time when event was created
        eventPhase: e.eventPhase,              // 1=capturing, 2=target, 3=bubbling
        bubbles: e.bubbles,                    // Can this event bubble?
        cancelable: e.cancelable,              // Can preventDefault() cancel this?
        defaultPrevented: e.defaultPrevented,  // Was preventDefault() called?
        isTrusted: e.isTrusted                 // Was this event triggered by user action?
    };
    
    /**
     * TARGET INFORMATION
     * Understanding the difference between target and currentTarget is crucial
     */
    const targetInfo = {
        target: e.target.tagName || e.target.nodeType,           // Element that triggered the event
        currentTarget: e.currentTarget.tagName || 'Unknown',     // Element with the event listener
        targetIsCurrentTarget: e.target === e.currentTarget      // Are they the same?
    };
    
    /**
     * MOUSE EVENT PROPERTIES
     * Only available for mouse events (click, mousedown, mousemove, etc.)
     */
    const mouseInfo = {};
    if (e.clientX !== undefined) {
        mouseInfo.clientX = e.clientX;         // X coordinate relative to viewport
        mouseInfo.clientY = e.clientY;         // Y coordinate relative to viewport
        mouseInfo.screenX = e.screenX;         // X coordinate relative to screen
        mouseInfo.screenY = e.screenY;         // Y coordinate relative to screen
        mouseInfo.offsetX = e.offsetX;         // X coordinate relative to target element
        mouseInfo.offsetY = e.offsetY;         // Y coordinate relative to target element
        mouseInfo.pageX = e.pageX;             // X coordinate relative to document
        mouseInfo.pageY = e.pageY;             // Y coordinate relative to document
        mouseInfo.button = e.button;           // Which button was pressed (0=left, 1=middle, 2=right)
        mouseInfo.buttons = e.buttons;         // Bitmask of currently pressed buttons
        mouseInfo.detail = e.detail;           // Click count for click events
        
        // Modifier keys
        mouseInfo.ctrlKey = e.ctrlKey;         // Was Ctrl key pressed?
        mouseInfo.shiftKey = e.shiftKey;       // Was Shift key pressed?
        mouseInfo.altKey = e.altKey;           // Was Alt key pressed?
        mouseInfo.metaKey = e.metaKey;         // Was Meta key (Cmd/Win) pressed?
    }
    
    /**
     * KEYBOARD EVENT PROPERTIES  
     * Only available for keyboard events (keydown, keyup, keypress)
     */
    const keyboardInfo = {};
    if (e.key !== undefined) {
        keyboardInfo.key = e.key;              // The actual key pressed ('a', 'Enter', 'ArrowUp')
        keyboardInfo.code = e.code;            // Physical key code ('KeyA', 'Enter', 'ArrowUp')
        keyboardInfo.keyCode = e.keyCode;      // Legacy key code (deprecated but still used)
        keyboardInfo.which = e.which;         // Legacy property (deprecated)
        keyboardInfo.repeat = e.repeat;        // Is this a repeated keypress?
        keyboardInfo.location = e.location;    // Key location (0=standard, 1=left, 2=right, 3=numpad)
        
        // Modifier keys (same as mouse events)
        keyboardInfo.ctrlKey = e.ctrlKey;
        keyboardInfo.shiftKey = e.shiftKey;
        keyboardInfo.altKey = e.altKey;
        keyboardInfo.metaKey = e.metaKey;
    }
    
    /**
     * DISPLAY THE ANALYSIS
     * Format and display all the collected information
     */
    let output = `🔍 EVENT ANALYSIS - ${e.type.toUpperCase()}\n`;
    output += `${'='.repeat(50)}\n\n`;
    
    // Basic Information
    output += `📋 BASIC INFORMATION:\n`;
    Object.entries(basicInfo).forEach(([key, value]) => {
        output += `  ${key.padEnd(20)}: ${value}\n`;
    });
    
    // Target Information
    output += `\n🎯 TARGET INFORMATION:\n`;
    Object.entries(targetInfo).forEach(([key, value]) => {
        output += `  ${key.padEnd(20)}: ${value}\n`;
    });
    
    // Mouse Information (if applicable)
    if (Object.keys(mouseInfo).length > 0) {
        output += `\n🖱️ MOUSE INFORMATION:\n`;
        Object.entries(mouseInfo).forEach(([key, value]) => {
            output += `  ${key.padEnd(20)}: ${value}\n`;
        });
        
        // Add helpful explanations for mouse coordinates
        output += `\n  📍 COORDINATE EXPLANATION:\n`;
        output += `    clientX/Y: Position relative to browser viewport\n`;
        output += `    screenX/Y: Position relative to entire screen\n`;
        output += `    offsetX/Y: Position relative to target element\n`;
        output += `    pageX/Y:   Position relative to entire document\n`;
        
        // Button explanation
        output += `\n  🔘 BUTTON EXPLANATION:\n`;
        output += `    button 0: Left mouse button\n`;
        output += `    button 1: Middle mouse button (wheel)\n`;
        output += `    button 2: Right mouse button\n`;
    }
    
    // Keyboard Information (if applicable)
    if (Object.keys(keyboardInfo).length > 0) {
        output += `\n⌨️ KEYBOARD INFORMATION:\n`;
        Object.entries(keyboardInfo).forEach(([key, value]) => {
            output += `  ${key.padEnd(20)}: ${value}\n`;
        });
        
        // Add helpful explanations for keyboard properties
        output += `\n  📝 KEY PROPERTY EXPLANATION:\n`;
        output += `    key:  The actual character or key name\n`;
        output += `    code: The physical key identifier\n`;
        output += `    keyCode: Legacy numeric code (avoid in new code)\n`;
    }
    
    // Add timestamp for reference
    output += `\n⏰ Analyzed at: ${new Date().toLocaleTimeString()}\n`;
    
    eventDetails.textContent = output;
    
    // Log to console for developers
    console.log(`🔍 Event Analysis: ${e.type}`, {
        basicInfo,
        targetInfo,
        mouseInfo,
        keyboardInfo
    });
}

/**
 * EVENT LISTENERS FOR COMPREHENSIVE TESTING
 * 
 * We'll listen for various event types to demonstrate different
 * event object properties.
 */

// Mouse events
['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseenter', 'mouseleave', 'contextmenu']
    .forEach(eventType => {
        interactionArea.addEventListener(eventType, analyzeEvent);
    });

// Keyboard events (make the area focusable first)
interactionArea.tabIndex = 0; // Makes the div focusable
['keydown', 'keyup', 'keypress'].forEach(eventType => {
    interactionArea.addEventListener(eventType, analyzeEvent);
});

// Focus events
['focus', 'blur'].forEach(eventType => {
    interactionArea.addEventListener(eventType, analyzeEvent);
});

// Add the demo to the page
document.body.appendChild(eventObjectDemo);

console.log('✅ Event Object Explorer initialized');
console.log('💡 Interact with the demo area to see detailed event information!');
```

---

## 🎯 Event Delegation: Performance and Flexibility

Event delegation is a powerful pattern that leverages event bubbling to handle events efficiently. Instead of attaching listeners to individual elements, we attach a single listener to a parent element.

### Why Event Delegation?

```
🎯 Event Delegation Benefits:
┌─────────────────────────────────────────────────────────────┐
│ ✅ Better Performance - One listener instead of many       │
│ ✅ Dynamic Content - Works with elements added later       │
│ ✅ Memory Efficient - Fewer event listeners               │
│ ✅ Cleaner Code - Centralized event handling              │
│ ✅ Automatic Cleanup - No need to remove individual       │
│    listeners when elements are removed                     │
└─────────────────────────────────────────────────────────────┘
```

### Professional Event Delegation System

```javascript
/**
 * ADVANCED EVENT DELEGATION SYSTEM
 * 
 * This class provides a professional-grade event delegation system
 * with features like selector matching, event statistics, and error handling.
 */

class EventDelegator {
    constructor(container) {
        this.container = container;           // The container element to delegate from
        this.handlers = new Map();            // Map to store event handlers by type:selector
        this.stats = {                        // Statistics for monitoring performance
            totalEvents: 0,                   // Total events captured
            handledEvents: 0,                 // Events that matched a handler
            delegatedEvents: 0                // Total handler executions
        };
        
        this.setupDelegation();
        console.log('🎯 EventDelegator initialized for:', container.className || container.tagName);
    }
    
    /**
     * REGISTER EVENT HANDLER
     * 
     * @param {string} eventType - The event type (click, change, etc.)
     * @param {string} selector - CSS selector to match target elements
     * @param {Function} handler - The event handler function
     * @param {Object} options - Additional options
     * @returns {EventDelegator} - Returns this for method chaining
     */
    on(eventType, selector, handler, options = {}) {
        const key = `${eventType}:${selector}`;
        
        // Initialize handler array if it doesn't exist
        if (!this.handlers.has(key)) {
            this.handlers.set(key, []);
        }
        
        // Store handler with metadata
        const handlerInfo = {
            handler,
            options,
            id: Math.random().toString(36).substr(2, 9), // Unique ID for removal
            addedAt: Date.now()
        };
        
        this.handlers.get(key).push(handlerInfo);
        
        console.log(`📝 Registered handler for "${eventType}" on "${selector}"`);
        return this; // Enable method chaining
    }
    
    /**
     * REMOVE EVENT HANDLER
     * 
     * @param {string} eventType - The event type
     * @param {string} selector - CSS selector
     * @param {string} handlerId - The handler ID (returned by on())
     * @returns {EventDelegator} - Returns this for method chaining
     */
    off(eventType, selector, handlerId) {
        const key = `${eventType}:${selector}`;
        const handlers = this.handlers.get(key);
        
        if (handlers) {
            const index = handlers.findIndex(h => h.id === handlerId);
            if (index > -1) {
                handlers.splice(index, 1);
                console.log(`🗑️ Removed handler ${handlerId} for "${eventType}" on "${selector}"`);
                
                // Clean up empty handler arrays
                if (handlers.length === 0) {
                    this.handlers.delete(key);
                }
            }
        }
        
        return this;
    }
    
    /**
     * SETUP DELEGATION SYSTEM
     * 
     * Sets up event listeners for common event types using the capturing phase
     * for better control over event handling.
     */
    setupDelegation() {
        // Common event types that benefit from delegation
        const eventTypes = [
            // Mouse events
            'click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout',
            // Form events  
            'change', 'input', 'submit', 'focus', 'blur',
            // Keyboard events
            'keydown', 'keyup', 'keypress',
            // Touch events (for mobile)
            'touchstart', 'touchend', 'touchmove'
        ];
        
        eventTypes.forEach(eventType => {
            this.container.addEventListener(eventType, (e) => {
                this.stats.totalEvents++;
                this.handleEvent(e);
            }, true); // Use capturing phase for better control
        });
        
        console.log(`🔧 Delegation setup complete for ${eventTypes.length} event types`);
    }
    
    /**
     * HANDLE DELEGATED EVENT
     * 
     * This is the core method that processes events and matches them
     * against registered handlers.
     * 
     * @param {Event} e - The event object
     */
    handleEvent(e) {
        let handled = false;
        
        // Find all matching handlers for this event type
        this.handlers.forEach((handlerList, key) => {
            const [eventType, selector] = key.split(':');
            
            // Skip if event type doesn't match
            if (e.type !== eventType) return;
            
            /**
             * SELECTOR MATCHING ALGORITHM
             * 
             * We need to check if the event target or any of its ancestors
             * match the selector. This allows for flexible event handling.
             */
            let element = e.target;
            
            // Walk up the DOM tree to find matching elements
            while (element && element !== this.container) {
                // Check if current element matches the selector
                if (element.matches && element.matches(selector)) {
                    
                    // Execute all handlers for this selector
                    handlerList.forEach(({ handler, options }) => {
                        try {
                            // Create enhanced event object with delegation info
                            const enhancedEvent = this.enhanceEvent(e, element);
                            
                            // Call handler with the matching element as 'this'
                            handler.call(element, enhancedEvent);
                            
                            handled = true;
                            this.stats.delegatedEvents++;
                            
                            console.log(`✅ Handler executed for "${selector}" on ${element.tagName}`);
                            
                        } catch (error) {
                            console.error(`❌ Handler error for "${selector}":`, error);
                        }
                    });
                    
                    // Stop at first match unless specified otherwise
                    break;
                }
                
                element = element.parentElement;
            }
        });
        
        if (handled) {
            this.stats.handledEvents++;
        }
    }
    
    /**
     * ENHANCE EVENT OBJECT
     * 
     * Adds delegation-specific properties to the event object
     * for better debugging and functionality.
     * 
     * @param {Event} originalEvent - The original event
     * @param {Element} matchedElement - The element that matched the selector
     * @returns {Object} - Enhanced event object
     */
    enhanceEvent(originalEvent, matchedElement) {
        return {
            // Preserve all original event properties
            ...originalEvent,
            
            // Add delegation-specific properties
            delegatedTarget: matchedElement,        // Element that matched the selector
            originalTarget: originalEvent.target,   // Original event target
            delegationContainer: this.container,    // The delegation container
            
            // Add convenience methods
            stopDelegation: () => {
                originalEvent.stopPropagation();
            },
            
            preventDefault: () => {
                originalEvent.preventDefault();
            },
            
            // Add debugging info
            delegationInfo: {
                matchedSelector: true,
                handlerCount: this.handlers.size,
                eventPath: this.getEventPath(originalEvent.target)
            }
        };
    }
    
    /**
     * GET EVENT PATH
     * 
     * Returns the path from the target to the delegation container
     * for debugging purposes.
     * 
     * @param {Element} target - The event target
     * @returns {Array} - Array of element tag names in the path
     */
    getEventPath(target) {
        const path = [];
        let element = target;
        
        while (element && element !== this.container) {
            path.push(element.tagName.toLowerCase());
            element = element.parentElement;
        }
        
        return path;
    }
    
    /**
     * GET STATISTICS
     * 
     * Returns performance and usage statistics for monitoring.
     * 
     * @returns {Object} - Statistics object
     */
    getStats() {
        return {
            ...this.stats,
            handlersRegistered: this.handlers.size,
            efficiency: this.stats.totalEvents > 0 
                ? ((this.stats.handledEvents / this.stats.totalEvents) * 100).toFixed(1) + '%'
                : '0%'
        };
    }
    
    /**
     * DESTROY DELEGATOR
     * 
     * Cleans up all event listeners and handlers.
     */
    destroy() {
        this.handlers.clear();
        // Note: We can't easily remove the event listeners we added in setupDelegation()
        // without keeping references to them. In a production system, you'd want to
        // store these references for proper cleanup.
        console.log('🧹 EventDelegator destroyed');
    }
}

/**
 * COMPREHENSIVE DELEGATION DEMO
 * 
 * This demo shows event delegation in action with a dynamic todo application.
 */

// Create the demo application HTML
const delegationApp = document.createElement('div');
delegationApp.className = 'delegation-app';
delegationApp.innerHTML = `
    <h3>🎯 Advanced Event Delegation Demo</h3>
    <p>This todo app uses a single event listener to handle all interactions!</p>
    
    <!-- Toolbar with various controls -->
    <div class="toolbar" style="padding: 15px; background: #f8f9fa; margin: 10px 0; border-radius: 8px;">
        <button class="btn-add" data-action="add">➕ Add Item</button>
        <button class="btn-clear" data-action="clear">🗑️ Clear All</button>
        <button class="btn-stats" data-action="stats">📊 Show Stats</button>
        <input type="text" class="item-input" placeholder="Enter new item..." style="
            margin-left: 10px; 
            padding: 8px; 
            border: 1px solid #ddd; 
            border-radius: 4px;
            width: 200px;
        ">
    </div>
    
    <!-- Main content area with two columns -->
    <div class="content-area" style="display: flex; gap: 20px; margin: 20px 0;">
        
        <!-- Todo items column -->
        <div class="todo-section" style="flex: 1;">
            <h4 style="margin: 0 0 10px 0; color: #495057;">📝 Todo Items</h4>
            <ul class="todo-list" style="
                list-style: none; 
                padding: 0; 
                min-height: 200px; 
                border: 2px dashed #dee2e6; 
                padding: 15px;
                border-radius: 8px;
                background: #ffffff;
            "></ul>
        </div>
        
        <!-- Completed items column -->
        <div class="completed-section" style="flex: 1;">
            <h4 style="margin: 0 0 10px 0; color: #495057;">✅ Completed Items</h4>
            <ul class="completed-list" style="
                list-style: none; 
                padding: 0; 
                min-height: 200px; 
                border: 2px dashed #dee2e6; 
                padding: 15px;
                border-radius: 8px;
                background: #f8f9fa;
            "></ul>
        </div>
    </div>
    
    <!-- Statistics display -->
    <div class="stats-display" style="
        background: #e3f2fd; 
        padding: 15px; 
        margin: 10px 0; 
        font-family: monospace; 
        border-radius: 8px;
        border: 1px solid #bbdefb;
        display: none;
    "></div>
`;
delegationApp.style.cssText = 'border: 2px solid #007bff; padding: 20px; margin: 10px; border-radius: 10px;';

// Get references to key elements
const todoList = delegationApp.querySelector('.todo-list');
const completedList = delegationApp.querySelector('.completed-list');
const itemInput = delegationApp.querySelector('.item-input');
const statsDisplay = delegationApp.querySelector('.stats-display');

// Initialize the event delegator
const delegator = new EventDelegator(delegationApp);

// Application state
let itemCounter = 0;
let items = [];

/**
 * REGISTER EVENT HANDLERS USING DELEGATION
 * 
 * Notice how we register handlers for elements that don't exist yet!
 * This is the power of event delegation.
 */

delegator
    // Toolbar button handlers
    .on('click', '.btn-add', function(e) {
        const itemName = itemInput.value.trim() || `Sample Item ${++itemCounter}`;
        addTodoItem(itemName);
        itemInput.value = '';
        console.log('➕ Added item via delegation:', itemName);
    })
    
    .on('click', '.btn-clear', function(e) {
        items = [];
        renderItems();
        console.log('🗑️ Cleared all items via delegation');
    })
    
    .on('click', '.btn-stats', function(e) {
        showStats();
    })
    
    // Input field handlers
    .on('keydown', '.item-input', function(e) {
        if (e.key === 'Enter') {
            const itemName = this.value.trim();
            if (itemName) {
                addTodoItem(itemName);
                this.value = '';
            }
        }
    })
    
    // Dynamic item handlers (these elements don't exist yet!)
    .on('click', '.item-toggle', function(e) {
        const itemId = parseInt(this.dataset.id);
        toggleItem(itemId);
        console.log('✅ Toggled item via delegation:', itemId);
    })
    
    .on('click', '.item-delete', function(e) {
        const itemId = parseInt(this.dataset.id);
        deleteItem(itemId);
        console.log('🗑️ Deleted item via delegation:', itemId);
    })
    
    .on('click', '.item-edit', function(e) {
        const itemId = parseInt(this.dataset.id);
        editItem(itemId);
        console.log('✏️ Edit item via delegation:', itemId);
    })
    
    // Double-click to edit
    .on('dblclick', '.item-text', function(e) {
        const itemId = parseInt(this.closest('.todo-item').dataset.id);
        editItem(itemId);
    })
    
    // Hover effects
    .on('mouseover', '.todo-item', function(e) {
        this.style.backgroundColor = '#f0f8ff';
        this.style.transform = 'translateX(5px)';
        this.style.transition = 'all 0.2s ease';
    })
    
    .on('mouseout', '.todo-item', function(e) {
        this.style.backgroundColor = '';
        this.style.transform = '';
    });

/**
 * APPLICATION LOGIC FUNCTIONS
 * 
 * These functions manage the application state and rendering.
 */

function addTodoItem(name) {
    const item = {
        id: Date.now(),                    // Unique ID based on timestamp
        name: name,
        completed: false,
        createdAt: new Date(),
        completedAt: null
    };
    
    items.push(item);
    renderItems();
    
    console.log('📝 Item added to state:', item);
}

function toggleItem(id) {
    const item = items.find(item => item.id === id);
    if (item) {
        item.completed = !item.completed;
        item.completedAt = item.completed ? new Date() : null;
        renderItems();
        
        console.log(`${item.completed ? '✅' : '📝'} Item toggled:`, item.name);
    }
}

function deleteItem(id) {
    const itemIndex = items.findIndex(item => item.id === id);
    if (itemIndex > -1) {
        const deletedItem = items.splice(itemIndex, 1)[0];
        renderItems();
        
        console.log('🗑️ Item deleted:', deletedItem.name);
    }
}

function editItem(id) {
    const item = items.find(item => item.id === id);
    if (item) {
        const newName = prompt('Edit item name:', item.name);
        if (newName && newName.trim()) {
            item.name = newName.trim();
            renderItems();
            
            console.log('✏️ Item edited:', item.name);
        }
    }
}

/**
 * RENDER ITEMS
 * 
 * Updates the DOM to reflect the current application state.
 * Notice how we don't need to add event listeners to new elements!
 */
function renderItems() {
    const todoItems = items.filter(item => !item.completed);
    const completedItems = items.filter(item => item.completed);
    
    // Render todo items
    todoList.innerHTML = todoItems.length > 0 
        ? todoItems.map(item => createItemHTML(item)).join('')
        : '<li style="color: #6c757d; font-style: italic; text-align: center; padding: 20px;">No todo items yet. Add one above!</li>';
    
    // Render completed items
    completedList.innerHTML = completedItems.length > 0
        ? completedItems.map(item => createItemHTML(item)).join('')
        : '<li style="color: #6c757d; font-style: italic; text-align: center; padding: 20px;">No completed items yet.</li>';
    
    console.log(`🔄 Rendered ${todoItems.length} todo and ${completedItems.length} completed items`);
}

/**
 * CREATE ITEM HTML
 * 
 * Generates HTML for a single todo item with all necessary data attributes
 * and CSS classes for event delegation to work.
 */
function createItemHTML(item) {
    return `
        <li class="todo-item" data-id="${item.id}" style="
            padding: 12px;
            margin: 8px 0;
            border: 1px solid ${item.completed ? '#28a745' : '#dee2e6'};
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: ${item.completed ? '#f8fff8' : '#ffffff'};
            ${item.completed ? 'opacity: 0.8;' : ''}
            cursor: pointer;
            transition: all 0.2s ease;
        ">
            <div class="item-content" style="flex: 1;">
                <span class="item-text" style="
                    ${item.completed ? 'text-decoration: line-through; color: #6c757d;' : 'color: #495057;'}
                    font-weight: 500;
                    cursor: pointer;
                ">${item.name}</span>
                <div class="item-meta" style="font-size: 11px; color: #6c757d; margin-top: 4px;">
                    Created: ${item.createdAt.toLocaleTimeString()}
                    ${item.completedAt ? ` • Completed: ${item.completedAt.toLocaleTimeString()}` : ''}
                </div>
            </div>
            
            <div class="item-actions" style="display: flex; gap: 5px;">
                <button class="item-toggle" data-id="${item.id}" style="
                    padding: 4px 8px;
                    border: none;
                    border-radius: 4px;
                    background: ${item.completed ? '#ffc107' : '#28a745'};
                    color: white;
                    cursor: pointer;
                    font-size: 12px;
                " title="${item.completed ? 'Mark as todo' : 'Mark as completed'}">
                    ${item.completed ? '↶' : '✓'}
                </button>
                
                <button class="item-edit" data-id="${item.id}" style="
                    padding: 4px 8px;
                    border: none;
                    border-radius: 4px;
                    background: #007bff;
                    color: white;
                    cursor: pointer;
                    font-size: 12px;
                " title="Edit item">
                    ✏️
                </button>
                
                <button class="item-delete" data-id="${item.id}" style="
                    padding: 4px 8px;
                    border: none;
                    border-radius: 4px;
                    background: #dc3545;
                    color: white;
                    cursor: pointer;
                    font-size: 12px;
                " title="Delete item">
                    ✕
                </button>
            </div>
        </li>
    `;
}

/**
 * SHOW STATISTICS
 * 
 * Displays delegation statistics and application metrics.
 */
function showStats() {
    const delegationStats = delegator.getStats();
    const isVisible = statsDisplay.style.display !== 'none';
    
    if (isVisible) {
        statsDisplay.style.display = 'none';
    } else {
        statsDisplay.innerHTML = `
            <strong>📊 Event Delegation Statistics:</strong><br><br>
            
            <strong>Delegation Performance:</strong><br>
            • Total Events Captured: ${delegationStats.totalEvents}<br>
            • Events Handled by Delegation: ${delegationStats.handledEvents}<br>
            • Handler Executions: ${delegationStats.delegatedEvents}<br>
            • Handlers Registered: ${delegationStats.handlersRegistered}<br>
            • Delegation Efficiency: ${delegationStats.efficiency}<br><br>
            
            <strong>Application State:</strong><br>
            • Total Items: ${items.length}<br>
            • Active Items: ${items.filter(i => !i.completed).length}<br>
            • Completed Items: ${items.filter(i => i.completed).length}<br>
            • Memory Usage: ~${(JSON.stringify(items).length / 1024).toFixed(2)} KB<br><br>
            
            <strong>Performance Benefits:</strong><br>
            • Using 1 delegated listener instead of ${items.length * 3 + 3} individual listeners<br>
            • Memory savings: ~${((items.length * 3 + 3) * 0.1).toFixed(1)} KB<br>
            • Dynamic elements work automatically without re-binding listeners
        `;
        statsDisplay.style.display = 'block';
    }
}

// Add the demo to the page
document.body.appendChild(delegationApp);

// Initialize with some sample data
addTodoItem('Learn Event Delegation');
addTodoItem('Build Interactive Applications');
addTodoItem('Master DOM Performance');

console.log('✅ Event Delegation Demo initialized');
console.log('💡 Try adding, editing, and completing items to see delegation in action!');
console.log('📊 Click "Show Stats" to see performance metrics');
```### 
Performance Comparison: Individual vs Delegated Listeners

```javascript
/**
 * PERFORMANCE COMPARISON DEMONSTRATION
 * 
 * This function demonstrates the performance difference between
 * individual event listeners and event delegation.
 */

function performanceComparison() {
    console.log('🏃‍♂️ Performance Comparison: Individual vs Delegated Listeners');
    
    const comparisonContainer = document.createElement('div');
    comparisonContainer.innerHTML = `
        <h4>⚡ Performance Comparison Demo</h4>
        <p>This demo compares the performance of individual listeners vs event delegation.</p>
        
        <div class="comparison-controls" style="margin: 15px 0;">
            <button class="run-comparison">🚀 Run Performance Test</button>
            <input type="number" class="item-count" value="1000" min="100" max="10000" 
                   style="margin-left: 10px; padding: 5px; width: 80px;">
            <label style="margin-left: 5px;">items to test</label>
        </div>
        
        <div class="results" style="
            margin: 15px 0; 
            padding: 15px; 
            background: #f8f9fa; 
            font-family: monospace; 
            font-size: 12px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        "></div>
    `;
    comparisonContainer.style.cssText = 'border: 2px solid #28a745; padding: 20px; margin: 10px; border-radius: 8px;';
    
    const runBtn = comparisonContainer.querySelector('.run-comparison');
    const itemCountInput = comparisonContainer.querySelector('.item-count');
    const results = comparisonContainer.querySelector('.results');
    
    runBtn.addEventListener('click', () => {
        const itemCount = parseInt(itemCountInput.value);
        
        results.innerHTML = 'Running performance test...<br>';
        
        // Test 1: Individual listeners (slower approach)
        const container1 = document.createElement('div');
        const start1 = performance.now();
        
        for (let i = 0; i < itemCount; i++) {
            const button = document.createElement('button');
            button.textContent = `Individual Button ${i}`;
            button.style.cssText = 'margin: 1px; padding: 2px 5px; font-size: 10px;';
            
            // ❌ Individual listener for each button
            button.addEventListener('click', () => {
                // Simulate some work
                button.style.backgroundColor = '#ffebee';
                setTimeout(() => button.style.backgroundColor = '', 100);
            });
            
            container1.appendChild(button);
        }
        
        const end1 = performance.now();
        const individualTime = end1 - start1;
        
        // Test 2: Event delegation (faster approach)
        const container2 = document.createElement('div');
        const start2 = performance.now();
        
        // ✅ Single delegated listener
        container2.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                // Simulate some work
                e.target.style.backgroundColor = '#e8f5e8';
                setTimeout(() => e.target.style.backgroundColor = '', 100);
            }
        });
        
        for (let i = 0; i < itemCount; i++) {
            const button = document.createElement('button');
            button.textContent = `Delegated Button ${i}`;
            button.style.cssText = 'margin: 1px; padding: 2px 5px; font-size: 10px;';
            container2.appendChild(button);
        }
        
        const end2 = performance.now();
        const delegatedTime = end2 - start2;
        
        // Calculate improvements
        const timeSaved = individualTime - delegatedTime;
        const percentImprovement = ((timeSaved / individualTime) * 100).toFixed(1);
        const memoryEstimate = itemCount * 0.1; // Rough estimate in KB
        
        // Display results
        results.innerHTML = `
            <strong>📊 Performance Test Results (${itemCount.toLocaleString()} buttons):</strong><br><br>
            
            <strong>Setup Time:</strong><br>
            • Individual Listeners: ${individualTime.toFixed(2)}ms<br>
            • Event Delegation: ${delegatedTime.toFixed(2)}ms<br>
            • Time Saved: ${timeSaved.toFixed(2)}ms (${percentImprovement}% faster)<br><br>
            
            <strong>Memory Usage Estimate:</strong><br>
            • Individual Listeners: ~${memoryEstimate.toFixed(1)} KB<br>
            • Event Delegation: ~0.1 KB<br>
            • Memory Saved: ~${(memoryEstimate - 0.1).toFixed(1)} KB<br><br>
            
            <strong>Scalability:</strong><br>
            • Individual approach scales O(n) - gets slower with more elements<br>
            • Delegation approach scales O(1) - constant performance<br><br>
            
            <strong>Maintenance:</strong><br>
            • Individual: Need to add/remove listeners for dynamic content<br>
            • Delegation: Automatically handles dynamic content<br>
        `;
        
        // Add containers to show the actual buttons (limited for performance)
        if (itemCount <= 100) {
            results.innerHTML += `<br><strong>Test Containers (click buttons to test):</strong><br>`;
            
            const testArea = document.createElement('div');
            testArea.style.cssText = 'display: flex; gap: 10px; margin-top: 10px;';
            
            const label1 = document.createElement('div');
            label1.innerHTML = '<small>Individual Listeners:</small>';
            label1.appendChild(container1);
            label1.style.cssText = 'flex: 1; max-height: 100px; overflow-y: auto; border: 1px solid #ccc; padding: 5px;';
            
            const label2 = document.createElement('div');
            label2.innerHTML = '<small>Event Delegation:</small>';
            label2.appendChild(container2);
            label2.style.cssText = 'flex: 1; max-height: 100px; overflow-y: auto; border: 1px solid #ccc; padding: 5px;';
            
            testArea.appendChild(label1);
            testArea.appendChild(label2);
            comparisonContainer.appendChild(testArea);
        }
        
        console.log(`Performance test completed: Individual ${individualTime.toFixed(2)}ms vs Delegation ${delegatedTime.toFixed(2)}ms`);
    });
    
    document.body.appendChild(comparisonContainer);
}

// Run the performance comparison
performanceComparison();
```

---

## 🌐 DOM Traversal and Manipulation Mastery

DOM traversal is the process of navigating through the DOM tree to find, access, and manipulate elements. Modern JavaScript provides powerful methods for efficient DOM navigation.

### Understanding DOM Relationships

```
🌳 DOM Family Tree Relationships:
┌─────────────────────────────────────────────────────────────┐
│                    parentElement                            │
│                         │                                   │
│    previousSibling ←── ELEMENT ──→ nextSibling             │
│                         │                                   │
│                   childElements                             │
│                                                             │
│ Navigation Methods:                                         │
│ • parentElement, parentNode                                 │
│ • children, childNodes                                      │
│ • firstElementChild, lastElementChild                       │
│ • nextElementSibling, previousElementSibling                │
│ • closest() - finds nearest ancestor matching selector      │
│ • querySelector() - finds descendant matching selector      │
└─────────────────────────────────────────────────────────────┘
```

### Advanced DOM Traversal Techniques

```javascript
/**
 * ADVANCED DOM TRAVERSAL DEMONSTRATION
 * 
 * This comprehensive example shows modern DOM traversal techniques
 * with practical use cases and performance considerations.
 */

console.log('=== DOM Traversal Masterclass ===');

// Create a complex DOM structure for traversal demonstration
const traversalLab = document.createElement('div');
traversalLab.className = 'traversal-lab';
traversalLab.innerHTML = `
    <h3>🧭 DOM Traversal Laboratory</h3>
    
    <!-- Complex nested structure for traversal practice -->
    <header class="app-header" data-section="header">
        <h1 class="main-title">Advanced DOM Navigation</h1>
        <nav class="main-nav">
            <ul class="nav-list">
                <li class="nav-item active"><a href="#home" class="nav-link">Home</a></li>
                <li class="nav-item"><a href="#about" class="nav-link">About</a></li>
                <li class="nav-item"><a href="#services" class="nav-link">Services</a></li>
                <li class="nav-item"><a href="#contact" class="nav-link">Contact</a></li>
            </ul>
        </nav>
    </header>
    
    <main class="app-main" data-section="main">
        <article class="post featured" data-id="1" data-category="javascript">
            <h2 class="post-title">Advanced JavaScript Techniques</h2>
            <div class="post-meta">
                <span class="author" data-author-id="123">John Doe</span>
                <time class="date" datetime="2024-01-15">January 15, 2024</time>
                <div class="tags">
                    <span class="tag primary">JavaScript</span>
                    <span class="tag secondary">DOM</span>
                    <span class="tag secondary">Advanced</span>
                </div>
            </div>
            <div class="post-content">
                <p class="intro">This post explores advanced DOM manipulation techniques that every developer should know.</p>
                <p class="body">Learn how to efficiently traverse and modify the DOM tree using modern JavaScript methods.</p>
                <div class="code-example">
                    <code>document.querySelector('.example')</code>
                </div>
            </div>
        </article>
        
        <article class="post" data-id="2" data-category="css">
            <h2 class="post-title">Modern CSS Layout Techniques</h2>
            <div class="post-meta">
                <span class="author" data-author-id="456">Jane Smith</span>
                <time class="date" datetime="2024-01-16">January 16, 2024</time>
                <div class="tags">
                    <span class="tag primary">CSS</span>
                    <span class="tag secondary">Layout</span>
                    <span class="tag secondary">Grid</span>
                    <span class="tag secondary">Flexbox</span>
                </div>
            </div>
            <div class="post-content">
                <p class="intro">Explore modern CSS layout techniques including Grid and Flexbox.</p>
                <p class="body">Master responsive design with these powerful layout tools.</p>
            </div>
        </article>
    </main>
    
    <aside class="sidebar" data-section="sidebar">
        <div class="widget recent-posts">
            <h3 class="widget-title">Recent Posts</h3>
            <ul class="post-list">
                <li class="post-item"><a href="#post1" class="post-link">Getting Started with React</a></li>
                <li class="post-item"><a href="#post2" class="post-link">Vue.js Best Practices</a></li>
                <li class="post-item"><a href="#post3" class="post-link">Angular Performance Tips</a></li>
            </ul>
        </div>
        
        <div class="widget categories">
            <h3 class="widget-title">Categories</h3>
            <ul class="category-list">
                <li class="category-item"><a href="#js" class="category-link">JavaScript (15)</a></li>
                <li class="category-item"><a href="#css" class="category-link">CSS (8)</a></li>
                <li class="category-item"><a href="#html" class="category-link">HTML (5)</a></li>
            </ul>
        </div>
    </aside>
    
    <footer class="app-footer" data-section="footer">
        <p class="copyright">&copy; 2024 DOM Traversal Lab</p>
        <div class="social-links">
            <a href="#twitter" class="social-link">Twitter</a>
            <a href="#github" class="social-link">GitHub</a>
        </div>
    </footer>
`;

// Add some styling for better visualization
traversalLab.style.cssText = `
    border: 2px solid #007bff; 
    padding: 20px; 
    margin: 10px; 
    font-family: Arial, sans-serif;
    background: #ffffff;
    border-radius: 8px;
`;

/**
 * TRAVERSAL UTILITY CLASS
 * 
 * A comprehensive utility class that provides advanced DOM traversal methods
 * with performance optimizations and helpful debugging features.
 */
class DOMTraverser {
    constructor(root) {
        this.root = root;
        this.cache = new Map(); // Cache for expensive operations
        console.log('🧭 DOMTraverser initialized for:', root.className || root.tagName);
    }
    
    /**
     * GET ALL SIBLINGS
     * 
     * Returns all sibling elements of the given element.
     * 
     * @param {Element} element - The reference element
     * @param {boolean} includeElement - Whether to include the element itself
     * @returns {Array} - Array of sibling elements
     */
    getAllSiblings(element, includeElement = false) {
        const siblings = [];
        let sibling = element.parentElement?.firstElementChild;
        
        while (sibling) {
            if (sibling !== element || includeElement) {
                siblings.push(sibling);
            }
            sibling = sibling.nextElementSibling;
        }
        
        return siblings;
    }
    
    /**
     * GET ELEMENT PATH
     * 
     * Generates a CSS selector path from the root to the target element.
     * Useful for debugging and creating unique selectors.
     * 
     * @param {Element} element - The target element
     * @returns {string} - CSS selector path
     */
    getElementPath(element) {
        const cacheKey = `path_${element.tagName}_${element.className}`;
        
        // Check cache first for performance
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        const path = [];
        let current = element;
        
        while (current && current !== this.root) {
            let selector = current.tagName.toLowerCase();
            
            // Use ID if available (most specific)
            if (current.id) {
                selector += `#${current.id}`;
                path.unshift(selector);
                break; // ID is unique, no need to go further
            }
            
            // Add classes if available
            if (current.className) {
                const classes = current.className.split(' ').filter(c => c.trim());
                if (classes.length > 0) {
                    selector += `.${classes.join('.')}`;
                }
            }
            
            // Add nth-child if needed for uniqueness
            const siblings = this.getAllSiblings(current, true);
            const sameTagSiblings = siblings.filter(s => s.tagName === current.tagName);
            
            if (sameTagSiblings.length > 1) {
                const index = sameTagSiblings.indexOf(current) + 1;
                selector += `:nth-child(${index})`;
            }
            
            path.unshift(selector);
            current = current.parentElement;
        }
        
        const result = path.join(' > ');
        this.cache.set(cacheKey, result); // Cache the result
        return result;
    }
    
    /**
     * FIND ELEMENTS BY TEXT CONTENT
     * 
     * Finds elements containing specific text using TreeWalker for efficiency.
     * 
     * @param {string} text - Text to search for
     * @param {boolean} exact - Whether to match exactly or partially
     * @param {string} tagFilter - Optional tag name filter
     * @returns {Array} - Array of matching elements
     */
    findByText(text, exact = false, tagFilter = null) {
        const matches = [];
        
        // Use TreeWalker for efficient text node traversal
        const walker = document.createTreeWalker(
            this.root,
            NodeFilter.SHOW_TEXT, // Only text nodes
            {
                acceptNode: function(node) {
                    // Skip empty text nodes and whitespace-only nodes
                    return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                }
            },
            false
        );
        
        let textNode;
        while (textNode = walker.nextNode()) {
            const content = textNode.textContent.trim();
            const matchFound = exact ? content === text : content.includes(text);
            
            if (matchFound) {
                const parentElement = textNode.parentElement;
                
                // Apply tag filter if specified
                if (!tagFilter || parentElement.tagName.toLowerCase() === tagFilter.toLowerCase()) {
                    matches.push(parentElement);
                }
            }
        }
        
        return matches;
    }
    
    /**
     * GET ELEMENT STATISTICS
     * 
     * Analyzes the DOM structure and returns detailed statistics.
     * Useful for performance analysis and debugging.
     * 
     * @param {Element} element - Root element to analyze (defaults to this.root)
     * @returns {Object} - Detailed statistics object
     */
    getElementStats(element = this.root) {
        const stats = {
            totalElements: 0,
            totalTextNodes: 0,
            elementsByTag: {},
            elementsByClass: {},
            elementsWithId: 0,
            maxDepth: 0,
            averageChildren: 0,
            largestElement: null,
            largestElementSize: 0
        };
        
        /**
         * RECURSIVE TRAVERSAL FUNCTION
         * 
         * Recursively traverses the DOM tree and collects statistics.
         */
        const traverse = (el, depth = 0) => {
            stats.maxDepth = Math.max(stats.maxDepth, depth);
            stats.totalElements++;
            
            // Count by tag name
            const tag = el.tagName.toLowerCase();
            stats.elementsByTag[tag] = (stats.elementsByTag[tag] || 0) + 1;
            
            // Count by class names
            if (el.className) {
                el.className.split(' ').forEach(cls => {
                    if (cls.trim()) {
                        stats.elementsByClass[cls] = (stats.elementsByClass[cls] || 0) + 1;
                    }
                });
            }
            
            // Count elements with IDs
            if (el.id) {
                stats.elementsWithId++;
            }
            
            // Track largest element (by innerHTML length)
            const elementSize = el.innerHTML.length;
            if (elementSize > stats.largestElementSize) {
                stats.largestElementSize = elementSize;
                stats.largestElement = {
                    tagName: el.tagName,
                    className: el.className,
                    id: el.id,
                    size: elementSize
                };
            }
            
            // Count child elements and text nodes
            let childElementCount = 0;
            Array.from(el.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE && child.textContent.trim()) {
                    stats.totalTextNodes++;
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    childElementCount++;
                    traverse(child, depth + 1);
                }
            });
            
            // Update average children calculation
            if (childElementCount > 0) {
                stats.averageChildren = (stats.averageChildren + childElementCount) / 2;
            }
        };
        
        traverse(element);
        
        // Round average children to 2 decimal places
        stats.averageChildren = Math.round(stats.averageChildren * 100) / 100;
        
        return stats;
    }
    
    /**
     * HIGHLIGHT ELEMENT PATH
     * 
     * Visually highlights the path from an element to the root.
     * Useful for debugging and understanding DOM structure.
     * 
     * @param {Element} element - The target element
     * @param {number} duration - How long to show the highlight (ms)
     * @returns {Array} - Array of highlighted elements
     */
    highlightPath(element, duration = 3000) {
        const highlighted = [];
        let current = element;
        let depth = 0;
        
        // Highlight each element in the path with different colors
        while (current && current !== this.root) {
            const hue = (depth * 60) % 360; // Different color for each level
            const originalOutline = current.style.outline;
            const originalOutlineOffset = current.style.outlineOffset;
            
            current.style.outline = `3px solid hsl(${hue}, 70%, 50%)`;
            current.style.outlineOffset = '2px';
            current.style.transition = 'outline 0.3s ease';
            
            highlighted.push({
                element: current,
                originalOutline,
                originalOutlineOffset
            });
            
            current = current.parentElement;
            depth++;
        }
        
        // Remove highlights after specified duration
        setTimeout(() => {
            highlighted.forEach(({ element, originalOutline, originalOutlineOffset }) => {
                element.style.outline = originalOutline;
                element.style.outlineOffset = originalOutlineOffset;
                element.style.transition = '';
            });
        }, duration);
        
        console.log(`🎨 Highlighted path with ${highlighted.length} elements`);
        return highlighted.map(h => h.element);
    }
    
    /**
     * FIND CLOSEST BY ATTRIBUTE
     * 
     * Finds the closest ancestor element with a specific attribute.
     * More flexible than the native closest() method.
     * 
     * @param {Element} element - Starting element
     * @param {string} attribute - Attribute name to search for
     * @param {string} value - Optional attribute value to match
     * @returns {Element|null} - Matching ancestor or null
     */
    findClosestByAttribute(element, attribute, value = null) {
        let current = element;
        
        while (current && current !== this.root) {
            if (current.hasAttribute(attribute)) {
                if (value === null || current.getAttribute(attribute) === value) {
                    return current;
                }
            }
            current = current.parentElement;
        }
        
        return null;
    }
    
    /**
     * GET ELEMENT DEPTH
     * 
     * Calculates how deep an element is nested within the root.
     * 
     * @param {Element} element - The target element
     * @returns {number} - Depth level (0 = direct child of root)
     */
    getElementDepth(element) {
        let depth = 0;
        let current = element;
        
        while (current && current !== this.root) {
            depth++;
            current = current.parentElement;
        }
        
        return current === this.root ? depth : -1; // -1 if not a descendant
    }
}

// Initialize the traverser
const traverser = new DOMTraverser(traversalLab);

/**
 * INTERACTIVE TRAVERSAL CONTROLS
 * 
 * Create an interactive interface to demonstrate traversal methods.
 */
const traversalControls = document.createElement('div');
traversalControls.innerHTML = `
    <h4>🎮 Interactive Traversal Controls</h4>
    <p>Click on any element in the lab above, then use these controls to explore DOM relationships.</p>
    
    <div class="controls-grid" style="
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
        gap: 10px; 
        margin: 15px 0;
    ">
        <button class="btn-demo-traversal">🧭 Run Traversal Demo</button>
        <button class="btn-show-stats">📊 Show DOM Statistics</button>
        <button class="btn-find-text">🔍 Find by Text</button>
        <button class="btn-highlight-path">🎨 Highlight Element Path</button>
    </div>
    
    <div class="search-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
        <label style="display: block; margin-bottom: 5px; font-weight: bold;">🔍 Text Search:</label>
        <input type="text" class="text-search" placeholder="Enter text to find (e.g., 'JavaScript')" style="
            width: 200px; 
            padding: 8px; 
            border: 1px solid #ddd; 
            border-radius: 4px;
            margin-right: 10px;
        ">
        <label style="margin-left: 15px;">
            <input type="checkbox" class="exact-match"> Exact match only
        </label>
    </div>
    
    <div class="traversal-output" style="
        background: #f9f9f9; 
        padding: 15px; 
        margin: 15px 0; 
        font-family: monospace; 
        font-size: 12px; 
        max-height: 300px; 
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        white-space: pre-wrap;
    "></div>
`;
traversalControls.style.cssText = 'border: 1px solid #28a745; padding: 20px; margin: 10px 0; border-radius: 8px; background: #f8fff8;';

const output = traversalControls.querySelector('.traversal-output');
const textSearch = traversalControls.querySelector('.text-search');
const exactMatch = traversalControls.querySelector('.exact-match');

// Track the currently selected element
let selectedElement = null;

/**
 * OUTPUT LOGGING FUNCTION
 * 
 * Formats and displays output in the demo interface.
 */
function logToOutput(message) {
    const timestamp = new Date().toLocaleTimeString();
    output.textContent += `[${timestamp}] ${message}\n`;
    output.scrollTop = output.scrollHeight;
}

/**
 * DEMONSTRATE BASIC TRAVERSAL METHODS
 * 
 * Shows various DOM traversal techniques with the selected element.
 */
function demonstrateTraversal() {
    if (!selectedElement) {
        logToOutput('❌ No element selected. Click on an element in the lab first.');
        return;
    }
    
    output.textContent = ''; // Clear previous output
    logToOutput('🧭 DOM TRAVERSAL DEMONSTRATION');
    logToOutput('='.repeat(50));
    
    // Basic element information
    logToOutput(`\n📍 SELECTED ELEMENT:`);
    logToOutput(`  Tag: ${selectedElement.tagName}`);
    logToOutput(`  Class: ${selectedElement.className || 'none'}`);
    logToOutput(`  ID: ${selectedElement.id || 'none'}`);
    logToOutput(`  Text: "${selectedElement.textContent.trim().substring(0, 50)}..."`);
    
    // Parent traversal
    logToOutput(`\n🔼 PARENT TRAVERSAL:`);
    logToOutput(`  parentElement: ${selectedElement.parentElement?.tagName || 'none'}`);
    logToOutput(`  closest('.post'): ${selectedElement.closest('.post')?.className || 'not found'}`);
    logToOutput(`  closest('[data-section]'): ${selectedElement.closest('[data-section]')?.dataset.section || 'not found'}`);
    
    // Child traversal
    logToOutput(`\n🔽 CHILD TRAVERSAL:`);
    logToOutput(`  children.length: ${selectedElement.children.length}`);
    logToOutput(`  childNodes.length: ${selectedElement.childNodes.length}`);
    logToOutput(`  firstElementChild: ${selectedElement.firstElementChild?.tagName || 'none'}`);
    logToOutput(`  lastElementChild: ${selectedElement.lastElementChild?.tagName || 'none'}`);
    
    // Sibling traversal
    logToOutput(`\n↔️ SIBLING TRAVERSAL:`);
    logToOutput(`  nextElementSibling: ${selectedElement.nextElementSibling?.tagName || 'none'}`);
    logToOutput(`  previousElementSibling: ${selectedElement.previousElementSibling?.tagName || 'none'}`);
    
    const siblings = traverser.getAllSiblings(selectedElement);
    logToOutput(`  total siblings: ${siblings.length}`);
    
    // Advanced traversal
    logToOutput(`\n🔍 ADVANCED TRAVERSAL:`);
    logToOutput(`  element path: ${traverser.getElementPath(selectedElement)}`);
    logToOutput(`  element depth: ${traverser.getElementDepth(selectedElement)}`);
    
    const closestWithData = traverser.findClosestByAttribute(selectedElement, 'data-id');
    logToOutput(`  closest with data-id: ${closestWithData?.tagName || 'not found'}`);
    
    // Query methods
    logToOutput(`\n🎯 QUERY METHODS:`);
    const childLinks = selectedElement.querySelectorAll('a');
    logToOutput(`  descendant links: ${childLinks.length}`);
    
    const childTags = selectedElement.querySelectorAll('.tag');
    logToOutput(`  descendant .tag elements: ${childTags.length}`);
}

// Button event handlers
traversalControls.querySelector('.btn-demo-traversal').addEventListener('click', demonstrateTraversal);

traversalControls.querySelector('.btn-show-stats').addEventListener('click', () => {
    const stats = traverser.getElementStats();
    output.textContent = '';
    logToOutput('📊 DOM STRUCTURE STATISTICS');
    logToOutput('='.repeat(50));
    
    logToOutput(`\n📈 OVERVIEW:`);
    logToOutput(`  Total elements: ${stats.totalElements}`);
    logToOutput(`  Total text nodes: ${stats.totalTextNodes}`);
    logToOutput(`  Maximum depth: ${stats.maxDepth}`);
    logToOutput(`  Average children per element: ${stats.averageChildren}`);
    logToOutput(`  Elements with ID: ${stats.elementsWithId}`);
    
    logToOutput(`\n🏷️ ELEMENTS BY TAG:`);
    Object.entries(stats.elementsByTag)
        .sort(([,a], [,b]) => b - a)
        .forEach(([tag, count]) => {
            logToOutput(`  ${tag}: ${count}`);
        });
    
    logToOutput(`\n🎨 TOP CLASSES:`);
    Object.entries(stats.elementsByClass)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 10)
        .forEach(([cls, count]) => {
            logToOutput(`  .${cls}: ${count}`);
        });
    
    if (stats.largestElement) {
        logToOutput(`\n📏 LARGEST ELEMENT:`);
        logToOutput(`  Tag: ${stats.largestElement.tagName}`);
        logToOutput(`  Class: ${stats.largestElement.className || 'none'}`);
        logToOutput(`  Size: ${stats.largestElement.size} characters`);
    }
});

traversalControls.querySelector('.btn-find-text').addEventListener('click', () => {
    const searchText = textSearch.value.trim();
    if (!searchText) {
        logToOutput('❌ Please enter text to search for.');
        return;
    }
    
    const isExact = exactMatch.checked;
    const matches = traverser.findByText(searchText, isExact);
    
    output.textContent = '';
    logToOutput(`🔍 TEXT SEARCH RESULTS`);
    logToOutput('='.repeat(50));
    logToOutput(`\nSearching for: "${searchText}" (${isExact ? 'exact' : 'partial'} match)`);
    logToOutput(`Found ${matches.length} matches:\n`);
    
    matches.forEach((element, index) => {
        const path = traverser.getElementPath(element);
        const text = element.textContent.trim().substring(0, 100);
        logToOutput(`${index + 1}. ${element.tagName}.${element.className || 'no-class'}`);
        logToOutput(`   Path: ${path}`);
        logToOutput(`   Text: "${text}${text.length === 100 ? '...' : ''}"`);
        logToOutput('');
        
        // Highlight the match temporarily
        element.style.backgroundColor = 'yellow';
        element.style.transition = 'background-color 0.3s ease';
        setTimeout(() => {
            element.style.backgroundColor = '';
        }, 2000);
    });
    
    if (matches.length === 0) {
        logToOutput('No matches found. Try a different search term or disable exact match.');
    }
});

traversalControls.querySelector('.btn-highlight-path').addEventListener('click', () => {
    if (!selectedElement) {
        logToOutput('❌ No element selected. Click on an element in the lab first.');
        return;
    }
    
    const highlightedElements = traverser.highlightPath(selectedElement);
    
    output.textContent = '';
    logToOutput('🎨 ELEMENT PATH HIGHLIGHTED');
    logToOutput('='.repeat(50));
    logToOutput(`\nHighlighted path from selected element to root:`);
    logToOutput(`Path contains ${highlightedElements.length} elements\n`);
    
    highlightedElements.forEach((element, index) => {
        const depth = highlightedElements.length - index - 1;
        logToOutput(`${'  '.repeat(depth)}${index + 1}. ${element.tagName}.${element.className || 'no-class'}`);
    });
    
    logToOutput(`\nHighlights will fade after 3 seconds.`);
});

// Add click handler to lab elements for selection
traversalLab.addEventListener('click', (e) => {
    // Remove previous selection highlight
    if (selectedElement) {
        selectedElement.style.boxShadow = '';
    }
    
    // Set new selection
    selectedElement = e.target;
    
    // Highlight selected element
    selectedElement.style.boxShadow = '0 0 0 3px rgba(0, 123, 255, 0.5)';
    selectedElement.style.transition = 'box-shadow 0.3s ease';
    
    logToOutput(`✅ Selected: ${selectedElement.tagName}.${selectedElement.className || 'no-class'}`);
    
    // Prevent event bubbling to avoid multiple selections
    e.stopPropagation();
});

// Add the components to the page
document.body.appendChild(traversalLab);
document.body.appendChild(traversalControls);

console.log('✅ DOM Traversal Laboratory initialized');
console.log('💡 Click on any element in the lab, then use the controls to explore!');
```### Dy
namic DOM Manipulation with Performance Optimization

```javascript
/**
 * ADVANCED DOM MANIPULATION SYSTEM
 * 
 * This class provides high-performance DOM manipulation methods
 * with built-in optimization techniques and animation support.
 */

class DOMManipulator {
    constructor() {
        this.animationQueue = [];          // Queue for managing animations
        this.isAnimating = false;          // Animation state flag
        this.performanceMetrics = new Map(); // Performance tracking
        
        console.log('🛠️ DOMManipulator initialized with performance tracking');
    }
    
    /**
     * CREATE ELEMENT WITH ADVANCED OPTIONS
     * 
     * Creates DOM elements with comprehensive configuration options.
     * This method provides a fluent API for element creation.
     * 
     * @param {string} tag - HTML tag name
     * @param {Object} options - Configuration options
     * @returns {Element} - The created element
     */
    createElement(tag, options = {}) {
        const startTime = performance.now();
        
        const element = document.createElement(tag);
        
        // Set attributes (data-*, aria-*, etc.)
        if (options.attributes) {
            Object.entries(options.attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
        }
        
        // Set properties (className, id, textContent, etc.)
        if (options.properties) {
            Object.entries(options.properties).forEach(([key, value]) => {
                element[key] = value;
            });
        }
        
        // Set CSS styles
        if (options.styles) {
            Object.entries(options.styles).forEach(([key, value]) => {
                element.style[key] = value;
            });
        }
        
        // Set dataset properties (data-* attributes)
        if (options.dataset) {
            Object.entries(options.dataset).forEach(([key, value]) => {
                element.dataset[key] = value;
            });
        }
        
        // Add event listeners
        if (options.events) {
            Object.entries(options.events).forEach(([event, handler]) => {
                element.addEventListener(event, handler);
            });
        }
        
        // Set content (text or HTML)
        if (options.text) {
            element.textContent = options.text;
        } else if (options.html) {
            element.innerHTML = options.html;
        }
        
        // Add child elements
        if (options.children) {
            options.children.forEach(child => {
                if (typeof child === 'string') {
                    element.appendChild(document.createTextNode(child));
                } else if (child instanceof Element) {
                    element.appendChild(child);
                }
            });
        }
        
        // Track performance
        const endTime = performance.now();
        this.recordMetric('createElement', endTime - startTime);
        
        return element;
    }
    
    /**
     * ANIMATED INSERTION
     * 
     * Inserts elements with smooth animations for better user experience.
     * 
     * @param {Element} element - Element to insert
     * @param {Element} parent - Parent element
     * @param {string} position - Insertion position
     * @param {string} animation - Animation type
     * @returns {Promise} - Resolves when animation completes
     */
    async insertWithAnimation(element, parent, position = 'beforeend', animation = 'fadeIn') {
        return new Promise((resolve) => {
            const startTime = performance.now();
            
            // Define animation presets
            const animations = {
                fadeIn: { 
                    initial: { opacity: '0', transform: 'translateY(-20px)' },
                    final: { opacity: '1', transform: 'translateY(0)' }
                },
                slideIn: { 
                    initial: { opacity: '0', transform: 'translateX(-100%)' },
                    final: { opacity: '1', transform: 'translateX(0)' }
                },
                scaleIn: { 
                    initial: { opacity: '0', transform: 'scale(0.5)' },
                    final: { opacity: '1', transform: 'scale(1)' }
                },
                bounceIn: { 
                    initial: { opacity: '0', transform: 'scale(0.3) rotate(180deg)' },
                    final: { opacity: '1', transform: 'scale(1) rotate(0deg)' }
                }
            };
            
            const animationConfig = animations[animation] || animations.fadeIn;
            
            // Set initial animation state
            Object.assign(element.style, animationConfig.initial);
            element.style.transition = 'all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)'; // Bouncy easing
            
            // Insert element into DOM
            parent.insertAdjacentElement(position, element);
            
            // Trigger animation on next frame
            requestAnimationFrame(() => {
                Object.assign(element.style, animationConfig.final);
                
                // Clean up after animation
                setTimeout(() => {
                    element.style.transition = '';
                    
                    // Record performance
                    const endTime = performance.now();
                    this.recordMetric('insertWithAnimation', endTime - startTime);
                    
                    resolve(element);
                }, 400);
            });
        });
    }
    
    /**
     * ANIMATED REMOVAL
     * 
     * Removes elements with smooth exit animations.
     * 
     * @param {Element} element - Element to remove
     * @param {string} animation - Animation type
     * @returns {Promise} - Resolves when element is removed
     */
    async removeWithAnimation(element, animation = 'fadeOut') {
        return new Promise((resolve) => {
            const startTime = performance.now();
            
            const animations = {
                fadeOut: { opacity: '0', transform: 'translateY(-20px)' },
                slideOut: { opacity: '0', transform: 'translateX(100%)' },
                scaleOut: { opacity: '0', transform: 'scale(0)' },
                bounceOut: { opacity: '0', transform: 'scale(0) rotate(180deg)' }
            };
            
            const animationConfig = animations[animation] || animations.fadeOut;
            
            element.style.transition = 'all 0.3s ease-in';
            Object.assign(element.style, animationConfig);
            
            setTimeout(() => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
                
                // Record performance
                const endTime = performance.now();
                this.recordMetric('removeWithAnimation', endTime - startTime);
                
                resolve();
            }, 300);
        });
    }
    
    /**
     * BATCH OPERATIONS WITH DOCUMENT FRAGMENT
     * 
     * Performs multiple DOM insertions efficiently using DocumentFragment.
     * This minimizes reflows and repaints for better performance.
     * 
     * @param {Element} parent - Parent element
     * @param {Array} elements - Elements to insert
     * @param {boolean} useFragment - Whether to use DocumentFragment
     * @returns {number} - Operation duration in milliseconds
     */
    batchInsert(parent, elements, useFragment = true) {
        const startTime = performance.now();
        
        if (useFragment) {
            // ✅ Efficient approach: Use DocumentFragment
            const fragment = document.createDocumentFragment();
            
            elements.forEach(element => {
                fragment.appendChild(element);
            });
            
            // Single DOM operation
            parent.appendChild(fragment);
            
        } else {
            // ❌ Inefficient approach: Individual insertions
            elements.forEach(element => {
                parent.appendChild(element);
            });
        }
        
        const endTime = performance.now();
        const duration = endTime - startTime;
        
        this.recordMetric('batchInsert', duration);
        console.log(`📦 Batch inserted ${elements.length} elements in ${duration.toFixed(2)}ms (fragment: ${useFragment})`);
        
        return duration;
    }
    
    /**
     * CLONE WITH MODIFICATIONS
     * 
     * Creates a deep clone of an element with optional modifications.
     * 
     * @param {Element} element - Element to clone
     * @param {Object} modifications - Modifications to apply
     * @returns {Element} - The modified clone
     */
    cloneWithModifications(element, modifications = {}) {
        const startTime = performance.now();
        
        // Create deep clone (includes all children and attributes)
        const clone = element.cloneNode(true);
        
        // Apply modifications
        if (modifications.attributes) {
            Object.entries(modifications.attributes).forEach(([key, value]) => {
                clone.setAttribute(key, value);
            });
        }
        
        if (modifications.styles) {
            Object.assign(clone.style, modifications.styles);
        }
        
        if (modifications.textContent) {
            clone.textContent = modifications.textContent;
        }
        
        if (modifications.className) {
            clone.className = modifications.className;
        }
        
        if (modifications.dataset) {
            Object.entries(modifications.dataset).forEach(([key, value]) => {
                clone.dataset[key] = value;
            });
        }
        
        // Record performance
        const endTime = performance.now();
        this.recordMetric('cloneWithModifications', endTime - startTime);
        
        return clone;
    }
    
    /**
     * REPLACE WITH TRANSITION
     * 
     * Replaces an element with smooth cross-fade transition.
     * 
     * @param {Element} oldElement - Element to replace
     * @param {Element} newElement - Replacement element
     * @param {string} transition - Transition type
     * @returns {Promise} - Resolves when transition completes
     */
    async replaceWithTransition(oldElement, newElement, transition = 'crossFade') {
        return new Promise((resolve) => {
            const startTime = performance.now();
            const parent = oldElement.parentNode;
            const rect = oldElement.getBoundingClientRect();
            
            if (transition === 'crossFade') {
                // Position new element exactly over the old one
                newElement.style.position = 'absolute';
                newElement.style.top = rect.top + window.scrollY + 'px';
                newElement.style.left = rect.left + window.scrollX + 'px';
                newElement.style.width = rect.width + 'px';
                newElement.style.height = rect.height + 'px';
                newElement.style.opacity = '0';
                newElement.style.zIndex = '1000';
                
                // Add to document for positioning
                document.body.appendChild(newElement);
                
                // Set up transitions
                newElement.style.transition = 'opacity 0.4s ease';
                oldElement.style.transition = 'opacity 0.4s ease';
                
                // Start cross-fade
                requestAnimationFrame(() => {
                    newElement.style.opacity = '1';
                    oldElement.style.opacity = '0';
                    
                    setTimeout(() => {
                        // Reset positioning and replace in original location
                        newElement.style.position = '';
                        newElement.style.top = '';
                        newElement.style.left = '';
                        newElement.style.width = '';
                        newElement.style.height = '';
                        newElement.style.zIndex = '';
                        newElement.style.transition = '';
                        
                        parent.replaceChild(newElement, oldElement);
                        
                        // Record performance
                        const endTime = performance.now();
                        this.recordMetric('replaceWithTransition', endTime - startTime);
                        
                        resolve(newElement);
                    }, 400);
                });
            }
        });
    }
    
    /**
     * RECORD PERFORMANCE METRIC
     * 
     * Tracks performance metrics for different operations.
     * 
     * @param {string} operation - Operation name
     * @param {number} duration - Duration in milliseconds
     */
    recordMetric(operation, duration) {
        if (!this.performanceMetrics.has(operation)) {
            this.performanceMetrics.set(operation, []);
        }
        
        const metrics = this.performanceMetrics.get(operation);
        metrics.push(duration);
        
        // Keep only last 100 measurements
        if (metrics.length > 100) {
            metrics.shift();
        }
    }
    
    /**
     * GET PERFORMANCE STATISTICS
     * 
     * Returns performance statistics for all tracked operations.
     * 
     * @returns {Object} - Performance statistics
     */
    getPerformanceStats() {
        const stats = {};
        
        this.performanceMetrics.forEach((metrics, operation) => {
            if (metrics.length === 0) return;
            
            const sorted = [...metrics].sort((a, b) => a - b);
            stats[operation] = {
                count: metrics.length,
                min: sorted[0],
                max: sorted[sorted.length - 1],
                avg: metrics.reduce((sum, val) => sum + val, 0) / metrics.length,
                median: sorted[Math.floor(sorted.length / 2)],
                p95: sorted[Math.floor(sorted.length * 0.95)]
            };
        });
        
        return stats;
    }
}

/**
 * COMPREHENSIVE DOM MANIPULATION DEMO
 * 
 * Interactive demonstration of all DOM manipulation techniques.
 */

// Create the demo interface
const manipulationDemo = document.createElement('div');
manipulationDemo.innerHTML = `
    <h3>🛠️ Advanced DOM Manipulation Demo</h3>
    <p>Explore high-performance DOM manipulation techniques with animations and optimizations.</p>
    
    <div class="manipulation-controls" style="
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
        gap: 10px; 
        margin: 15px 0; 
        padding: 15px; 
        background: #f8f9fa; 
        border-radius: 8px;
    ">
        <button class="btn-create-advanced">✨ Create Advanced Element</button>
        <button class="btn-batch-create">📦 Batch Create (Performance Test)</button>
        <button class="btn-animated-insert">🎬 Animated Insert</button>
        <button class="btn-clone-modify">📋 Clone & Modify</button>
        <button class="btn-replace-transition">🔄 Replace with Transition</button>
        <button class="btn-show-performance">📊 Show Performance Stats</button>
        <button class="btn-clear-demo">🧹 Clear Demo Area</button>
    </div>
    
    <div class="demo-area" style="
        min-height: 400px; 
        border: 2px dashed #dee2e6; 
        padding: 20px; 
        position: relative;
        background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                    linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                    linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                    linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        border-radius: 8px;
        overflow: hidden;
    ">
        <div class="demo-placeholder" style="
            text-align: center; 
            color: #6c757d; 
            font-style: italic; 
            padding: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            border: 1px dashed #adb5bd;
        ">
            🎭 Demo area - elements will appear here with animations!<br>
            <small>Try the controls above to see DOM manipulation in action</small>
        </div>
    </div>
    
    <div class="performance-stats" style="
        background: #e3f2fd; 
        padding: 15px; 
        margin: 15px 0; 
        font-family: monospace; 
        font-size: 12px;
        border-radius: 8px;
        border: 1px solid #bbdefb;
        display: none;
    "></div>
`;
manipulationDemo.style.cssText = 'border: 2px solid #6f42c1; padding: 20px; margin: 10px; border-radius: 10px; background: #ffffff;';

// Get references to demo elements
const demoArea = manipulationDemo.querySelector('.demo-area');
const performanceStats = manipulationDemo.querySelector('.performance-stats');
const demoPlaceholder = manipulationDemo.querySelector('.demo-placeholder');

// Initialize the manipulator
const manipulator = new DOMManipulator();

// Track created elements
let elementCounter = 0;

/**
 * BUTTON EVENT HANDLERS
 * 
 * Each button demonstrates different DOM manipulation techniques.
 */

// Advanced element creation
manipulationDemo.querySelector('.btn-create-advanced').addEventListener('click', async () => {
    elementCounter++;
    
    // Create element with comprehensive options
    const advancedElement = manipulator.createElement('div', {
        attributes: {
            'data-id': elementCounter,
            'data-type': 'advanced',
            'aria-label': `Advanced element ${elementCounter}`
        },
        properties: {
            className: 'advanced-element interactive'
        },
        styles: {
            padding: '20px',
            margin: '10px',
            background: `linear-gradient(135deg, 
                hsl(${(elementCounter * 137.5) % 360}, 70%, 60%), 
                hsl(${(elementCounter * 137.5 + 60) % 360}, 70%, 80%))`,
            color: 'white',
            borderRadius: '12px',
            cursor: 'pointer',
            boxShadow: '0 4px 15px rgba(0, 0, 0, 0.2)',
            transform: 'translateY(0)',
            transition: 'transform 0.2s ease, box-shadow 0.2s ease',
            fontWeight: 'bold',
            textAlign: 'center',
            minHeight: '80px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column'
        },
        dataset: {
            created: new Date().toISOString(),
            counter: elementCounter,
            animationType: 'hover'
        },
        events: {
            click: function(e) {
                // Toggle scale animation
                const isScaled = this.style.transform.includes('scale');
                this.style.transform = isScaled 
                    ? 'translateY(0) scale(1)' 
                    : 'translateY(-5px) scale(1.05)';
                
                // Change gradient
                const hue = Math.random() * 360;
                this.style.background = `linear-gradient(135deg, 
                    hsl(${hue}, 70%, 60%), 
                    hsl(${hue + 60}, 70%, 80%))`;
                
                console.log(`🖱️ Advanced element ${this.dataset.counter} clicked!`);
            },
            mouseenter: function() {
                this.style.transform = 'translateY(-5px) scale(1.02)';
                this.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.3)';
            },
            mouseleave: function() {
                this.style.transform = 'translateY(0) scale(1)';
                this.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
            },
            dblclick: function() {
                // Spin animation
                this.style.transform += ' rotate(360deg)';
                setTimeout(() => {
                    this.style.transform = this.style.transform.replace(' rotate(360deg)', '');
                }, 600);
            }
        },
        html: `
            <div style="font-size: 18px; margin-bottom: 5px;">
                🎨 Advanced Element #${elementCounter}
            </div>
            <div style="font-size: 12px; opacity: 0.9;">
                Created: ${new Date().toLocaleTimeString()}<br>
                Click to interact • Double-click to spin
            </div>
        `
    });
    
    // Hide placeholder if it exists
    if (demoPlaceholder && demoPlaceholder.parentNode) {
        await manipulator.removeWithAnimation(demoPlaceholder, 'fadeOut');
    }
    
    // Insert with random animation
    const animations = ['fadeIn', 'slideIn', 'scaleIn', 'bounceIn'];
    const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
    
    await manipulator.insertWithAnimation(advancedElement, demoArea, 'beforeend', randomAnimation);
    
    console.log(`✨ Created advanced element #${elementCounter} with ${randomAnimation} animation`);
});

// Batch creation performance test
manipulationDemo.querySelector('.btn-batch-create').addEventListener('click', () => {
    const elementCount = 500; // Reduced for better demo experience
    
    console.log(`🚀 Starting batch creation performance test with ${elementCount} elements...`);
    
    // Create elements array
    const elements = [];
    for (let i = 0; i < elementCount; i++) {
        const element = manipulator.createElement('div', {
            styles: {
                padding: '3px 8px',
                margin: '2px',
                background: `hsl(${(i * 137.5) % 360}, 60%, 85%)`,
                fontSize: '11px',
                display: 'inline-block',
                borderRadius: '4px',
                border: '1px solid rgba(0, 0, 0, 0.1)'
            },
            text: `Batch ${i + 1}`,
            dataset: {
                batchIndex: i
            }
        });
        elements.push(element);
    }
    
    // Create containers for comparison
    const container1 = manipulator.createElement('div', {
        styles: {
            maxHeight: '150px',
            overflowY: 'auto',
            border: '2px solid #28a745',
            margin: '10px',
            padding: '10px',
            borderRadius: '6px',
            background: '#f8fff8'
        },
        html: '<h5 style="margin: 0 0 10px 0; color: #28a745;">📦 DocumentFragment (Optimized)</h5>'
    });
    
    const container2 = manipulator.createElement('div', {
        styles: {
            maxHeight: '150px',
            overflowY: 'auto',
            border: '2px solid #dc3545',
            margin: '10px',
            padding: '10px',
            borderRadius: '6px',
            background: '#fff5f5'
        },
        html: '<h5 style="margin: 0 0 10px 0; color: #dc3545;">🐌 Individual Inserts (Slow)</h5>'
    });
    
    // Test with DocumentFragment (fast)
    const fragmentTime = manipulator.batchInsert(
        container1, 
        elements.map(el => el.cloneNode(true)), 
        true
    );
    
    // Test with individual inserts (slow)
    const individualTime = manipulator.batchInsert(
        container2, 
        elements.map(el => el.cloneNode(true)), 
        false
    );
    
    // Add containers to demo area
    demoArea.appendChild(container1);
    demoArea.appendChild(container2);
    
    // Show performance comparison
    const improvement = ((individualTime - fragmentTime) / individualTime * 100).toFixed(1);
    const comparisonDiv = manipulator.createElement('div', {
        styles: {
            background: '#fff3cd',
            border: '1px solid #ffeaa7',
            padding: '15px',
            margin: '10px',
            borderRadius: '6px',
            fontFamily: 'monospace',
            fontSize: '12px'
        },
        html: `
            <strong>📊 Performance Comparison Results:</strong><br><br>
            <strong>Elements Created:</strong> ${elementCount.toLocaleString()}<br>
            <strong>DocumentFragment:</strong> ${fragmentTime.toFixed(2)}ms<br>
            <strong>Individual Inserts:</strong> ${individualTime.toFixed(2)}ms<br>
            <strong>Performance Improvement:</strong> ${improvement}% faster<br>
            <strong>Speed Multiplier:</strong> ${(individualTime / fragmentTime).toFixed(1)}x faster<br><br>
            <em>DocumentFragment batches DOM operations for optimal performance!</em>
        `
    });
    
    demoArea.appendChild(comparisonDiv);
    
    console.log(`📊 Batch test completed: Fragment ${fragmentTime.toFixed(2)}ms vs Individual ${individualTime.toFixed(2)}ms`);
});

// Animated insertion
manipulationDemo.querySelector('.btn-animated-insert').addEventListener('click', async () => {
    const animations = ['fadeIn', 'slideIn', 'scaleIn', 'bounceIn'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
    
    const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    
    const animatedElement = manipulator.createElement('div', {
        styles: {
            padding: '15px 20px',
            margin: '8px',
            background: randomColor,
            color: 'white',
            borderRadius: '8px',
            fontWeight: 'bold',
            textAlign: 'center',
            boxShadow: '0 2px 10px rgba(0, 0, 0, 0.2)',
            cursor: 'pointer'
        },
        html: `
            🎬 Animated with <strong>${randomAnimation}</strong><br>
            <small>Click me for a surprise!</small>
        `,
        events: {
            click: async function() {
                // Surprise animation
                this.style.transform = 'rotate(720deg) scale(1.2)';
                this.style.transition = 'transform 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                
                setTimeout(() => {
                    this.style.transform = '';
                    this.innerHTML = '🎉 Surprise! I spun around!';
                }, 800);
            }
        }
    });
    
    await manipulator.insertWithAnimation(animatedElement, demoArea, 'beforeend', randomAnimation);
    
    console.log(`🎬 Inserted element with ${randomAnimation} animation`);
});

// Clone and modify
manipulationDemo.querySelector('.btn-clone-modify').addEventListener('click', () => {
    const existingElements = demoArea.querySelectorAll('.advanced-element');
    
    if (existingElements.length === 0) {
        alert('💡 Create an advanced element first to see cloning in action!');
        return;
    }
    
    const originalElement = existingElements[Math.floor(Math.random() * existingElements.length)];
    
    const clone = manipulator.cloneWithModifications(originalElement, {
        attributes: {
            'data-type': 'cloned',
            'data-original-id': originalElement.dataset.id
        },
        styles: {
            background: 'linear-gradient(135deg, #667eea, #764ba2)',
            transform: 'rotate(5deg)',
            border: '3px dashed #ffffff'
        },
        dataset: {
            cloned: 'true',
            clonedAt: Date.now()
        }
    });
    
    // Update content to show it's a clone
    const originalCounter = originalElement.dataset.counter;
    clone.innerHTML = `
        <div style="font-size: 18px; margin-bottom: 5px;">
            📋 Clone of Element #${originalCounter}
        </div>
        <div style="font-size: 12px; opacity: 0.9;">
            Cloned: ${new Date().toLocaleTimeString()}<br>
            Original ID: ${originalElement.dataset.id}
        </div>
    `;
    
    demoArea.appendChild(clone);
    
    console.log(`📋 Cloned element #${originalCounter} with modifications`);
});

// Replace with transition
manipulationDemo.querySelector('.btn-replace-transition').addEventListener('click', async () => {
    const placeholder = demoArea.querySelector('.demo-placeholder');
    
    if (!placeholder) {
        alert('💡 Clear the demo area first to see the replacement transition!');
        return;
    }
    
    const replacement = manipulator.createElement('div', {
        styles: {
            padding: '40px',
            background: 'linear-gradient(135deg, #667eea, #764ba2)',
            color: 'white',
            borderRadius: '12px',
            textAlign: 'center',
            boxShadow: '0 10px 30px rgba(0, 0, 0, 0.3)',
            border: '3px solid #ffffff'
        },
        html: `
            <div style="font-size: 24px; margin-bottom: 10px;">🔄</div>
            <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">
                Smooth Replacement Complete!
            </div>
            <div style="font-size: 14px; opacity: 0.9;">
                The placeholder was replaced with a beautiful cross-fade transition
            </div>
        `
    });
    
    await manipulator.replaceWithTransition(placeholder, replacement, 'crossFade');
    
    console.log('🔄 Replaced placeholder with smooth transition');
});

// Show performance statistics
manipulationDemo.querySelector('.btn-show-performance').addEventListener('click', () => {
    const stats = manipulator.getPerformanceStats();
    const isVisible = performanceStats.style.display !== 'none';
    
    if (isVisible) {
        performanceStats.style.display = 'none';
    } else {
        let statsHTML = '<strong>📊 DOM Manipulation Performance Statistics:</strong><br><br>';
        
        if (Object.keys(stats).length === 0) {
            statsHTML += '<em>No performance data yet. Try some operations first!</em>';
        } else {
            Object.entries(stats).forEach(([operation, metrics]) => {
                statsHTML += `<strong>${operation}:</strong><br>`;
                statsHTML += `  Operations: ${metrics.count}<br>`;
                statsHTML += `  Average: ${metrics.avg.toFixed(2)}ms<br>`;
                statsHTML += `  Min: ${metrics.min.toFixed(2)}ms<br>`;
                statsHTML += `  Max: ${metrics.max.toFixed(2)}ms<br>`;
                statsHTML += `  95th Percentile: ${metrics.p95.toFixed(2)}ms<br><br>`;
            });
            
            statsHTML += '<em>💡 Lower times indicate better performance!</em>';
        }
        
        performanceStats.innerHTML = statsHTML;
        performanceStats.style.display = 'block';
    }
});

// Clear demo area
manipulationDemo.querySelector('.btn-clear-demo').addEventListener('click', async () => {
    const elements = Array.from(demoArea.children);
    
    if (elements.length === 0) {
        console.log('🧹 Demo area is already empty');
        return;
    }
    
    console.log(`🧹 Clearing ${elements.length} elements with staggered animations...`);
    
    // Remove elements with staggered animation for visual effect
    for (let i = 0; i < elements.length; i++) {
        setTimeout(async () => {
            if (elements[i] && elements[i].parentNode) {
                const animations = ['fadeOut', 'slideOut', 'scaleOut'];
                const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
                
                await manipulator.removeWithAnimation(elements[i], randomAnimation);
            }
            
            // Add placeholder back after all elements are removed
            if (i === elements.length - 1) {
                setTimeout(() => {
                    if (demoArea.children.length === 0) {
                        const newPlaceholder = manipulator.createElement('div', {
                            properties: {
                                className: 'demo-placeholder'
                            },
                            styles: {
                                textAlign: 'center',
                                color: '#6c757d',
                                fontStyle: 'italic',
                                padding: '50px',
                                background: 'rgba(255, 255, 255, 0.8)',
                                borderRadius: '8px',
                                border: '1px dashed #adb5bd'
                            },
                            html: `
                                🎭 Demo area cleared - ready for new elements!<br>
                                <small>Try the controls above to see DOM manipulation in action</small>
                            `
                        });
                        
                        manipulator.insertWithAnimation(newPlaceholder, demoArea, 'beforeend', 'fadeIn');
                    }
                }, 200);
            }
        }, i * 150); // Stagger the animations
    }
    
    // Hide performance stats
    performanceStats.style.display = 'none';
});

// Add the demo to the page
document.body.appendChild(manipulationDemo);

console.log('✅ Advanced DOM Manipulation Demo initialized');
console.log('🛠️ Try the different controls to see high-performance DOM manipulation techniques!');
```